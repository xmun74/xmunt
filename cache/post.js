export const cachedPosts = [
  {
    slug: 'crlf',
    title: '개행.줄바꿈.EOL(end-of-line)문자란? - CR, LF',
    content:
      '\n# 어쩌다 LF를 검색…?\n\n다짜고짜 LF와 CR에 대해서 알고싶어서(?!) 이를 검색해본 건 아니고\n아래와 같은 에러를 만나서 이에 대해 알아보게되었다.\n윈도우 환경에서(중요) eslint, prettier를 설정하던 중 코드의 마침부분마다 에러가 표시되고 있었다.\n\n### 에러\n\n```\nDelete `␍`\n```\n\n![241013-173454](/images/posts/crlf/241013-173454.png)\n\n<br />\n\n### 원인\n\n- 회사는 윈도우고 개인 노트북은 맥인데,\n  맥에서 작성했던 prettierrc를 그대로 복붙했더니 문제가 발생했던 것이다.\n\n### 해결 방법\n\n- "endOfLine": "lf"에서 "auto"로 변경\n  `"endOfLine": "auto",`\n\n```js\n{\n  "semi": true,\n  "singleQuote": false,\n  "tabWidth": 2,\n  "trailingComma": "es5",\n  "arrowParens": "avoid",\n  "bracketSameLine": false,\n  "bracketSpacing": true,\n  //  "endOfLine": "lf", // 삭제\n  "endOfLine": "auto", // 추가\n   "printWidth": 120,\n  "proseWrap": "preserve"\n}\n\n```\n\n- Prettier v2.0.0부터 endOfLine의 기본값이 auto에서 lf로 변경됨\n  - [Options · Prettier](https://prettier.io/docs/en/options.html#end-of-line)\n\n---\n\n<br /><br />\n\n# 줄바꿈의 시작\n\n![](https://velog.velcdn.com/images/xmun74/post/267298e1-ed2e-46c7-9f27-4ca5a9ac02d7/image.gif)\n\n- [참고 영상](https://www.youtube.com/watch?v=FkUXn5bOwzk)\n\n![241013-173532](/images/posts/crlf/241013-173532.png)\n\nLF와 CR이란 용어는 `타자기`에서 부터 의미가 시작된다.\n\n타자를 입력할 때마다 종이가 오른쪽에서 왼쪽으로 움직이는데\n한 줄을 다 입력해서 오른쪽 끝에 다다르면 다음줄 + 맨 처음으로 이동해야한다.\n이때 2가지의 동작이 이뤄진다.\n\n1. 왼쪽 레버를 오른쪽으로 당겨서 종이의 맨 왼쪽으로 이동하고\n2. 다음줄로 넘어가기 위해 종이를 위로 올려서 세로 줄넘김을 한다.\n\n- `Carriage`란 종이를 고정해주는 롤처럼 생긴 장치다.\n- `Carriage Return`은 레버를 당겨서 종이를 맨 왼쪽으로 이동시키기는 것을 뜻한다.\n- `Line Feed`는 한줄만큼 종이를 위로 올려서 세로 줄넘김하는 것을 말한다.\n\n<br />\n\n### 1. CR `\\n`\n\nCarriage Return : 커서를 맨앞으로 이동 (가로)\n\n### 2. LF `\\r`\n\nLine Feed : 커서는 그대로인 상태에서 다음줄로 이동 (세로)\n\n### CRLF `\\r\\n`\n\nCarriage Return Line Feed : 커서 맨앞 이동 + 다음줄 이동\n\n- CR과 LF의 조합\n\n<br /><br />\n\n## 운영체제 별 개행\n\n코드 작성할 때 키보드 `엔터` 키를 누를때마다 개행문자라는 보이지 않는 문자가 삽입된다.\n그런데 운영체제마다 기본으로 채택하고 있는 line ending 개행문자(줄바꿈) 처리방식이 다르다.\n\n#### 1. Windows OS\n\n- 두가지를 조합한 CRLF `\\r\\n` 채택\n- 윈도우에서 LF 개행으로 된 파일을 읽을 때 깨짐 현상 발생\n  1. 줄바꿈 충돌로 글자가 붙여서 보여짐\n  2. 글자 제일 마지막에 특수문자 `^M` 이 출력됨\n\n#### 2. UNIX 및 MAC OS(9 버전 이후)\n\n- LF `\\n` 채택\n- MAC OS 9 이전 버전 (매킨토시:Machintosh) - CR 채택\n  원래 초창기 9버전 이전에는 CR를 사용했지만,\n  그 이후부터는 Unix와 일치하는 LF로 변경됐다.\n\n![241013-173706](/images/posts/crlf/241013-173706.png)\n\n> - 이스케이프 시퀀스란?\n>   프린트할 수 없지만 개념상 있는 문자 (예: 개행`\\n`, 탭`\\t`)\n\n<br/>\n- 자바스크립트에서 keyCode가 13이면 엔터를 의미하는데 이 아스키코드에서 나온 것이다.\n\n<br /><br />\n\n# 그러면 왜 지금은 개행방식이 나눠졌나?\n\n1963~1968년까지 ISO(국제표준화기구)에서는 개행문자로 CR+LF를 채택했다. 밑 사진의 텔레타이프라는 전신타자기에서 주로 사용됐다.\n\n그러다가 1964년 등장한 멀틱스 운영체제에서부터 개행문자를 LF만으로 채택하기 시작했다. 이는 컴퓨터가 막 등장하던 시기여서 메모리 비용이 비쌌기 때문에 바이트가 작은 LF만은 채택한 것이다.\nUnix와 리눅스도 멀틱스의 관례를 이어나가게 됐다.\n윈도우는 1981년 등장한 DOS 운영체제의 CR+LF 방식의 관례를 따르게 된 것이다.\n\n- [텔레타이프 (전신타자기)](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%8B%A0%ED%83%80%EC%9E%90%EA%B8%B0)\n  ![241013-173750](/images/posts/crlf/241013-173750.png)\n\n<br /><br /><br /><br />\n\n# Git에서의 줄 끝\n\nGit으로 개발자들과 협업하는데 윈도우와 맥을 혼용해서 코드를 올리고 있었다면,\n컴퓨터에서는 CRLF와 LF의 각 바이트 값이 다르기 떄문에 다르게 인식한다.\n그래서 형상관리 툴에서는 개행방식이 다르면 diff로 인식되어 서로 다른 코드라고 보게 된다.\n따라서 git commit할 때 실제 변경하지 않은 파일도 개행방식이 다른 것 때문에 변경된 것으로(CRLF에서 LF로 변환 또는 반대) 잘못 인식하게 된다.\n\n- 윈도우에서 `git add .` 시 밑과 같은 warning을 만나게 된다.\n\n```\nwarning: LF will be replaced by CRLF in 파일경로\nThe file will have its original line endings in your working directory\n```\n\n이는 커밋 내역, 코드 이력관리에 좋지 않으므로 설정이 필요하다.\n\n> 협업 시 개발자 간 사용중인 OS가 다를 경우 Git에서 예기치 않은 문제가 생길 수 있다.\n\n### [해결방법](https://docs.github.com/ko/get-started/getting-started-with-git/configuring-git-to-handle-line-endings?platform=mac)\n\n- Windows OS\n\n```bash\ngit config --global core.autocrlf true\n```\n\n1. Git에서 가져올 때 - Git LF -> Windows CRLF로 변경\n2. Git에 전송할 때 - Window CRLF -> Git LF로 변경\n\n- Mac OS\n\n```bash\ngit config --global core.autocrlf input\n```\n\n- [Prettier 참고](https://prettier.io/docs/en/options.html#end-of-line)\n\n<br /><br /><br /><br />\n\n#### VSCode 개행 확인\n\n- 윈도우 VSCode는 개행이 CRLF로 기본설정 되어 있다.\n  ![241013-173810](/images/posts/crlf/241013-173810.png)\n\n- 맥 VSCode는 개행이 LF로 기본설정 되어 있다.\n  ![241013-173817](/images/posts/crlf/241013-173817.png)\n\n<br /><br /><br /><br />\n\n# 참고\n\n- [Carriage return - wiki](https://en.wikipedia.org/wiki/Carriage_return#Computers)\n\n- [Why is the line terminator CR+LF? - Microsoft, Raymond Chen](https://devblogs.microsoft.com/oldnewthing/20040318-00/?p=40193)\n\n- https://www.aleksandrhovhannisyan.com/blog/crlf-vs-lf-normalizing-line-endings-in-git/\n\n- [개발 용어 : 캐리지 리턴(CR), 라인 피드 (LF) 알아보기](https://jw910911.tistory.com/90)\n\n- [LF와 CRLF의 차이 (Feat. Prettier)](https://velog.io/@jakeseo_me/LF와-CRLF의-차이-Feat.-Prettier)\n',
  },
  {
    slug: 'giscus',
    title: 'Next.js 블로그에 댓글기능 추가하기 - Giscus',
    content:
      "\n# 댓글 기능을 추가하자\n\n#### 댓글기능을 구현한 오픈소스들\n\n오픈소스를 사용해서 손쉽게 댓글기능을 추가할 수 있다.\n그 중 [giscus](https://giscus.app/ko)는 Github API를 사용하여 Discussions으로 불러오기 때문에 대댓글을 작성할 수 있고 시간순/인기순 정렬, 리액션 추가, 지연 로딩 등을 지원해줘서 해당 오픈소스를 선택했다.\n\n1. [giscus](https://giscus.app/ko) - Github Discussions 기능을 사용\n2. [utterances](https://utteranc.es/) - Github Issue 기능을 사용\n3. [disqus](https://disqus.com/)\n\n<br></br>\n\n# Setting\n\n1. Github 블로그 프로젝트 레포가 `Public`이어야 함\n2. [Discussions 기능 활성화](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/enabling-or-disabling-github-discussions-for-a-repository)\n\n- 레포 Settings - Features탭에 Discussions 체크\n  ![](https://velog.velcdn.com/images/xmun74/post/a9d1c359-10f6-4adb-b278-ef75eb261b45/image.png)\n\n3. 해당 레포에 [giscus 앱 설치](https://github.com/apps/giscus)\n4. [한글 공식문서](https://giscus.app/ko)따라 설정하기\n   설정 부분 보면서 원하는대로 config를 정하면 자동으로 `script` 태그를 생성해주는데 이 `script` 태그를 코드에 넣으면 된다.\n   ```html\n   <script\n     src=\"https://giscus.app/client.js\"\n     data-repo=\"[복붙]\"\n     data-repo-id=\"[복붙]\"\n     data-category=\"General\"\n     data-category-id=\"[복붙]\"\n     data-mapping=\"pathname\"\n     data-strict=\"0\"\n     data-reactions-enabled=\"1\"\n     data-emit-metadata=\"0\"\n     data-input-position=\"bottom\"\n     data-theme=\"preferred_color_scheme\"\n     data-lang=\"ko\"\n     data-loading=\"lazy\"\n     crossorigin=\"anonymous\"\n     async\n   ></script>\n   ```\n\n# 블로그에 적용한 코드\n\n- Next.js를 기반으로 `script`태그에 config 속성 적용한 코드\n\n  ```tsx\n  import { useRouter } from 'next/router'\n  import { useEffect, useRef, useState } from 'react'\n  import { useRecoilValue } from 'recoil'\n  import { getLocalStorage } from '../lib/localStorage'\n  import themeState from '../states/atoms/theme'\n\n  export default function Giscus() {\n    const refEl = useRef<HTMLDivElement>(null)\n    const router = useRouter()\n\n    function getInitTheme() {\n      if (typeof window !== 'undefined') {\n        const localTheme = getLocalStorage('theme')\n        if (localTheme) {\n          return localTheme\n        }\n        return 'light'\n      }\n      return 'light'\n    }\n    const theme = useRecoilValue(themeState) === 'dark' ? 'dark' : 'light' // 테마 토글버튼 클릭 시 변경하기\n\n    useEffect(() => {\n      const curTheme = getInitTheme() === 'dark' ? 'dark' : 'light' // 새로고침 시 저장된 테마 불러오기\n      if (!refEl.current || refEl.current.hasChildNodes()) return\n\n      const scriptEl = document.createElement('script')\n      scriptEl.src = 'https://giscus.app/client.js'\n      scriptEl.async = true\n      scriptEl.crossOrigin = 'anonymous'\n      scriptEl.setAttribute('data-repo', 'xmun74/xmunt')\n      scriptEl.setAttribute('data-repo-id', 'R_kgDOIwVyxg')\n      scriptEl.setAttribute('data-category', 'General')\n      scriptEl.setAttribute('data-category-id', 'DIC_kwDOIwVyxs4CUrIr')\n      scriptEl.setAttribute('data-mapping', 'pathname')\n      scriptEl.setAttribute('data-strict', '0')\n      scriptEl.setAttribute('data-reactions-enabled', '1')\n      scriptEl.setAttribute('data-emit-metadata', '0')\n      scriptEl.setAttribute('data-input-position', 'bottom')\n      scriptEl.setAttribute('data-theme', curTheme)\n      scriptEl.setAttribute('data-lang', 'en')\n      scriptEl.setAttribute('data-loading', 'lazy')\n\n      refEl.current.appendChild(scriptEl)\n    }, [])\n\n    useEffect(() => {\n      const iframe = document.querySelector<HTMLIFrameElement>(\n        'iframe.giscus-frame',\n      )\n      iframe?.contentWindow?.postMessage(\n        { giscus: { setConfig: { theme } } },\n        'https://giscus.app',\n      )\n    }, [theme])\n\n    return <section ref={refEl} />\n  }\n  ```\n\n- theme에 맞게 댓글테마도 변경해야해서 테마와 관련된 코드를 추가했다.\n  https://github.com/giscus/giscus/issues/336 를 참고하여 코드를 작성했다.\n\n#### 참고\n\nhttps://github.com/giscus/giscus/issues/336\n",
  },
  {
    slug: 'git-branch',
    title: 'Git 브랜치 전략',
    content:
      '\n# Git Flow\n\n깃 플로우는 2010년도 Vincent Driessen이 제안한 전략이다. 브랜치 전략을 검색하면 나오는 유명한 도식도도 밑 포스팅 하단 링크에 들어가면 확인할 수 있다.\n\n- [A successful Git branching model - Vincent Driessen이 제안한 브랜치 전략(2010년)](https://nvie.com/posts/a-successful-git-branching-model/)\n\n![241027-221924](/images/posts/git-branch/241027-221924.png)\n\n위 그림에 정의된 브랜치를 나열하면 밑처럼 구성되어 있다.\n\n1. `master(main)` : 배포된 프로덕션 브랜치\n2. `develop` : 다음 버전 개발 완료 후 main 브랜치로 머지\n3. features(`feature/branch-name`) : 기능 개발 후 develop 브랜치로 머지\n4. releases(`release/v1.1`)\n   : develop 브랜치에서 따와서 bugfix나 수정을 하고 배포 준비 테스트를 마치면 main, develop 브랜치에 머지\n5. hotfixes(`hotfix/v1.1`)\n   : 배포 후 문제 발생 시 main에서 가져와서 문제해결 후 main, develop 브랜치에 머지\n\n<br />\n\n#### 💁 누가 사용하는 것이 적합한가요?\n\n1. 안정적으로 관리 가능한 장기간의 릴리스 주기를 가진 팀\n2. 병렬적으로 다중 버전관리가 필요한 `앱, 라이브러리/프레임워크` 등에 적합할 수 있다.\n   - 이유\n     - **앱**을 사용자가 업데이트 안할 수도 있기 때문에 이전 버전도 지원해야 함\n     - **라이브러리/프레임워크**들은 특정 버전으로 설치가 가능함.\n       예) `npm -D react@^16.8.0 react-dom@16.8.0`\n\n> ### 웹 개발자들은 Git Flow가 복잡해요 🤯\n>\n> `웹 어플리케이션 개발자들은 ...`\n>\n> - 하루에 **여러 번 배포**하기도 하는데\n>   복잡한 git flow는 작업 속도를 늦추고, 다양한 브랜치를 관리하는데 복잡도가 증가한다는 단점이 있습니다. 이는 빠른 개발 사이클과 안맞기 때문입니다.\n>\n> - 병렬적으로 다중 버전관리가 아닌, **가장 최신의 단일 버전만을 관리**하면 되기 때문입니다.\n>   이에 대한 내용은 Vincent Driessen님의 [글 상단](https://nvie.com/posts/a-successful-git-branching-model/) `반성문`이라는 코멘트에서 확인할 수 있다.\n>   ![241027-221940](/images/posts/git-branch/241027-221940.png)\n\n---\n\n<br /><br />\n\n# [GitHub Flow](https://githubflow.github.io/)\n\n: main 브랜치와 함께 기능 브랜치로는 feature를 사용하는 전략\n\n1. `master(main)` : 배포되는 브랜치\n2. `features` : 기능 브랜치\n\n- 바로 밑에서 소개하는 TBD와 유사하지만, 차이점을 말해보자면 밑과 같은 내용이 있다.\n- GitHub에서의 브랜치는 장기간의 기능 브랜치라는 점에서 차이가 있다.\n- GitHub Flow는 기능이 완료된 이후에 머지 수행하지만, TBD는 하루에도 여러번 병합을 수행한다.\n- GitHub Flow는 기능 개발 주기가 긴 반면, TBD는 빠르면서 점진적인 개발 주기를 가져간다.\n\n<br /><br /><br /><br />\n\n---\n\n# [Trunk-based Development(TBD)](https://trunkbaseddevelopment.com/)\n\n: 모든 개발자가 `trunk(or main)` 단일 브랜치를 항상 배포 가능한 상태로 유지하는 방식.\n\n- 각 개발자들은 신규 기능을 바로 main에 작은 단위로 commit한다.\n- 브랜치를 사용하려면 작은 단위의 짧은 수명을 가진 feature 브랜치를 사용한다.\n- 빠른 릴리스가 가능\n- [Google](https://cloud.google.com/architecture/devops?hl=ko), Facebook 등 대규모 연속 배포, 고속 릴리스를 안정적으로 수행하는 대규모 서비스에서 사용하는 방식.\n\n> trunk(나무 줄기:주요코드)라는 명칭과 branch(나뭇가지:기능,변경사항)를 비유로 사용.\n\n![241027-221952](/images/posts/git-branch/241027-221952.png)\n\n#### 특징\n\n1. 짧은 수명(sort-lived)의 기능 브랜치\n   : 머지 지옥(충돌해결 문제)을 되도록 피하기 위해서 장기간의 브랜치를 사용하지 않는다. commit의 단위를 작게 가져가거나, 브랜치의 기간을 짧게 가져간다.\n2. 빠른 코드 리뷰, 페어 프로그래밍\n   : main에 바로 commit 해야되기 때문에 코드의 안정성과 품질이 보장되어야한다. 그래서 이를 위해서 페어 프로그래밍이나 코드리뷰 등의 과정이 필요하다.\n   페어 프로그래밍을 하면서 자연스럽게 코드 내용에 대해서 공유, 오류 검출 등의 작업을 하거나 아니면 빠른 코드리뷰를 통해서라도 코드 품질을 높이는 작업을 수행한다.\n3. 자동화 테스트 구축\n   : 마찬가지로 코드 안정성과 품질을 보장하기 위한 테스트 과정이 필요하다. 테스트를 통과했을 때 머지가 되도록 자동화 테스트가 구축되어야 한다.\n4. 소규모 CI/CD 자동화\n5. 큰 기능 개발의 경우는 Feature Toggles 사용\n   : 큰 단위의 신규 기능이어서 장기간 작업이 이뤄질 경우에 main에 푸시할 경우, 해당 기능은 아직 운영에 보이지 않게 비활성화해야하는 경우가 있다. 이런 경우는 아직 작업 진행중인 기능을 비활성화한 상태로 병합할 수 있도록 Feature Toggle를 사용한다. 또는 브랜치 추상화([Branch by abstraction](https://trunkbaseddevelopment.com/branch-by-abstraction/))를 활용한다.\n\n<br />\n\n#### [Feature Toggles(Feature Flags)](https://martinfowler.com/articles/feature-toggles.html)란?\n\n- 특정 기능을 배포 이후 비활성화 또는 활성화해서 토글할 수 있음.\n- 특정 기능을 특정 유저에게만 운영환경에서 테스트 가능하게 활성화할 수 있음.\n\n---\n\n<br /><br />\n\n## GitLab Flow\n\n: GitLab을 활용하여 Merge, CI/CD와 연관되고 다양한 환경에서의 배포에 초점이 맞춰진 전략 - [GitLab 참고](https://about.gitlab.com/blog/2023/07/27/gitlab-flow-duo/)\n\n1. `master(main)`\n   : feature가 완료되어 pr을 받고 production에 나가는 브랜치(이전 develop과 동일)\n2. `feature` : master에서 파생되고 머지\n3. `pre-production`\n   : master와 production 사이의 단계로 테스트 서버에 배포해서 테스트하는 브랜치\n4. `production` : 배포 브랜치\n\n---\n\n<br /><br /><br /><br />\n\n# 참고\n\n- https://trunkbaseddevelopment.com/\n- [A successful Git branching model - Vincent Driessen](https://nvie.com/posts/a-successful-git-branching-model/)\n',
  },
  {
    slug: 'github-actions-be-01',
    title: 'Github Actions - 백엔드 CI/CD 구축하기',
    content:
      "\n## 도입 배경\n\n#### [문제] 프리티어 EC2 인스턴스에서 서버 빌드가 너무 오래 걸린다.\n\n![](https://velog.velcdn.com/images/xmun74/post/62f62e8b-b94b-4c90-b403-c76f1bca95f3/image.png)\nnodeJS, express, Typescript로 백엔드를 만들어서 인스턴스 내에서 빌드하는 과정이 있었습니다. 그런데 EC2 인스턴스에서 `yarn tsc` 빌드 명령어를 수행하면 30분 이상 그냥 저대로 멈춰있었습니다.\n계속 저 상태로 놔두면 인스턴스 상태검사(연결성 검사)에서 통과되지 않는 상황으로 바뀌기도 했습니다. 상태검사가 통과가 안되는 상태로 바뀌면 EC2 인스턴스 콘솔과 SSH 클라이언트에서 접속이 불가해지는 문제로 이어졌습니다. 그래서 상태검사를 통과시키기 위해 인스턴스 중지했다가 다시 시작해야 했습니다.\n\n#### [원인] 프리티어 t2.micro 인스턴스 메모리 부족\n\n프리티어로 사용중이던 t2.micro 인스턴스는 1G 메모리밖에 안돼서 서버 빌드가 중단되거나 오래 걸린다고 합니다. 인스턴스 유형을 바꾸고 돈을 더 내면 간단한 문제지만, 개인 프로젝트였기 때문에 프리티어 계정을 사용하여 무료로 이용해야 한다는 제한을 두고 진행해야했습니다.\n\n#### [해결 방법]\n\n1. [스왑 파일로 디스크의 RAM을 임시 메모리로 끌어와 사용하는 것](https://repost.aws/ko/knowledge-center/ec2-memory-swap-file)\n   단점\n   - 스왑 공간은 디스크에 위치하기 때문에 RAM에 비해 느린 HDD을 사용하게 되어 I/O 속도가 느려져서 서버 성능이 저하될 수 있음\n2. 인스턴스 외 환경에서 빌드, 배포하기 (CI/CD)\n\n1번 방법은 서버 성능 저하와 메모리 관리 복잡성이 증가한다는 단점이 존재하기때문에 현재 상황에서는 2번인 인스턴스 외 환경에서 빌드/배포하는 방법을 선택했습니다.\n원래는 CI/CD를 빌드/배포 자동화의 도구라고만 생각했었는데 위 배경처럼 메모리가 부족한 문제 상황에서 해결 방법으로 선택할 수 있음을 다시 배울 수 있었습니다.\n<br /><br />\nCI/CD로는 Github Actions, 젠킨스 등이 있습니다. Github Actions는 무료 계정으로 현재 월 2000분, 500MB까지 무료로 사용할 수 있다고 합니다. ([GitHub Actions 청구 정보](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#included-storage-and-minutes))\n그래서 Github Actions를 사용해서 구축해보았습니다.\n\n<br /><br /><br /><br />\n\n---\n\n<br />\n\n# Github Action 흐름\n\n> Github에 PUSH(트리거) - Build - Test - Deploy\n\n제 NodeJS 백엔드는 Test가 없기 때문에 일단 크게 Build와 Deploy의 흐름으로 작성했습니다.\n시작하기에 앞서 루트에 `.github/workflows` 폴더 생성 후 `파일명.yml`파일을 생성합니다.\n\n#### 진행 과정\n\n1. Github 특정 브랜치에 Push하면\n2. 빌드한 다음 빌드된 결과물을 압축\n3. 압축된 빌드 결과물을 EC2 인스턴스에 전송\n4. 배포 과정을 담은 sell script 실행\n\n## 1. Github 특정 브랜치에 PUSH하면\n\n```yml\nname: CI-CD-server\n\non:\n  push:\n    branches:\n      - master\n```\n\n- `on` : `jobs`이 실행될 상황 정의.\n  master 브랜치에 push할 때 jobs를 실행하게 했습니다.\n\n## 2. 빌드한 다음 빌드된 결과물을 압축\n\n```yml\njobs:\n  build-and-deploy-server:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [18.x]\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: ⎔ Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: ⎔ Install packages\n        run: yarn\n```\n\n- `jobs` - 실행될 작업 내용을 작성.\n\n1. `actions/checkout@v3`\n   Runner(workflow 실행환경)가 현재 Github 저장소 소스코드에 체크아웃됩니다.\n2. `⎔ Use Node.js ${{ matrix.node-version }}`\n   인스턴스와 동일한 node 버전(18.x)으로 적용합니다.\n3. `⎔ Install packages`\n   yarn 명령어로 패키지들 설치합니다.\n\n```yml\n\t  - name: ⎔ Build server\n        env:\n          COOKIE_SECRET: ${{ secrets.COOKIE_SECRET}}\n          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME}}\n          MYSQL_PWD: ${{ secrets.MYSQL_PWD}}\n          MYSQL_HOST: ${{ secrets.MYSQL_HOST}}\n          PORT: ${{ secrets.PORT}}\n          KAKAO_ID: ${{ secrets.KAKAO_ID}}\n          FRONTEND_URL: ${{ secrets.FRONTEND_URL}}\n          REDIS_HOST: ${{ secrets.REDIS_HOST}}\n          REDIS_PORT: ${{ secrets.REDIS_PORT}}\n          REDIS_PWD: ${{ secrets.REDIS_PWD}}\n        run: |\n          yarn build\n\n      - name: ⎔ Package dist Folder\n        run: tar -czvf dist.tar.gz dist\n```\n\n4. `⎔ Build server`\n   env 환경변수들을 가져오고 빌드하기\n5. `⎔ Package dist Folder`\n   빌드한 dist 폴더를 tar 파일로 압축하기\n\n## 3. 압축된 빌드 결과물을 EC2 인스턴스에 전송\n\n```yml\n- name: ⎔ Deploy to Amazon ECS\n  uses: appleboy/scp-action@master\n  with:\n    host: ${{ secrets.EC2_IP }}\n    username: ${{ secrets.EC2_USER }}\n    key: ${{ secrets.EC2_PEM_KEY }}\n    source: 'dist.tar.gz'\n    target: ${{ secrets.SERVER_PATH }}\n```\n\n#### [appleboy/scp-action@master](https://github.com/appleboy/scp-action)\n\n: GitHub Actions에서 사용되는 SCP(Secure Copy Protocol)를 이용한 파일 전송 액션입니다. 이는 workflow가 실행된 후에 생성된 파일들을 다른 서버로 안전하게 복사하는 데 사용합니다.\n\n- 액션에 전달할 값 (유출하면 안됨)\n  - host: EC2 퍼블릿 IP 주소\n  - username: EC2 인스턴스 접속위한 사용자명\n  - key: 인스턴스 생성할 때 다운받은 pem key\n  - source: 복사할 파일. 빌드폴더를 압축한 파일을 적었습니다.\n  - target: 복사한 파일이 전송될 서버 내 경로.\n\n#### Github에 secrets 등록하기\n\n1. GitHub 레포에서 Settings > Secrets > `New repository secret` 클릭\n2. `Name` 필드에 지정할 이름(예:EC2_KEY)을 입력하고,\n   `Value` 필드에 복사한 키 내용을 붙여넣기\n3. `Add secret` 클릭하여 저장\n\n#### pem 파일 로컬에서 여는 방법\n\n1. 로컬 터미널에서 해당 pem파일이 위치하는 폴더로 가서\n2. `cat 파일명.pem` 입력\n3. (-----BEGIN RSA PRIVATE KEY----- 로 시작하여 -----END RSA PRIVATE KEY----- 로 끝나는 부분) 전체를 복사\n4. GitHub Secrets에 등록하기\n\n## 4. 배포 과정을 담은 sell script 실행\n\n```yml\n- name: ⎔ Execute shell script\n  uses: appleboy/ssh-action@master\n  with:\n    host: ${{ secrets.EC2_IP }}\n    username: ${{ secrets.EC2_USER }}\n    key: ${{ secrets.EC2_PEM_KEY }}\n    script: |\n      cd ${{ secrets.SERVER_PATH }}\n      sudo tar -xzvf dist.tar.gz\n      git pull origin 브랜치명\n      yarn\n      pm2 kill\n      pm2 start dist/index.js\n```\n\n#### [appleboy/ssh-action@master](https://github.com/appleboy/ssh-action)\n\n: SSH(Secure Shell: 원격 컴퓨터를 안전하게 제어하고 전송하기 위한 프로토콜)를 통해 원격 서버에 접속하여 명령어를 실행하는 액션.\n\n- host, username, key는 scp와 똑같이 입력했습니다.\n- script\n  평소 코드를 push하고 인스턴스에서 반복 작업하던 명령어들을 script에 작성합니다. 여기서 위에서 압축했던 파일을 압축해제하는 코드를 추가합니다.\n  ```bash\n  cd 프로젝트폴더\n  sudo tar -xzvf dist.tar.gz  #빌드폴더 파일압축 해제\n  git pull origin 브랜치명\n  yarn\n  pm2 kill  #실행중이던 pm2 종료\n  pm2 start dist/index.js   #pm2 실행하기\n  ```\n\n---\n\n## 전체 코드\n\n```yml\nname: CI-CD-server\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build-and-deploy-server:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [18.x]\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: ⎔ Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: ⎔ Install packages\n        run: yarn\n\n      - name: ⎔ Build server\n        env:\n          COOKIE_SECRET: ${{ secrets.COOKIE_SECRET}}\n          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME}}\n          MYSQL_PWD: ${{ secrets.MYSQL_PWD}}\n          MYSQL_HOST: ${{ secrets.MYSQL_HOST}}\n          PORT: ${{ secrets.PORT}}\n          KAKAO_ID: ${{ secrets.KAKAO_ID}}\n          FRONTEND_URL: ${{ secrets.FRONTEND_URL}}\n          REDIS_HOST: ${{ secrets.REDIS_HOST}}\n          REDIS_PORT: ${{ secrets.REDIS_PORT}}\n          REDIS_PWD: ${{ secrets.REDIS_PWD}}\n        run: |\n          yarn build\n\n      - name: ⎔ Package dist Folder\n        run: tar -czvf dist.tar.gz dist\n\n      - name: ⎔ Deploy to Amazon ECS\n        uses: appleboy/scp-action@master\n        with:\n          host: ${{ secrets.EC2_IP }}\n          username: ${{ secrets.EC2_USER }}\n          key: ${{ secrets.EC2_PEM_KEY }}\n          source: 'dist.tar.gz'\n          target: ${{ secrets.SERVER_PATH }}\n\n      - name: ⎔ Execute shell script\n        uses: appleboy/ssh-action@master\n        with:\n          host: ${{ secrets.EC2_IP }}\n          username: ${{ secrets.EC2_USER }}\n          key: ${{ secrets.EC2_PEM_KEY }}\n          script: |\n            cd ${{ secrets.SERVER_PATH }}\n            sudo tar -xzvf dist.tar.gz\n            git pull origin 브랜치명\n            yarn\n            pm2 kill\n            pm2 start dist/index.js\n```\n\n- Github에 push 후, CI/CD가 잘 작동하는 것을 확인할 수 있었습니다.\n  ![](https://velog.velcdn.com/images/xmun74/post/660cd926-c776-4ef7-8081-ee4cc8557032/image.png)\n\n<br /><br />\n\n---\n\n<br /><br /><br /><br /><br />\n\n참고\n\n- [zero-black 벨로그 - [github-actions] 리액트 빌드하기](https://velog.io/@zero-black/github-actions-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0)\n- [oscar0421 벨로그 -[github action] 빌드부터 배포까지!](https://velog.io/@oscar0421/github-action-%EB%B9%8C%EB%93%9C%EB%B6%80%ED%84%B0-%EB%B0%B0%ED%8F%AC%EA%B9%8C%EC%A7%80#workflow-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0)\n",
  },
  {
    slug: 'github-actions-fe-01',
    title: 'Github Actions - 프론트엔드 CI/CD 구축하기 (S3, CloudFront)',
    content:
      '\n# IAM\n\nIAM(Identity and Access Management)\n: 외부에서 AWS 리소스에 대한 액세스 권한을 안전하게 제어하는 서비스\n\n- 예시\n  - Github Actions에서 S3에 접근할 때.\n  - NodeJS에서 S3에 이미지 업로드하기 위해서 S3에 접근할 때\n\n---\n\n# 1. IAM 사용자 생성하기\n\nGithub Actions에서 S3에 업로드하고 CloudFront의 캐시를 무효화하기 위해서 IAM 사용자를 사용하여 접근해보겠습니다.\n\n- IAM - 사용자 메뉴 - 사용자 생성\n  ![](https://velog.velcdn.com/images/xmun74/post/af81dce3-b0ba-4ff2-978e-cd90feebb2de/image.png)\n- 사용자 이름 입력\n  ![](https://velog.velcdn.com/images/xmun74/post/3bce27ab-0ad6-4784-90bb-580d58ff895b/image.png)\n- 직접 정책 연결 체크 후\n  `AmazonS3FullAccess`와 `CloudFrontFullAccess` 체크.\n  Github Actions에서 S3와 CloudFront에 접근할 것이기에 위에 2개를 체크해줬다.\n  ![](https://velog.velcdn.com/images/xmun74/post/a5748d37-d2d8-4374-aaba-8a8b10a0bf21/image.png)\n  ![](https://velog.velcdn.com/images/xmun74/post/948ecdfd-49dc-4905-9a2d-9525edc5d41e/image.png)\n- 검토 후 사용자 생성\n  ![](https://velog.velcdn.com/images/xmun74/post/62162fb4-96b0-49fd-999c-d7d2342b9cf5/image.png)\n- 생성된 사용자 이름 클릭\n  ![](https://velog.velcdn.com/images/xmun74/post/a322554a-2a01-4be6-935b-3ebbee72a87c/image.png)\n- 보안 자격 증명 탭 - 액세스 키 만들기\n  : 외부에서 사용할 수 있게 액세스 키를 생성한다.\n  ![](https://velog.velcdn.com/images/xmun74/post/71f79d3d-c8d2-4e4b-8ab7-20a30f36f060/image.png)\n- 사용 사례 - 서드 파티 (깃헙 등)\n  ![](https://velog.velcdn.com/images/xmun74/post/65c2955f-aa20-4a12-96b8-2e4ea98a4b8d/image.png)\n- 설명 태그 설정 - 설정하고 - 액세스 키 만들기\n  ![](https://velog.velcdn.com/images/xmun74/post/40ebafd2-3611-418f-aa58-6326643e4fcf/image.png)\n- 액세스 키 생성됨\n  🚨 이 페이지에서 바로 나가지 말고 깃헙 secrets에 등록하기\n  페이지를 나가면 다시 액세스 키를 보거나 다운받을 수 없습니다!\n  이 키는 절대 외부로 유출하면 안되기 때문에 Github Secret에 등록하여 깃헙에 올라가지 않게 합니다.\n  ![](https://velog.velcdn.com/images/xmun74/post/456d57cd-92aa-4f84-9165-8dd045e13aa1/image.png)\n- ✅[필수] 깃헙 레포 - Settings > Actions > New ~ secret 해서 등록하기\n  ![](https://velog.velcdn.com/images/xmun74/post/f767e337-a5ab-4469-b491-b7318aa063a3/image.png)\n\n---\n\n# 2. Github Actions CI/CD 작성\n\n#### jobs 진행 과정\n\n1. NodeJS 세팅\n2. yarn install\n3. build 하기\n4. AWS 인증 정보 설정\n5. AWS S3에 배포하기\n6. [AWS CloudFront 캐시 무효화](https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html)\n\n```yml\nname: CI-CD-biblical-web\n\non:\n  push:\n    branches:\n      - master\n    paths:\n      - \'apps/web/**\'\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [18.x]\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: ⎔ Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: ⎔ Monorepo install\n        uses: ./.github/actions/yarn-install\n\n      - name: ⎔ Build web\n        working-directory: apps/web\n        env:\n          API_URL: ${{ secrets.API_URL}}\n          USER_IMG_FIELD: ${{ secrets.USER_IMG_FIELD}}\n          CLIENT_URL: ${{ secrets.CLIENT_URL}}\n        run: |\n          yarn build\n\n      - name: ⎔ Configure AWS credentials\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          aws-access-key-id: ${{ secrets.AWS_KEY_ID }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}\n          aws-region: ap-northeast-2\n\n      - name: ⎔ Deploy to AWS S3\n        run: |\n          aws s3 sync --delete --region ap-northeast-2 apps/web/dist s3://S3버킷명\n\n      - name: ⎔ Invalidate AWS CloudFront Cache\n        run: |\n          aws cloudfront create-invalidation --distribution-id ${{ secrets.AWS_DISTRIBUTION_ID }} --paths "/*"\n```\n\n#### AWS S3에 배포하기\n\n`aws s3 sync --delete --region ap-northeast-2 apps/web/dist s3://버킷명`\n\n- sync : S3 버킷과 로컬폴더 간 동기화하기\n- --delete : 로컬에서 삭제된 파일은 S3 버킷에서도 삭제된다\n- --region ap-northeast-2 : 리전을 서울로 지정\n- apps/web/dist : 빌드폴더 경로\n  <br />\n\n#### AWS CloudFront 캐시 무효화\n\n`aws cloudfront create-invalidation --distribution-id ${{ secrets.AWS_DISTRIBUTION_ID }} --paths "/*"`\n\n- --paths "/\\*" : 모든 파일에 대한 캐시 무효화\n- 캐시 무효화하는 이유\n  : CloudFront의 캐시 정책을 `CachingOptimized`로 선택한 경우,\n  캐시 유지시간이 기본 TTL 24시간으로 설정되어 있다. 따라서 S3 버킷을 재업로드 후 변경된 사항을 배포된 cloudfront에서 바로 확인하고 싶다면 캐시 무효화를 해줘야 한다.\n- 참고로 캐시 객체 무효화는 매월 1000개 경로까지 무료이고 그 이상부터 경로당 0.005 USD 비용이 발생한다. ([CloudFront 비용](https://aws.amazon.com/ko/cloudfront/pricing/))\n\n<br /><br /><br /><br /><br />\n',
  },
  {
    slug: 'google-analytics',
    title: 'NextJS 블로그에 Google Analytics 추가하기',
    content:
      "\n# [Google Analytics](https://analytics.google.com/analytics)\n\n구글에서 무료로 제공하는 도구로 사이트에 들어오는 사용자 유입, 조회수, 사용자 유형 등을 분석하여 통계를 내준다\n\n1. 관리 - 데이터스트림 - 스트림 추가 - 내사이트 입력\n2. 태그 안내보기 - `직접 설치`\n3. 파일 설정 - [NextJS 예시](https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics/pages/_app.js)\n\n- 공식예시가 gtag.js여서 ts 타입 정의를 위해 설치\n\n  ```bash\n  npm i -D @types/gtag.js\n  ```\n\n- `lib/gtag.tsx` 생성\n\n```tsx:lib/gtag.tsx showLineNumbers\nimport { useRouter } from 'next/router'\nimport { useEffect } from 'react'\n\nexport const GA_TRACKING_ID = `G-로 시작하는 id복붙`\n\n// https://developers.google.com/analytics/devguides/collection/gtagjs/pages\nexport const pageview = (url: URL) => {\n  window.gtag('config', GA_TRACKING_ID, {\n    page_path: url,\n  })\n}\n\n// https://developers.google.com/analytics/devguides/collection/gtagjs/events\nexport const event = (\n  action: Gtag.EventNames,\n  { event_category, event_label, value }: Gtag.EventParams,\n) => {\n  window.gtag('event', action, {\n    event_category,\n    event_label,\n    value,\n  })\n}\n\n// page view\nexport const useGtag = () => {\n  const router = useRouter()\n  useEffect(() => {\n    const handleRouteChange = (url: URL) => {\n      pageview(url)\n    }\n    router.events.on('routeChangeComplete', handleRouteChange)\n    router.events.on('hashChangeComplete', handleRouteChange)\n    return () => {\n      router.events.off('routeChangeComplete', handleRouteChange)\n      router.events.off('hashChangeComplete', handleRouteChange)\n    }\n  }, [router.events])\n}\n```\n\n- `_app.tsx`에 추가하기\n\n```tsx:_app.tsx showLineNumbers\nimport Script from 'next/script'\nimport * as gtag from '../lib/gtag'\nimport isDev from '../lib/isDev'\n// 생략\nexport default function App({ Component, pageProps }: AppProps) {\n  gtag.useGtag()\n\n  return (\n    <RecoilRoot>\n      {/* 생략 */}\n      {!isDev && (\n        <>\n          <Script\n            id=\"gtag-init\"\n            dangerouslySetInnerHTML={{\n              __html: `\n                window.dataLayer = window.dataLayer || [];\n                function gtag(){dataLayer.push(arguments);}\n                gtag('js', new Date());\n                gtag('config', '${gtag.GA_TRACKING_ID}', {\n                  page_path: window.location.pathname,\n                });\n              `,\n            }}\n          />\n          {/* Global Site Tag (gtag.js) - Google Analytics */}\n          <Script\n            strategy=\"afterInteractive\"\n            src={`https://www.googletagmanager.com/gtag/js?id=${gtag.GA_TRACKING_ID}`}\n          />\n        </>\n      )}\n\n      {/* 생략 */}\n      <Component {...pageProps} />\n    </RecoilRoot>\n  )\n}\n\n```\n\n- `{!isDev && ( ... ) }` 배포 모드일때만 해당 script를 추가하게 함\n- 배포 후 사이트 html Elements탭에서 `id=\"gtag-init\"`으로 검색해서 잘 추가됐는지 확인하기\n- 구글 애널리틱스에 표시되기까지 24-48시간 정도 걸린다고 한다..\n\n## 실시간 사용자 수 보기\n\n- [Google Analytics](https://analytics.google.com/analytics)에 왼쪽 탭에서 `보고서` 클릭 - `실시간` 클릭\n  밑처럼 실시간 사용자 수를 분석한 통계를 볼 수 있다!\n  ![230316-132736](/images/posts/google-analytics/230316-132736.png)\n\n# Google Search Console과 연결\n\n구글에서 검색해서 들어온 통계를 보기 위해서 연결하기\n\n- 관리자 - Search Console 링크 - 연결\n  ![230309-161524](/images/posts/google-analytics/230309-161524.png)\n\n#### 구글 콘솔에서 사이트 통계보기\n\n- [구글 콘솔](https://search.google.com/search-console) - 개요 - 오른쪽 상단 `Search Console Insights` 클릭\n\n---\n\n#### 참고\n\n- [nextjs예시](https://github.com/vercel/next.js/tree/canary/examples/with-google-analytics)\n- https://kimyanglogging.tistory.com/3\n- https://velog.io/@yunsungyang-omc/Next.js-Google-Analystics-%EC%9D%B4%EC%8B%9D%ED%95%98%EA%B8%B0\n",
  },
  {
    slug: 'http-history',
    title: 'HTTP 버전 별 역사',
    content:
      '\n<br/><br/><br/><br/>\n\nHTTP(Hyper Text Transfer Protocol)는 웹 브라우저와 웹 서버 간에 통신을 위한 프로토콜(규약)로, 1989년에 팀 버너스리에 의해 처음 제안됐습니다. 웹 브라우저가 서버에 HTML 문서나 사진 등의 리소스를 요청하면, 서버는 필요한 문서를 응답으로 전달하게 식으로 동작합니다.\nHTTP 최초의 버전은 v0.9로 시작하여 가장 최신버전은 v3입니다. HTTP는 버전이 발전될수록 성능과 보안이 향상되었으며, 각 버전별로 어떤 특징이 있는지 살펴보겠습니다.\n\n<br/><br/><br/><br/>\n\n# HTTP 역사\n\n1. HTTP/0.9 - 1991년(최초 버전)\n2. HTTP/1.0 - 1996년\n3. HTTP/1.1 - 1997년(표준)\n4. HTTP/2.0 - 2015년\n5. HTTP/3.0 - 2021년\n\n<br/><br/><br/><br/>\n\n## 1. HTTP/0.9\n\n최초의 버전은 사실 버전이 없었기 때문에 v0.9 시점에서 이후에 생겨난 버전과 구분하기 위해 v0.9버전을 붙이게 됐습니다.\n\n#### 특징\n\n- 요청은 단일 라인\n- GET 메서드만 존재\n- HTTP 헤더가 없어서 HTML 외 다른 유형의 문서를 전달할 수 없었음\n\n```jsx\n/* 요청 */\nGET /helloworld.html\n\n/* 응답 */\n<html>\n  hello world !\n</html>\n```\n\n<br/><br/>\n\n## 2. HTTP/1.0\n\n#### 특징\n\n- 요청에 `버전 정보`가 포함됨\n- 요청 메서드가 `GET, HEAD, POST` 추가됨\n- 응답 시작부분에 `Status Code` 추가되어 성공/실패 여부 확인 가능\n- 요청과 응답에 `HTTP 헤더` 포함되어 메타데이터 전송 가능해짐\n- `Content-Type`이 추가되면서 HTML 문서 외 다른 문서도 전송 가능해짐\n\n#### 단점\n\n- 1개 요청마다 TCP 연결 새로 생성해야함\n  : 1개 웹 페이지에서 다수의 HTTP 리소스 요청할 때마다 TCP handshake 과정을 거쳐야 해서 속도가 느려지게 되는 단점이 발생합니다.\n\n```\n/* 요청 */\nGET /myimage.gif HTTP/1.0\nUser-Agent: NCSA_Mosaic/2.0 (Windows 3.1)\n\n/* 응답 */\n200 OK\nDate: Tue, 15 Nov 1994 08:12:32 GMT\nServer: CERN/3.0 libwww/2.17\nContent-Type: text/gif\n(image content)\n\n```\n\n<br/><br/>\n\n## 3. HTTP/1.1\n\n표준화 작업의 대상이 된 버전으로 1996년 11월에 발표된 1.0 버전에서 몇 달 뒤인 1997년 1월에 발표됐습니다.\n\n#### 특징\n\n- Persistent Connection(연결 유지)\n  : 지정된 timeout 동안 연결 재사용 가능해집니다. 1.0에서 요청에 대한 응답이 오면 TCP 연결이 종료되는 한계를 개선하기 위해 추가되었습니다.\n- Pipelining 추가\n  : 여러 요청을 처리할 때 앞순서의 응답을 기다리고 요청하는 것이 아니라 여러 요청을 한꺼번에 전송할 수 됐습니다. 그래서 통신 지연 시간이 단축됐습니다.\n- Chunked Transfer Encoding\n- Cache-Control\n- Host 헤더 추가\n  : 한 개의 IP에 여러 도메인을 호스트할 수 있게 가능해졌습니다.\n- 메서드 `OPTIONS, PUT, DELETE, TRACE` 추가\n\n#### 단점\n\n- HOL(Head Of Line) Blocking\n  : 앞 요청의 응답이 Blocking되어 너무 오래걸리면 뒷순서의 응답도 늦어지는 HOLB 문제가 발생합니다.\n- Header 구조 중복\n  : 헤더값이 중복되더라도 똑같은 내용으로 다시 요청해야하는 문제가 있습니다.\n\n<br/><br/>\n\n## 4. HTTP/2.0\n\n#### 특징\n\n- Binary Framing 계층 추가\n  : Text 형식의 메시지를 프레임단위로 나누고 Binary로 인코딩하여 데이터 전송합니다.\n- Header 압축\n- Multiplex Streaming\n  ![250216-233528](/images/posts/http-history/250216-233528.png)\n  : 하나의 TCP 연결에서 동시에 여러 요청을 병렬로 처리할 수 있게 됐습니다. TCP 연결을 Stream, Message, Frame 단위로 세부화합니다. 각 스트림이 하나의 프레임을 전송하고, 하나의 연결에서 여러 스트림을 가지게 되면서 동시에 여러 요청을 처리할 수 있게 됩니다. 이후 클라이언트 측에서 받은 데이터를 다시 조립하여 사용합니다. 이 다중화 덕분에 HOLB 문제를 해결할 수 있게 됩니다.\n- Stream Prioritization : 리소스 우선순위 설정 가능\n\n<br/><br/>\n\n## 5. HTTP/3.0\n\nTCP로 인해 발생하는 문제를 해결하기 위해 전송계층에서 TCP 대신 `QUIC`라는 프로토콜을 사용합니다.\n\n#### QUIC(Quick UDP Internet Connections)란?\n\n구글의 짐 로스킨드가 설계한 전송계층 통신 프로토콜입니다. TCP에서 신뢰성을 유지하기 위한 기능들을 UDP 기반으로 구현했습니다. 신뢰가 보장되지 않던 UDP 위에 혼잡제어, 흐름제어 등의 작업을 하는 QUIC 계층을 추가하여 신뢰성을 제공합니다.\n\n<br/><br/>\n\n- [RFC 1945](https://datatracker.ietf.org/doc/html/rfc1945)\n- [RFC 2068](https://datatracker.ietf.org/doc/html/rfc2068)\n- [HTTP의 진화 - MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Evolution_of_HTTP)\n',
  },
  {
    slug: 'https-01',
    title: 'HTTPS와 TLS',
    content:
      '\n<br /><br />\n\n# HTTPS란?\n\nHTTPS란 HTTP(Hypertext Transfer Protocol) 통신과정에서 보안을 강화한 프로토콜입니다. 웹 사이트 URL에 `http://`가 아닌 `https://`가 붙은 경우 HTTPS를 사용하고 있음을 확인할 수 있습니다.\nHTTP는 보안을 고려하지 않았기 때문에 요청이 평문으로 노출됩니다. 그래서 `스니핑`과 같은 해킹기법으로 신용카드 정보나 비밀번호 등 중요한 정보를 가로챌 수 있습니다. 이러한 보안 문제를 해결하기 위해서 HTTPS가 도입되었으며, TLS(또는 SSL)를 사용하여 HTTP 요청과 응답을 암호화함으로써 보안이 강화된 통신 환경을 제공하게 됐습니다. 예를 들어, 위치 정보 데이터를 조회하는 [HTML5 Geolocation API](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API) 같이 민감한 개인정보를 제공하는 기능은 HTTP에서 지원하지 않고 HTTPS환경에서만 지원되는 것을 확인할 수 있습니다.\n\n<br />\n\nTLS(Transport Layer Security:전송 계층 보안) 또는 SSL(Secure Sockets Layer:보안 소켓 계층)이라 불리는 이 프로토콜은 1995년 SSL 2.0이 처음 공개됐으며 이후 1999년 TLS가 등장했습니다. TLS는 SSL의 보안 취약점을 개선해서 등장했기 때문에 SSL은 이제 TLS로 대체되었습니다. 하지만 `SSL`이라는 명칭을 많이 사용했기 때문에 여전히 TLS와 SSL이라는 용어가 함께 사용되고 있습니다.\n\n<br /><br /><br />\n\n# 대칭키, 비대칭키, 하이브리드 암호화\n\n먼저 동작원리를 살펴보기에 앞서서 대칭키, 비대칭키를 알아보도록 하겠습니다.\n암호화 과정은 민감한 데이터를 암호화하고 권한있는 사용자가 데이터를 해독하도록 복호화 하는 과정을 말합니다.\n\n<br />\n\n![](https://velog.velcdn.com/images/xmun74/post/be07c0f6-0874-45bb-83b4-218a0ad7494c/image.png)\n\n#### 대칭키 방식\n\n동일한 1개의 키를 사용하여 암호화 및 복호화를 수행하는 방식입니다.\n\n- 장점: 간단한 구조로 구현에 용이하며 속도가 빠름\n- 단점: 원거리일때 안전하게 키 교환하는 것이 어려움, 키 유출될 경우 보안 문제 발생\n\n<br />\n\n![](https://velog.velcdn.com/images/xmun74/post/7d2243ec-26c2-46fa-98ab-f77a547f9818/image.png)\n\n#### 비대칭키 방식\n\n공개키(Public key)와 개인키(비밀키 Private key) 2개 키를 사용하는 방식입니다. Server는 공개키, 개인키로 key pair 쌍을 만듭니다. 그리고 공개키는 모두가 가질 수 있도록 배포하고 비밀키는 서버 자신만 보도록 보관합니다.이후 Client는 누구나 획득할 수 있는 Server의 공개키를 가지고 암호화하여 전송하고 Server는 자신만이 가진 개인키로 데이터를 복호화합니다.\n\n- 장점: 대칭키보다 안전하게 키 교환하고 관리하기 쉬움, 확장성 높음\n- 단점: 속도가 느리고 연산 복잡성 증가\n\n<br />\n\n![](https://velog.velcdn.com/images/xmun74/post/eb38964d-14c7-46f9-8f19-b8715cf02dc1/image.png)\n\n#### 하이브리드 방식\n\n대칭키와 비대칭키를 결합하여 장점을 활용하는 시스템입니다. 이렇게 대칭키 방식으로 빠른 속도를 유지하고 비대칭키의 장점으로 키 교환/관리 보안성 문제를 해결합니다. 이는 TLS/SSL 프로토콜에서 사용됩니다.\n\n1. Server는 공개키, 개인키 키페어를 생성해서 공개키를 Client에 전송합니다.\n2. Client는 Server의 공개키로 대칭키를 암호화하여 전송합니다.\n3. Server는 개인키로 대칭키를 복호화합니다. 따라서 대칭키가 양쪽에 있게 됩니다.\n4. Client는 대칭키로 암호화하여 데이터 전송합니다.\n5. Server는 대칭키로 데이터를 복호화합니다.\n\n<br /><br /><br /><br />\n\n---\n\n# TLS Handshake 과정\n\n![250302-234050](/images/posts/https-01/250302-234050.png)\n\n- [사진 참고](https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/)\n\n다음으로 TLS Handshake 과정을 살펴보도록 하겠습니다. 위 사진에서 파란색 부분은 TCP 3-way handshake로 SYN, SYN ACK, ACK 연결하는 과정입니다. 그리고 노란색 부분의 패킷은 TLS handshake입니다. TCP 3-way handshake을 통해서 TCP 연결이 된 이후에 발생합니다. 이어서 노란색 부분인 TLS handshake 과정을 차례대로 보도록 하겠습니다.\n\n#### 1. Client Hello\n\n클라이언트가 서버에 연결을 시도하는 패킷입니다.\n클라이언트의 TLS/SSL 버전 정보, 클라이언트가 지원하는 Cipher Suites(암호화 방식), 클라이언트에서 생성된 Random byte(난수) 등을 전달합니다.\n\n> **Cipher Suites 구조** ([사진 참고 - microsoft](https://learn.microsoft.com/en-us/windows/win32/secauthn/cipher-suites-in-schannel))\n> ![](https://velog.velcdn.com/images/xmun74/post/c496f9b2-04a4-4d2a-b76c-a7d3fcd95d16/image.png)\n>\n> - TLS: 프로토콜명\n> - key exchange: 클라이언트-서버 간 대칭키 교환할 방식\n> - signature: 클라이언트-서버 간 교환한 인증서 검증 알고리즘\n> - bulk encryption: 클라이언트-서버 간 교환되는 대칭키 암호 알고리즘\n> - message authentication: 암호화된 메시지의 무결성을 보장하는 MAC 또는 HMAC 생성\n\n#### 2. Server Hello\n\n앞선 Client Hello에 대해서 서버가 응답하는 패킷입니다.\n서버 자신의 TLS/SSL 버전정보, 서버에서 생성한 난수, 클라이언트가 보낸 Cipher Suites중에서 서버가 사용 가능한 암호화 방식을 1개 선택하여 보냅니다.\n\n#### 3. Certificate\n\n서버 자신의 TLS/SSL 인증서를 클라이언트에 전송합니다.\n인증서에는 서버가 생성한 공개키가 담겨 있습니다.\n클라이언트는 서버의 인증서가 무결한지 검증합니다. 그리고 이전에 주고받은 클라이언트와 서버 각각의 난수로 대칭키를 생성합니다. 그리고 이 대칭키를 인증서 안에 있던 서버의 공개키로 암호화합니다.\n\n#### 4. Server Hello Done\n\n서버의 메시지 전송이 마쳤다는 것을 의미하는 작업입니다.\n\n#### 5. Client Key Exchange\n\n클라이언트는 인증서에서 추출한 서버의 공개키로 대칭키를 암호화하고 해당 대칭키를 전송합니다.\n\n#### 6. Change Cipher Spec / Finished\n\n클라이언트와 서버 서로가 이후 전송되는 메시지를 협상된 암호화 알고리즘과 키를 사용하여 암호화하겠다는 사실을 알리는 패킷입니다. 그리고 Finished 패킷을 보내서 TLS/SSL handshake를 종료하여 마칩니다.\n\n<br /><br /><br /><br />\n\n# 마치며\n\n이전에 평문으로 전송되던 HTTP의 보안 문제를 해결하기 위한 등장한 HTTPS에 대해서 알아보았습니다. HTTPS는 TLS/SSL를 통해서 요청과 응답을 암호화하고 이로써 중간가공격이나 스니핑 해킹에 대해서 보안을 강화할 수 있습니다. 그리고 TLS 핸드셰이크 과정을 통해서 클라이언트와 서버가 안전하게 대칭키를 공유하고 암호화된 데이터를 전송할 수 있게 됐습니다. 만약 중간 네트워크에서 패킷이 가로채지더라도 데이터를 해독하기 어렵게되어 내용을 알 수 없게 됩니다. 따라서 암호화를 통해 보안을 강화한 HTTPS와 동작원리에 대해서 이해할 수 있었습니다.\n\n---\n\n<br /><br /><br /><br />\n\n# 참고\n\n- [HTTPS란 무엇입니까? - cloudflare](https://www.cloudflare.com/ko-kr/learning/ssl/what-is-https/)\n- [TLS 핸드셰이크의 원리는 무엇일까요? | SSL 핸드셰이크 - cloudflare](https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/)\n',
  },
  {
    slug: 'https-encript',
    title: 'HTTPS와 추가적인 암호화',
    content:
      '\n![250316-020900](/images/posts/https-encript/250316-020900.png)\n\n<br/><br/><br/><br/>\n\n# HTTPS payload 평문? 암호화?\n\n> 💁 HTTPS 사용하더라도 비밀번호는 암호화 후 전송해야하는 거 아니야?\n\n<br/>\n예전에 개발자 단톡방에서 위와 같은 주제가 논의된 적이 있었습니다.\n위와 같은 질문이 있을 때 필자는 HTTPS를 사용하고 있다면 이미 TLS를 통해서 비대칭키 암호화를 수행하기 때문에 프론트엔드단에서 암호화가 필요없다고 생각했습니다.\n<br/>\n\n### 실제 서비스들은 어떻게 하고 있나?\n\n이러한 궁금증을 해결하기 위해서 실제 서비스들은 어떻게 하고 있는지 조사해봤습니다. 국내 주요 사이트인 11번가, 네이버 등은 비밀번호를 평문이 아닌 암호화해서 전송하는 방식을 사용하고 있었습니다.\n또한, 이전 블로그 글들을 보면 페이스북이 평문으로 전송한다고 기재된 글들이 많아서 직접 살펴보게 됐습니다. 그래서 2025년 기준으로 찾아본 결과 페이스북도 암호화해서 전송하는 것을 확인했습니다.\n아래 사진에서 `encpass` (encript password)를 통해서 비밀번호를 암호화하고 있는 것을 확인할 수 있죠.\n![](https://velog.velcdn.com/images/xmun74/post/3363388f-3271-47b1-af68-02bd1fe9f257/image.png)\n\n<br/>\n반면, 비밀번호를 평문으로 전송하는 서비스로는 AWS, 쿠팡, 트위터, Github, 링크드인을 찾아볼 수 있었습니다. 하지만 이러한 서비스 중에서 일부는 2FA(2단계 인증), MFA(다단계 인증), 세션 등 추가적인 보안 조치가 되어있는 것을 확인할 수 있습니다.\n<br/>\n\n> - 평문 전송 : AWS, 쿠팡, 트위터, Github, 링크드인 ... (그렇지만 추가적인 보안조치)\n> - 암호화 전송 : 11번가, 네이버, 페이스북 ...\n\n<br/><br/><br/><br/>\n\n# 데이터 전송 방식과 암호화 사례\n\n대부분의 웹 사이트들은 HTTPS를 사용해서 보안을 신뢰하고 있지만, 일부 기업 및 사이트들은 HTTPS에 더해 추가적인 암호화 후 전송하는 보안 방식을 사용하고 있는 것을 확인할 수 있었습니다. 이어지는 내용에서는 기본적인 전송방식, 클라이언트 측 암호화, 그리고 종단간 암호화하는 사례에 대해서 살펴보겠습니다.\n\n<br/><br/>\n\n## 1. 평문 전송 후 서버에서 해싱, 암호화\n\n보통 기본적인 비밀번호 전송 방식으로는 HTTPS에서 평문(plain text)으로 전송한 후 서버에서 이를 해싱 및 암호화하여 DB에 저장하는 방식을 말합니다.\n\n#### 한계점\n\n이 방식의 한계점으로는 재전송 공격(Replay Attack)에 취약하다는 점이 있습니다. 공격자가 HTTPS 요청을 캡쳐해서 재전송할 시 정상적인 로그인 시도로 인식할 수 있기 때문입니다.\n\n---\n\n## 2. 클라이언트 측에서 암호화 후 전송하는 경우\n\n#### 1. 중간자(MITM) 공격 시 재전송 공격(Replay Attack) 방어\n\n> **중간자(MITM: man in the middle attack) 공격이란?**\n> : 사용자와 사용자 사이에서 중간자가 칩임하여 통신을 도청하거나 패킷을 가로채서 조작하는 공격 기법.\n>\n> - 공격 유형 : SSL 스니핑, SSL 스트리핑, 이메일 하이재킹, 와이파이 도청 등\n\n만약 HTTPS 환경에서 해커가 특정 공격 기법을 통해 MITM 공격에 성공했을 때\n사용자와 서버 사이의 데이터를 가로챘어도 만약 암호화된 데이터라면 해당 데이터를 활용할 수 없게 됩니다.\n\n- 단, **Nonce(일회성 난수 토큰) 방식** 등을 통해 구현해야합니다.\n  공격자가 요청을 중간에서 가로채 요청을 재전송하더라도 Nonce 방식으로 해당 토큰은 1번만 사용하므로 공격에 실패하기 때문입니다.\n  이렇게 구현하지 않는다면 공격자가 암호화된 요청을 그대로 재전송할 시 정상적인 요청으로 받아들여져 암호화값 자체를 악용하여 활용할 수 있게 되버립니다.\n\n#### 2. 추가적인 보안 요구사항이 있는 경우\n\n금융, 의료, 공공기관, 정부관련 등에서 데이터 자체가 유출되어서 활용되면 안되는 경우 보안 강화를 위해서 활용될 수 있습니다.\n\n---\n\n## 3. E2EE(End-to-End Encryption)\n\n엔드 투 엔드 암호화(E2EE)는 일명 단 대 단 암호화, 종단간 암호화라고 불립니다.\n발신자 - 수신자는 각 종단의 `엔드`를 뜻합니다. 예를 들면 페이스북에서 메시지를 보내는 사람과 받는 사람만 메시지를 읽을 수 있고, 페이스북은 읽을 수 없습니다.\n데이터는 오로지 주고받는 당사자만 열람 가능한 방식을 말합니다.\n<br/>\n\n> 발신자(열람 가능) - 페이스북 서버(열람 불가능) - 수신자(열람 가능)\n\n<br/>\n\n메시지 발신자와 수신자만 메시지 해독을 해서 조회를 하고 서버에서는 해독이 불가하므로 메시지 원본을 볼 수가 없습니다. 복호화 키를 Server가 아닌 수신자 장치에 저장합니다. 따라서 서버조차 복호화할 수 없기 때문에 해킹에 대한 위험이 줄어듭니다.\n\n#### 특징\n\n- Application Layer에서 구현됨\n- 서버에 복호화 키가 없으므로 데이터 유출 시에도 보호됨\n- 인스턴스 메시지(단톡 채팅방, 비밀 채팅), 민감한 개인정보, Zoom 음성대화 등\n- 프라이버시 강화에 초점\n\n#### 범죄에 악용될 수 있는 한계점\n\n한계점으로는 해킹에 대해서는 안전하지만 메시지 복구가 어렵고 범죄행위에 악용될 수 있다는 점이 있습니다. [22년 BBC 기사](https://www.bbc.com/korean/international-60100742)를 보면 영국정부, 아동자선단체는 아동 성범죄에 악용될 수 있는 측면 때문에 반대를 하고 있는 상황이었기 때문에 E2EE가 연기되었고 그 다음해인 [23년 말에 페이스북](https://about.fb.com/news/2023/12/default-end-to-end-encryption-on-messenger/)에서 E2EE를 도입한 것을 확인할 수 있었습니다. [레딧](https://www.reddit.com/r/facebook/comments/1bwb35b/why_are_facebook_messengers_endtoend_encrypted/?rdt=54894)에서 E2EE로 변경된 방식에 대해서 불평을 가진 사람들도 볼 수 있었습니다.\n\n<br/><br/><br/><br/>\n\n---\n\n### 통신 보안을 위한 방식: mTLS(Mutual TLS)\n\nmTLS는 클라이언트측 인증서 전달해서 신원 증명 단계가 추가된 방식입니다. 기존 TLS에서 서버의 신원 증명하는 방식에서 더 나아가 클라이언트단도 인증하는 방식입니다. 서버와 클라이언트 간 서로의 신원을 확인해야 할 때 사용합니다. 예를 들어 B2B 기업간 통신할 때 사용됩니다.\nE2EE가 사용자 간 프라이버시 보호에 목적을 뒀다면, mTLS는 클라이언트-서버 간 신원 보장에 목적을 둔 점에서 차이가 있습니다.\n\n#### 특징\n\n- Transport Layer에서 동작됨\n- 서버나 DB에서 데이터 조회 가능\n- 양쪽에서 상호 신원을 확인함으로써 통신 보안에 초점 맞춘다.\n\n#### 동작 과정\n\n1. 클라이언트와 서버 연결\n2. 서버가 클라이언트에 TLS 인증서 제시\n3. 클라이언트는 서버 인증서 확인 후, 자신 인증서를 서버에 전달\n4. 서버는 클라이언트 인증서 확인 후 접근 허용\n5. 클라이언트는 공개키로 대칭키 암호화해서 서버에 전송\n6. 서버는 개인키로 복호화해서 대칭키 획득\n7. 서버는 대칭키로 암호화된 데이터 전송\n\n<br/><br/><br/><br/>\n\n---\n\n# 마치며\n\nHTTPS는 기본적인 보안을 제공해주는 수단입니다. 하지만 특정 보안 요구사항이 있다거나, 특정 해킹 공격에 대비해서 추가적인 암호화를 수행하는 예시들을 살펴보았습니다. 다만 예시를 들은 모든 것을 암호화 방식이 필수라는 것이 아니라 서비스 요구사항의 필요에 따라서 적절한 보안 기법을 도입하는 것이 바람직해 보입니다. 그리고 혹시 틀린 정보가 있을 수 있으니 이에 대해서는 댓글로 정보를 남겨주시면 감사하겠습니다.\n\n<br/><br/><br/><br/>\n\n### 참고\n\n- [종단 간 암호화(E2EE)란?](https://www.cloudflare.com/ko-kr/learning/privacy/what-is-end-to-end-encryption/)\n\n- [중간 공격: 유형 및 예시](https://www.fortinet.com/kr/resources/cyberglossary/man-in-the-middle-attack)\n',
  },
  {
    slug: 'module-federation-01',
    title: 'Module Federation이란?',
    content:
      "\n## 들어가며\n\n모듈 페더레이션이라는 키워드가 왜 등장했는지 그 배경을 잠시 알아보겠습니다. 먼저 모듈 페더레이션은 결국 MFE 마이크로 프론트엔드를 구현하기 위한 방식들 중 하나입니다. 그러기에 앞서 MFE가 무엇인지 간단하게 살펴보겠습니다.\n<br />\n\n## MFE(Micro-Frontend) 등장\n\nThoughtWorks Technology Radar(기술 트렌드 조사 사이트)를 살펴보면 대략 2016년도부터 '마이크로 프론트엔드' 아키텍쳐에 대한 개념이 알려지기 시작하면서 이 아키텍쳐를 적용하려는 시도가 늘어났습니다.\n이 개념이 발전하게된 과정을 살펴보면,\n먼저 기존에 사용했던 `모놀리식`(한 패키지 안 여러 개의 서비스) 아키텍쳐의 단점으로 서비스 확장의 어려움, 서비스 별 배포가 어려움, 긴 빌드시간 등에 대한 해결책으로 `마이크로서비스` 아키텍쳐가 등장했는데 이 원칙을 프론트엔드 진영에 적용한 것이 `MFE(Micro-Frontend)`입니다.\n<br />\n\n물론 무조건 마이크로서비스 아키텍쳐가 정답이라는 말은 아닙니다. [마이크로서비스 한계점에 대한 글](https://news.hada.io/topic?id=7839)을 참고하여 서비스 규모나 비용과 생산성 간 트레이드오프 등을 따져보며, 정말 우리 서비스에 맞는지 검토한 후에 도입하는 것이 적절합니다.\n<br />\n\nMFE를 간단히 설명하자면 한 패키지에 묶여있던 거대한 서비스를 마이크로 서비스로 쪼개서 `독립적으로 배포`하고, 쪼개진 서비스를 `통합`할 수 있어야 한다. 예를 들면 밑처럼 모노레포를 사용하여 카드추천, 비대면 계좌개설, 부동산 등의 서비스로 쪼개는 것을 살펴볼 수 있습니다.\n\n- [자료 참고](https://speakerdeck.com/raon0211/toseuyi-maikeuropeuronteuendeu-akitegceo-geurigo-jadonghwa?slide=37)\n  ![](https://velog.velcdn.com/images/xmun74/post/ab6b86fe-51d9-4bc2-8652-d8840b19222a/image.png)\n  <br />\n\n그렇다면 밑의 그림처럼 분리된 여러 개의 서비스들이 독립적인 CI/CD를 진행하고 하나의 웹 페이지로 조립해야하는 통합 과정이 필요합니다.\n\n- [그림 참고](https://martinfowler.com/articles/micro-frontends.html)\n  ![](https://velog.velcdn.com/images/xmun74/post/ecd52c29-6fe2-4d06-87a6-61f18a60ca93/image.png)\n\n<br /><br />\n\n## 통합 방식\n\n[마틴 파울러 사이트의 글](https://martinfowler.com/articles/micro-frontends.html#IntegrationApproaches)에서 소개된 방식들을 간단히 살펴보겠습니다. 방식에 대한 자세한 내용은 해당 글을 참고하시고, 이 외에도 여러 방식이 존재합니다. 나눠진 코드 조각들을 하나로 통합하는 방식들입니다.\n그 중 JavaScript를 통한 런타임 통합 방식으로 Moduel Federation이 있습니다.\n<br />\n\n1. 서버 측 템플릿 구성\n2. 빌드 타임 통합\n3. iframe을 통한 런타임 통합\n4. JavaScript를 통한 런타임 통합\n   - 직접 구현하기\n   - Sigle-SPA 라이브러리\n   - Module Federation\n5. 웹 컴포넌트를 통한 런타임 통합\n\n<br />\n\n위 방식 중에서 JavaScript를 통한 런타임 통합으로 Module Federation에 대한 구현은 밑과 같은 방식들이 있습니다.\n\n<br />\n\n- Webpack5의 [ModuleFederationPlugin](https://webpack.kr/plugins/module-federation-plugin/)\n  : Webpack5부터 내장된 모듈 페더레이션 플러그인입니다.\n- [vite-plugin-federation](https://github.com/originjs/vite-plugin-federation)\n  : 모듈 페더레이션을 지원하는 Vite/Rollup 플러그인으로, Webpack에서 영감을 받았고 Webpack Module Federation과 호환이 됩니다.\n\n<br /><br />\n\n# Module Federation\n\n: `런타임에 통합`되어 각 앱이 서로 `코드를 공유`하는 기능입니다.\n\n`다른 애플리케이션의 코드`를 `런타임`에 가져와서 `동적 로드`할 수 있는 플러그인입니다. 양뱡향으로 모듈 페더레이션이 가능하기 때문에 A 앱에서 B 앱의 코드를 불러올 수 있고 이 반대 상황도 가능합니다.\n2020년 10월에 릴리즈된 Webpack5부터 추가된 내장 기능으로 처음 소개됐습니다. 넷플릭스나 아마존, AWS 등 해외 대기업에서도 사용하고 있다고 합니다.\n<br />\n\n#### Q, 왜 런타임에 하나?\n\n빌드 타임에서 통합한다면, 만약 A 애플리케이션 모듈이 수정될 때 이를 사용하던 다른 B,C 애플리케이션도 다시 빌드/배포해야해서 마이크로 프론트엔드의 장점인 독립적 배포가 어려워집니다.\n런타임에 통합하면, A 애플리케이션 모듈이 업데이트되면 이 코드를 사용하던 B 애플리케이션을 배포 안해도 A 코드의 변경사항이 실시간으로 반영됩니다. 따라서 런타임에 각 서비스가 개별적으로 배포해서 동적으로 로딩할 수 있게 됩니다.\n<br /><br />\n\n### 주요 용어 정리\n\n- 모듈 : Webpack으로 번들링 가능한 리소스 (JS, CSS, HTML, JSON, Asset ..)\n\n1. Host - 하나로 통합된 컨테이너.\n2. Remote - Host로 통합될 모듈.\n   다른 애플리케이션에서 사용하도록 노출(expose)해야 한다.\n3. Local - 현재 애플리케이션 내 단일 빌드에 포함되는 일반적인 모듈\n4. Exposes - 원격 모듈로 노출할 부분 지정.\n   expose하면 Host가 원격 모듈의 코드를 사용할 수 있게 된다.\n5. Container - 다른 애플리케이션에서 로드 가능한 단위\n   ![](https://velog.velcdn.com/images/xmun74/post/95ba106b-f474-4edd-af1b-4bf5a7921b22/image.png)\n\n<br /><br />\n\n## 간단한 코드 예시\n\n### 1. 원격에서 Webpack 설정하기\n\n예를 들어 app1 애플리케이션의 Header.js를 공유하려고 expose하는 경우입니다.\n\n- `name`은 모듈 페더레이션을 수행하는 앱 간 유일한 container 이름이어야 합니다.\n- `filename`은 해당 앱에 대한 정보를 담는 Manifest 파일명을 지정하는 옵션으로 기본값이 remoteEntry.js입니다.\n- `exposes`는 노출할 모듈들을 정의합니다. value 경로에 위치한 로컬 모듈을 key 경로의 원격 모듈로 expose합니다.\n\n```js\n// 원격a-services/webpack.config.js\nconst { ModuleFederationPlugin } = require('webpack').container\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1', // 원격 모듈 이름 - 중복 불가\n      filename: 'remoteEntry.js',\n      exposes: {\n        // 원격 모듈에서 공유할 항목\n        // `./Header` path로 `./src/components/Header.tsx`의 로컬 모듈을 expose함\n        './Header': './src/components/Header.js',\n      },\n    }),\n    // 번들링할 때 remoteEntry.js 파일 생성\n  ],\n}\n```\n\n### 2. 호스트에서 Webpack 설정하기\n\n- `remotes` - 사용할 원격 모듈 목록\n\n```js\nnew ModuleFederationPlugin({\n    name: 'app2', // 호스트 이름\n    remotes: {\n       app1: 'app1@http://localhost:3001/remoteEntry.js',\n    },\n}),\n```\n\n- 호스트에서 원격 모듈 import해서 사용하기\n\n```jsx\nimport 구현체 from '{container 원격 모듈 이름}/{exposes의 key 값}'\n// Static import\nimport Header from 'app1/Header'\n// Dynamic import\nconst Header = React.lazy(() => import('app1/Header'))\n```\n\n### 3. 공유 모듈 설정하기\n\n- 호스트나 원격 모듈 전부 공통적으로 사용하는 공유 모듈이 있다면 이를 설정하여 런타임에 1번만 로딩하게 하는 설정입니다. 이로 인해 요청 횟수가 줄어들게 됩니다.\n- [SharedConfig](https://github.com/webpack/webpack/blob/1f99ad6367f2b8a6ef17cce0e058f7a67fb7db18/declarations/plugins/sharing/SharePlugin.d.ts#L41)를 보면 다양한 옵션들이 있습니다.\n\n```js\nnew ModuleFederationPlugin({\n  shared: {\n    ...deps,\n    react: {\n      sigleton: true,\n      requiredVersion: '^18.0.0',\n    },\n  },\n})\n```\n\n<br /><br />\n\n---\n\n# 마치며\n\nMFE는 복잡도가 높기 때문에 대규모 서비스에서 서비스 특성에 따라서 확실한 장점이 있을 때 도입하는 것이 맞다고 생각했습니다.\n다른 발표 자료들을 찾아볼 때 사용하는 기술, 의사결정 등 사용하는 예시마다 적용하고 선택하는 방식이 다 달라서 완벽한 best practice는 없다고 느껴졌습니다.\n그리고 추가로 [module-federation-examples](https://github.com/module-federation/module-federation-examples) 깃헙에서 SSR, 양방향 호스트 등 다양한 예제들을 소개하고 있으니 참고하면 됩니다.\n\n<br /><br /><br /><br />\n\n참고\n\n- [Micro Frontends - Martin Fowler 사이트](https://martinfowler.com/articles/micro-frontends.html)\n- [Module Federation - Webpack 공식문서](https://webpack.js.org/concepts/module-federation/)\n- https://github.com/module-federation/module-federation-examples\n- [Webpack 5 Module Federation으로 Micro-Frontends 운영하기 - FEConf 유튜브](https://www.youtube.com/watch?v=0Eq6evGKJ68)\n- [[SaaS] Micro Frontends를 위해 Module Federation 적용하기 - 강남언니 블로그](https://blog.gangnamunni.com/post/saas-microfrontends/)\n",
  },
  {
    slug: 'nextjs-infinite-scroll-two',
    title: '무한스크롤 구현에서 뒤로가기 시 스크롤 유지를 해보자',
    content:
      "\n# 뒤로가기 시 이전 스크롤 위치로 복구하기\n\n무한 스크롤로 많은 목록들을 스크롤해서 내렸다가\n1개 글을 클릭한 후\n뒤로가기를 눌렀는데 맨 위로 되돌아가졌다.\n아까 그 위치로 계~속 스크롤해서 내려가자니 여간 불편한 게 아니다...\n이러한 사용자 경험을 향상시키기 위해 이전 스크롤 위치를 기억해서 복구할 필요가 있다!\n\n### 구현할 것\n\n- 경로 변경 전(글 목록 -> 글 상세)에 스크롤위치 저장하기\n- 뒤로가기를 해서 해당 경로에 왔는 지 체크\n- 뒤로가기로 왔으면 저장했던 스크롤위치로 복구\n\n### 구현 코드\n\n```tsx:useScrollRestoration.tsx\nimport { useRouter } from 'next/router'\nimport { useEffect } from 'react'\nimport {\n  getSessionStorage,\n  removeWebStorage,\n  setSessionStorage,\n} from '../webStorage'\n\nexport default function useScrollRestoration() {\n  const router = useRouter()\n\n  useEffect(() => {\n    let scrollStore: null | { x: number; y: number }\n\n    const onRouteChangeStart = () => {\n      setSessionStorage('scroll-position', {\n        x: window.pageXOffset,\n        y: window.pageYOffset,\n      })\n      //   console.log('1. 경로변경 전 저장', window.pageXOffset, window.pageYOffset)\n    }\n\n    const onRouteChangeComplete = () => {\n      if (scrollStore) {\n        const { x, y } = scrollStore\n        // console.log('3. 경로변경 후 (복구)', scrollStore)\n        setTimeout(() => window.scrollTo(x, y), 50)\n        scrollStore = null\n        removeWebStorage('scroll-position', 'session')\n      }\n    }\n\n    router.beforePopState(() => {\n      scrollStore = getSessionStorage('scroll-position')\n      //   console.log('2. 뒤로가기 전 실행', scrollStore)\n      return true\n    })\n    router.events.on('routeChangeStart', onRouteChangeStart)\n    router.events.on('routeChangeComplete', onRouteChangeComplete)\n\n    return () => {\n      router.events.off('routeChangeStart', onRouteChangeStart)\n      router.events.off('routeChangeComplete', onRouteChangeComplete)\n    }\n  }, [])\n}\n```\n\n위 해당 코드를 `_app.tsx`에서 실행시켰다. 먼저 코드를 보면서 설명해보자면,\nnext-router의 [router.events](https://nextjs.org/docs/api-reference/next/router#routerevents)를 활용하여 경로가 이동될 때 함수를 실행하게 했다.\n참고로 라우터 이벤트는 useEffect에서 구독하여 실행해야한다.\n\n- `routeChangeStart(url, { shallow })` - 경로가 변경되기 시작할때 발생\n\n- `routeChangeComplete(url, { shallow })` - 경로가 완전히 변경되면 발생\n\n- [router.beforePopState](https://nextjs.org/docs/api-reference/next/router) - 경로 작동 전 실행함. return값이 true면 popstate를 호출함\n\n  - [popstate](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event) : 뒤로가기/앞으로가기 버튼 클릭 시 호출됨\n\n#### 구현 과정\n\n> 경로 이동 예시 : 글 목록 (스크롤 후)=> 글 상세\n\n1. 경로 이동 시작될 때(routeChangeStart) 스크롤위치를 sessionStorage에 저장\n2. 뒤로가기 클릭해서 경로 작동되기 전에(beforePopState) sessionStorage에 저장된 값을 변수(scrollStore)에 할당함\n3. 경로 완전히 변경된 후(routeChangeComplete) 변수에 저장된 값이 있으면 스크롤 위치 복구 후 다시 초기화해줌\n\n# 문제\n\n# 참고\n\nhttps://coffeeandcakeandnewjeong.tistory.com/94\nhttps://helloinyong.tistory.com/300\n",
  },
  {
    slug: 'nextjs-infinite-scroll',
    title: 'Intersection Observer API로 무한스크롤 구현하기',
    content:
      "\n## 적용하는 이유\n\n이전에는 블로그에서 글 목록 페이지에 접속했을 때 모든 글을 출력해주고 있었습니다.\n예를 들어 100개 글이 있다면 1번 요청에 100개를 받아오는 방식이었습니다.\n그래서 긴 목록을 렌더링할 때 사용하는 페이지네이션이나 무한스크롤을 적용하여 필요한 데이터만 나눠 받을 수 있게 하는 방법으로 구현하고자 했습니다.\n<br/>\n먼저 페이지네이션은 페이지 이동을 위해 따로 클릭을 해야하지만\n무한스크롤은 그냥 스크롤만 하면 추가 데이터를 볼 수 있습니다.\n따라서 사용자 경험을 높이기 위해서 스크롤만해서 새 데이터를 볼 수 있는 무한스크롤을 선택했습니다. 이 글에서는 무한스크롤 방식을 Intersection Opserver API를 사용하여 구현하고자 합니다.\n\n### 무한 스크롤 한계점\n\n- 뒤로가기 시 이전 스크롤 위치 기억하는 추가 작업 필요\n- 푸터 찾기 어려워짐\n\n## 무한스크롤 구현 방법\n\n1. scroll event\n\n   - throttle이나 requestAnimationFrame으로 구현\n     : 스크롤 이벤트 성능 개선을 위해서 위에 해당된 추가 작업이 필요하다\n\n2. Intersection Opserver API\n\n#### 구현 사항\n\n- 최하단까지 스크롤하면 N개 데이터 fetch하기\n- 받아올 다음 데이터 없거나 로딩중일 때 fetch 중지\n\n#### 추가 구현 사항\n\n- 목록에서 스크롤 내리고 1개 상세페이지로 들어갔다가\n  뒤로가기 누르면 이전 스크롤 위치 기억하기\n- 로딩중일 때, 스켈레톤 UI 로드\n\n---\n\n# Intersection Opserver API\n\n[Intersection Opserver API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) 는 상위요소나 viewport에서 해당 요소가 교차될 때 변경사항을 비동기식으로 관찰할 수 있게 하는 API다. 예를 들어 컴퓨터 화면에서 특정 요소가 보여질 때를 관찰하여 콜백함수를 실행하게 하는 것이다.\n\n## 1. Intersection Opserver 개념\n\n#### Intersection Observer 인스턴스 생성하기\n\n```js\nlet options = {\n  root: document.querySelector('#scrollArea'),\n  rootMargin: '0px',\n  threshold: 1.0,\n}\n\n// Intersection Opserver 생성\n// 요소가 관찰되면 1번째 인자인 콜백함수 실행, 2번쨰 인자로 옵션 지정\nlet observer = new IntersectionObserver(callback, options)\n```\n\n#### options\n\n- `root` - 대상이 root에 들어오면 콜백함수를 실행함. (기본값인 `null`은 viewport가 지정됨)\n- `rootMargin` - root의 margin값 [상,오,하,왼] 지정 가능. (기본값 0)\n- `threshold` - 대상의 가시성 비율을 나타내는 숫자나 배열로, 대상이 얼마나 보이느냐에 따라 콜백함수 실행함. 0.5 - 대상이 root에서 50% 보이면 감지 / 1.0- 대상 전체가 보이면 감지 (기본값 0)\n\n#### callback 함수\n\n타겟 요소의 관찰이 시작될 때 실행되는 콜백함수\n\n```js\nlet callback = (entries, observer) => {\n  entries.forEach((entry) => {\n    // entry.isIntersecting :target의 교차여부를 boolean값으로 출력\n    // entry.target\n  })\n}\n```\n\n- `entries` - target의 배열. 현재상태에 대한 속성들이 존재함.\n- `observer` - 콜백함수 호출한 observer\n\n#### 메서드\n\n```js\n// 타겟 관찰 시작\nobserver.observe(target)\n// 타겟 관찰 중단\nobserver.unobserve(target)\n// 모든 관찰 중단\nobserver.disconnect()\n```\n\n#### 관찰할 요소 타겟팅하기\n\n```tsx\n/* JS 버전 */\nlet target = document.querySelector(\"#listItem\");\nobserver.observe(target);\n\n/* React + TS 버전 */\nlet target = useRef<HTMLDivElement>(null);\nobserver.observe(target.current as Element);\n// ...\nreturn (\n{/* ... */}\n<div ref={target}></div>\n)\n```\n\n---\n\n## 2. 커스텀 훅 만들기\n\n커스텀 훅으로 만들어두면 무한 스크롤, 스켈레톤 UI, 지연 로딩 등에서도 재사용할 수 있으므로 Hook으로 분리하여 구현해봅시다.\n\n```tsx:useIntersect.tsx\n/* NextJS + TS 버전 */\nimport { useCallback, useEffect, useRef } from 'react'\n\ninterface IntersectionObserverInit {\n  root?: Element | Document | null\n  rootMargin?: string\n  threshold?: number | number[]\n}\n\ntype IntersectHandler = (\n  entry: IntersectionObserverEntry,\n  observer: IntersectionObserver,\n) => void\n\nconst defaultOptions = {\n  root: null,\n  rootMargin: '0px',\n  threshold: 1.0,\n}\n\nexport default function useIntersect(\n  onIntersect: IntersectHandler,\n  options?: IntersectionObserverInit,\n) {\n  const target = useRef<HTMLDivElement>(null)\n\n  const callback = useCallback(\n    (entries: IntersectionObserverEntry[], observer: IntersectionObserver) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          onIntersect(entry, observer)\n        }\n      })\n    },\n    [onIntersect],\n  )\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(callback, {\n      ...defaultOptions,\n      ...options,\n    })\n    if (target.current) {\n      observer.observe(target.current as Element)\n    }\n    return () => observer && observer.disconnect()\n  }, [target, callback, options])\n\n  return target\n}\n```\n\n#### React에서는 useEffect 안에서 인스턴스 생성\n\nuseEffect에서 렌더링이 되고 나서 해당 target이 있을 때 `observe()`로 관찰을 시작하고\n`return()`문에서 언마운트될 때 `disconnect()`하여 관찰을 중단한다.\n\n<br />\n\n### Hook 사용처\n\n```tsx\nexport default function Blog() {\n  const [blogs, setBlogs] = useState([])\n  const [page, setPage] = useState(0)\n  const [nextPage, setNextPage] = useState(true)\n  const [isLoading, setIsLoading] = useState(false)\n\n  const fetchData = async () => {\n    setIsLoading(true)\n    const { contents, pageNumber, isLastPage } = await blogsApi.getBlogs(\n      page,\n      8,\n    )\n    setBlogs(blogs.concat(contents))\n    setPage(pageNumber + 1)\n    setNextPage(!isLastPage)\n    setIsLoading(false)\n  }\n\n  const target = useIntersect(async (entry, observer) => {\n    observer.unobserve(entry.target)\n    if (nextPage && !isLoading) {\n      fetchData() // 다음페이지 있고 로딩중 아닐때 fetch 하기\n    }\n  })\n  return (\n    <>\n      {/* fetch로 받은 limit있는 N개 목록 ... */}\n      <div ref={target}>{isLoading && <div>Loading...</div>}</div>\n    </>\n  )\n}\n```\n\n#### 최하단까지 스크롤하면 N개 데이터 fetch하기\n\nfetch로 받아온 제한된 개수를 가진 목록이 있고, 그 목록 바로 밑에 target을 두어서 target에 도달했을 때 새 데이터를 fetch 받도록 했습니다.\n\n#### 다음 데이터가 있고, 로딩중이 아닐 때만 fetch하기\n\n최하단까지 스크롤했을 때 데이터 fetch를 계속 반복하면 안되기 때문에\n조건문에 해당될 때만 fetch하도록 구성해야 합니다.\n예를 들어 다음 데이터가 있고, 로딩중이 아닐때만 fetch를 하도록 합니다.\n\n# 마치며\n\n목록을 출력하는 방법으로 무한 스크롤이 있지만 이 방법에도 한계점이 있습니다. 밑처럼 추가 구현해야 될 사항들이 있습니다.\n\n- 뒤로가기 시 이전 스크롤 위치 기억하기\n- 불러온 데이터만큼 DOM 노드 증가하기 때문에 렌더링 최적화 작업 필요\n- 로딩중일 때 스켈레톤 UI 출력하기\n\n이 중에서 뒤로가기 구현은 스크롤 위치를 기억해야한다는 점이 있습니다.\n먼저 무한스크롤로 데이터를 N개까지 로드한 이후에 상세 페이지로 이동했다가 뒤로가기로 돌아오면 데이터가 초기화되어 있습니다.\n간단하게 구현하려면 상세페이지를 모달로 구현하거나 이전 데이터를 전부 저장해놓는 방법이 있습니다.\n하지만 이전 데이터가 100페이지가 넘는다거나 대량의 데이터라면 저장하기가 부담스럽습니다.\n또는 세션스토리지에 스크롤높이를 저장해두고, 뒤로가기시 padding-bottom으로 저장해둔 값을 설정하는 방법이 있습니다. 하지만 이도 1페이지부터~N페이지까지 전부 요청을 다시 해야되기 때문에 서버에 부담이 가고 로딩시간이 길어진다는 점이 있습니다.\n<br/>\n그리고 이와 연관되서 DOM 노드 수가 증가한다는 문제가 발생됩니다. 이전 데이터를 다 불어오면 DOM 노드 수가 증가하기 때문에 그만큼 렌더링 시간도 증가한다는 문제가 있습니다. 따라서 가상화목록(or windowing)이라는 렌더링 최적화방식을 적용해야 할 필요성이 있습니다.\n이와 관련된 내용은 다음 포스트부터 설명하도록 하겠습니다.\n<br/>\n무한스크롤 방식이 사용자 경험 향상에 도움이 되지만, 한계점이 있고 이에 따라 추가적인 작업을 구현해야 한다는 점이 있습니다. 모든 사이트가 무한스크롤을 사용하지 않는 것은 이러한 문제들이 있었기 때문이라고 생각했습니다. 따라서 각 방식의 트레이드오프를 비교해서 해당 서비스에 맞는 효과적인 방식을 선택하는 것이 바람직하다고 생각합니다.\n\n<br /><br /><br />\n\n---\n\n> 참고\n\n[실전 Infinite Scroll with React - kakaoenterprise](https://tech.kakaoenterprise.com/149)\n[(React) 무한 스크롤 기능 구현하기 : used by Intersection Observer - 2](https://velog.io/@yunsungyang-omc/React-%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-used-by-Intersection-Observer-2)\n[무한 스크롤(Infinite scroll) 구현하기](https://velog.io/@eunoia/%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4Infinite-scroll-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)\n[[React] 무한 스크롤 적용하기](https://velog.io/@sjoleee_/React-%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4#%EB%AC%B4%ED%95%9C%EC%8A%A4%ED%81%AC%EB%A1%A4%EC%9D%84-%EB%8F%84%EC%9E%85%ED%95%98%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0)\n",
  },
  {
    slug: 'nextjs-setting-ts',
    title:
      'NextJs + TS 셋팅 - eslint, prettier, styled-components (husky, lint-staged, airbnb)',
    content:
      '\n[Next.js 공식문서](https://nextjs.org/docs/basic-features/typescript)\n\n#### 개발환경\n\n- next.js - 13.1.1\n- typescript - 4.9.4\n- eslint (+ airbnb규칙) - 8.31.0\n- prettier - 2.8.2\n- husky - 8.0.0\n- lint-staged - 13.1.0\n- styled-components - 5.3.6\n\n# Next.js + TS 설치\n\n### 1. Next.js + TS 새 프로젝트로 생성하는 방법 1\n\n```bash\nnpx create-next-app@latest --ts 프로젝트명\n#or\nyarn create next-app --typescript 프로젝트명\n#or\npnpm create next-app --ts 프로젝트명\n\n#eslint 설치하겠냐는 질문에 yes 선택\n```\n\n```diff-json:package.json showLineNumbers\n{\n  "name": "xmunt",\n  "version": "0.1.0",\n  "private": true,\n  "scripts": {\n    "dev": "next dev",\n    "build": "next build",\n    "start": "next start",\n    "lint": "next lint"\n  },\n  "dependencies": {\n    "@next/font": "13.1.1",\n    "@types/node": "18.11.18", //ts 관련 패키지\n    "@types/react": "18.0.26", //ts 관련 패키지\n    "@types/react-dom": "18.0.10",\n    "eslint": "8.31.0",\n    "eslint-config-next": "13.1.1",\n    "next": "13.1.1",\n    "react": "18.2.0",\n    "react-dom": "18.2.0",\n    "typescript": "4.9.4"\n  }\n}\n\n```\n\n<br/><br/>\n\n### 2. 기존 프로젝트(Next.js )에서 Next.ts로 생성하는 방법 2\n\n```bash\ntouch tsconfig.json\nnpm install --save-dev @types/react @types/node\nnpm run dev  # 잘 실행되면 됨 tsconfig.json에 자동 설정됨\n```\n\n<br/><br/><br/><br/>\n\n# 1. ESLint 설정\n\nNext.js 버전 `11.0.0` 부터 ESLint가 함께 통합됐기 때문에\nNext 설치 때 eslint 설치에 yes했다면,\nESLint를 추가 설치하거나 `.eslintrc.json`을 따로 생성하지 않아도 됨.\n(만약 next 설치할때 eslint 설치하겠냐는 질문에 no 했다면 해야겠지만,)\n\n- airbnb, google, next 등 다양한 규칙들이 있다. 그 중에 대표적인 airbnb 규칙을 사용해서 설치하고자 한다.\n\n<br/>\n\n## Airbnb 규칙 설정\n\n### 1. `eslint-config-airbnb` - 리액트 관련 규칙\n\n- 리액트 관련된 경우 사용\n\n> - eslint-config-airbnb의 의존성 패키지 목록 확인 명령어\n\n```bash\nnpm info "eslint-config-airbnb@latest" peerDependencies\n```\n\n- 위 명령어를 통해 조회된 종속 패키지목록이다.\n  버전에 맞는 패키지들을 같이 설치해줘야 한다\n  ```bash\n  {\n    eslint: \'^7.32.0 || ^8.2.0\',\n    \'eslint-plugin-import\': \'^2.25.3\',\n    \'eslint-plugin-jsx-a11y\': \'^6.5.1\',\n    \'eslint-plugin-react\': \'^7.28.0\',\n    \'eslint-plugin-react-hooks\': \'^4.3.0\'\n  }\n  ```\n\n#### 설치하기\n\n```bash\n#1. airbnb + 종속 패키지까지 설치하기\nnpx install-peerdeps --dev eslint-config-airbnb\n#또는 각각 개별적 설치\nnpm install -D eslint eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-ally\n\n#2. TypeScript 관련 airbnb, lint 패키지 설치하기\nnpm install -D eslint-config-airbnb-typescript @typescript-eslint/eslint-plugin @typescript-eslint/parser\n```\n\n<br/><br/><br/>\n\n### 2. `eslint-config-airbnb-base` - 리액트 제외 규칙\n\n- 리액트를 안 쓰는 경우 설치\n- 종속성 패키지 확인 명령어\n  ```bash\n  npm info "eslint-config-airbnb-base@latest" peerDependencies\n  ```\n\n#### 설치하기\n\n```bash\nnpx install-peerdeps --dev eslint-config-airbnb-base\n```\n\n- `.eslintrc.json`에 설정 추가\n\n```js:.eslintrc.json\n"env": {\n    "br/owser": true,\n    "node": true,\n  },\n  "extends": "airbnb-base",\n  "rules": {\n    "linebr/eak-style": 0,\n  },\n```\n\n<br/><br/><br/>\n\n# 2. Prettier 설치\n\n#### 1. Prettier 및 플러그인 설치하기\n\neslint와 prettier를 함께 사용할 시 규칙들이 충돌됨으로 의존성 패키지들을 설치해야 한다.\n\n```bash\nnpm install -D prettier eslint-plugin-prettier eslint-config-prettier\n```\n\n- `eslint-plugin-prettier` : eslint에서 prettier랑 충돌할 규칙 비활성화\n- `eslint-config-prettier` : 포매팅할때 prettier 사용하게 하기\n\n#### 2. `.prettierrc` 파일 생성\n\n```js:.prettierrc\n{\n  "semi": false,\n  "singleQuote": true,\n  "tabWidth": 2,\n  "trailingComma": "all"\n}\n```\n\n- `"semi": false` - 세미콜론 사용여부. (Next.js는 세미콜론 `;` 사용안해서 false함)\n- `"singleQuote": true` - 작은 따옴표 `\'` 사용\n- `"tabWidth": 2,` - 탭 너비 설정\n- `"trailingComma": "all"` - 여러 줄일때 마지막에 후행 콤마 사용\n\n<br/><br/><br/>\n\n### `.eslintrc.json` 설정\n\n- 주석설명있는 버전\n\n```js:.eslintrc.json\n{\n  "root": true,\n  "parser": "@typescript-eslint/parser",\n  "plugins": ["@typescript-eslint", "prettier"],\n  "parserOptions": {\n    "project": "./tsconfig.json",\n    "createDefaultProgram": true\n  },\n  "env": { // 전역객체를 eslint가 인식하는 구간\n    "br/owser": true, // document나 window 인식되게 함\n    "node": true,\n    "es6": true\n  },\n  "ignorePatterns": ["node_modules/"], // eslint 미적용될 폴더나 파일 명시\n  "extends": [\n    "airbnb",\n    "airbnb-typescript",\n    "airbnb/hooks",\n    "next/core-web-vitals",\n    "plugin:@typescript-eslint/recommended", // ts 권장\n    "plugin:prettier/recommended" // eslint의 포매팅을 prettier로 사용.\n    "prettier" // eslint-config-prettier prettier와 중복된 eslint 규칙 제거\n  ],\n  "rules": {\n    "react/react-in-jsx-scope": "off", // react 17부턴 import 안해도돼서 기능 끔\n    // 경고표시, 파일 확장자를 .ts나 .tsx 모두 허용함\n    "react/jsx-filename-extension": ["warn", { "extensions": [".ts", ".tsx"] }],\n    "no-useless-catch": "off" // 불필요한 catch 못쓰게 하는 기능 끔\n  }\n}\n```\n\n- rules\n  배열의 첫번째 값을 0,1,2나 "off", "warn", "error"로 규칙 표시\n\n## Error\n\n#### 1. `npm run lint` 실행 시 뜨는 에러내용\n\n```bash\nError: "prettier/@typescript-eslint" has been merged\ninto "prettier" in eslint-config-prettier 8.0.0.\nSee: https://github.com/prettier/eslint-config-prettier/blob/main/CHANGELOG.md#version-800-2021-02-21\n```\n\n#### 2. 원인\n\nextends에 `"prettier/@typescript-eslint"` 속성 때문\n블로그글들 참고하면서 했는데 이 설정 있으면 `npm run lint`가 실행안됨\n\n#### 3. 해결방법\n\neslint-config-prettier 버전 8부터\n`"prettier/@typescript-eslint"` 속성이 `"prettier"`로 병합됨\n\n- `prettier/@typescript-eslint`를 extends 설정에서 제거 후 `"prettier"` 추가\n  [버전 8부터 병합된 내용 공유한 깃허브 ](https://github.com/prettier/eslint-config-prettier/blob/main/CHANGELOG.md#version-800-2021-02-21)\n  [perttier/@typescript-eslint 가 제거됐다는 글](https://stackoverflow.com/questions/65675771/eslint-couldnt-find-the-config-prettier-typescript-eslint-after-relocating)\n\n## `.eslintrc.json`\n\n- 주석 없는 버전\n  ```js:.eslintrc.json\n  {\n    "root": true,\n    "parser": "@typescript-eslint/parser",\n    "plugins": ["@typescript-eslint", "prettier"],\n    "parserOptions": {\n      "project": "./tsconfig.json",\n      "createDefaultProgram": true\n    },\n    "env": {\n      "br/owser": true,\n      "node": true,\n      "es6": true\n    },\n    "ignorePatterns": ["node_modules/"],\n    "extends": [\n      "airbnb",\n      "airbnb-typescript",\n      "airbnb/hooks",\n      "next/core-web-vitals",\n      "plugin:@typescript-eslint/recommended",\n      "plugin:prettier/recommended",\n      "prettier"\n    ],\n    "rules": {\n      "react/react-in-jsx-scope": "off",\n      "react/jsx-props-no-spreading": 0,\n      "@typescript-eslint/semi": "off",\n      "react/jsx-filename-extension": ["warn", { "extensions": [".ts", ".tsx"] }],\n      "no-useless-catch": "off"\n    }\n  }\n  ```\n\n<br/><br/><br/><br/>\n\n# 실행하기\n\n> #### 실행 순서\n>\n> prettier(코드스타일 자동정리) -> eslint(규칙검사) -> 코드 수정\n\n## 1. prettier 실행\n\n- `npx prettier --write pages`\n  ![](https://velog.velcdn.com/images/xmun74/post/aa53cd56-3b27-4604-8014-271e34af2a92/image.png)\n\n## 2. eslint 실행\n\n- `npm run lint`\n- 만약 밑처럼 에러가 난다면 구글링해서 `.eslintrc` rules에서 해당 속성을 끄거나 설정해주면 된다.\n  ![](https://velog.velcdn.com/images/xmun74/post/f61cd481-12c1-4539-ac08-28dfbff020fe/image.png)\n- (난 위에 `.eslintrc.json`에서 해당 속성들을 설정해뒀다)\n  ![](https://velog.velcdn.com/images/xmun74/post/e4dedd9f-8ba4-403d-8aa7-bf4c646779c2/image.png)\n\n<br/><br/>\n\n---\n\n<br/><br/>\n\n# 3. husky와 lint-staged로 편리하게 사용하기\n\n> git commit할 때 변경된 파일만 eslint, prettier 자동 실행하기\n\n### 1. husky\n\n- git hook(커밋,푸시 등) 제어하는 npm 라이브러리\n- git commit 시 eslint, prettier 실행 자동화하기\n\n### 2. lint-staged\n\n- staged된 파일만 특정 명령어 실행하는 도구\n- commit 시 전체가 아니라 변경된 파일만 eslint, prettier 실행하기\n\n#### 설치하기\n\n#### 1. [husky 권장설치 공식문서](https://typicode.github.io/husky/#/?id=automatic-recommended)\n\n```bash\nnpx husky-init && npm install       # npm\nnpx husky-init && yarn              # Yarn 1\nyarn dlx husky-init --yarn2 && yarn # Yarn 2+\npnpm dlx husky-init && pnpm install # pnpm\n```\n\n- 설치하면 package.json 수정됨, husky 설치됨, .husky/pre-commit 생성\n- 설치 후 package.json에 추가된 부분\n\n  ```js:package.json\n    "scripts": {\n      //\n      "prepare": "husky install"\n    },\n  ```\n\n#### 2. lint-staged 설치\n\n```bash\nnpm i -D lint-staged\n```\n\n#### 3. package.json에 명령어 추가하기\n\n변경된 js,jsx,ts,tsx 파일만 밑 명령어 실행하게 함\n\n```js:package.json\n"lint-staged": {\n    "*.{js,jsx,ts,tsx}": [\n      "prettier --write",\n      "eslint --fix"\n    ]\n  }\n```\n\n#### 4. `.husky/pre-commit` 에 명령어 추가 [(참고)](https://github.com/okonet/lint-staged#examples)\n\n```bash\n#!/usr/bin/env sh\n. "$(dirname -- "$0")/_/husky.sh"\n\nnpx lint-staged # 추가\n\n```\n\n<br/><br/><br/><br/>\n\n# 4. styled-components 설정\n\n#### 설치하기\n\n```bash\nnpm i styled-components\nnpm i -D @types/styled-components  # ts 위한 설치\n```\n\n### 1. SSR 설정하기\n\n- 첫 화면 렌더링 때도 css 적용하게 해주기\n- Next.js에서 styled-components에 대한 SSR 추가 설정이 필요하다\n\n> #### 🔺 옛날 방법 (Next.js 12버전 이하)\n\n1. babel 플러그인 설치\n\n```bash\nnpm i -D babel-plugin-styled-components\n```\n\n2. [`.babelrc` 파일 생성 후 추가](https://styled-components.com/docs/tooling#usage)\n\n```js\n{\n  "presets": ["next/babel"],\n  "plugins": [\n    [\n      "babel-plugin-styled-components",\n      {\n        "ssr": true,\n        "fileName": true,\n        "displayName": true,\n      }\n    ]\n  ]\n}\n```\n\n#### ✅ 최신방법 (Next.js 12 버전 이상)\n\nnext 버전 12부터 컴파일러에서 바벨 플러그인`babel-plugin-styled-components`을 포트하고 있음\nhttps://nextjs.org/docs/advanced-features/compiler#styled-components\n\n1. `next.config.js` 에 추가 설정하기\n\n```js:next.config.js\n/** @type {import(\'next\').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  compiler: {\n    // 추가\n    styledComponents: true, // 추가\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n<br/>\n\n2. `pages/_document.tsx` 수정\n\n- 참고 - [next 공식문서](https://nextjs.org/docs/advanced-features/custom-document#customizing-renderpage), [dev글](https://dev.to/sumukhakb210/using-styled-components-with-nextjs-12-and-typescript-in-2021-3439), [참고블로그](https://been.tistory.com/m/56)\n\n```tsx:pages/_document.tsx\nimport Document, {\n  Html,\n  Head,\n  Main,\n  NextScript,\n  DocumentContext,\n  DocumentInitialProps,\n} from \'next/document\'\nimport { ServerStyleSheet } from \'styled-components\'\n\nclass MyDocument extends Document {\n  static async getInitialProps(\n    ctx: DocumentContext,\n  ): Promise<DocumentInitialProps> {\n    const sheet = new ServerStyleSheet()\n    const originalRenderPage = ctx.renderPage\n\n    try {\n      ctx.renderPage = () =>\n        originalRenderPage({\n          enhanceApp: (App) => (props) =>\n            sheet.collectStyles(<App {...props} />),\n        })\n      const initialProps = await Document.getInitialProps(ctx)\n\n      return {\n        ...initialProps,\n        styles: (\n          <>\n            {initialProps.styles}\n            {sheet.getStyleElement()}\n          </>\n        ),\n      }\n    } finally {\n      sheet.seal()\n    }\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head />\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    )\n  }\n}\n\nexport default MyDocument\n```\n\n<br/><br/>\n\n- ssr 적용 전 소스코드에 css 없음\n  ![](https://velog.velcdn.com/images/xmun74/post/24654ab4-de3a-4ae6-a2d0-b00f6a27bcc7/image.png)\n- ssr 적용 후 소스코드에 css가 포함됨\n  ![](https://velog.velcdn.com/images/xmun74/post/614e5b02-77d1-4173-b3a2-87e4786a347a/image.png)\n\n<br/><br/>\n\n### 2. GlobalStyle, Theme 적용하기\n\n- `npm i styled-reset` - 기본으로 적용되는 css 리셋하는 패키지 설치\n\n```bash\nnpm i styled-reset\n```\n\n#### 1. GlobalStyle 전역스타일 설정\n\n- `styles/GlobalStyle.ts` 생성 예시\n\n```ts:styles/GlobalStyle.ts\nimport { createGlobalStyle } from \'styled-components\'\nimport reset from \'styled-reset\'\n\nconst GlobalStyle = createGlobalStyle`\n  ${reset}\n  * {\n    box-sizing: border-box;\n    padding: 0;\n    margin: 0;\n  }\n  body {\n    height: 100%;\n  }\n  button {\n    cursor: pointer;\n    background-color: inherit;\n  }\n  a {\n    text-decoration:none;\n    color:inherit;\n  }\n`\nexport default GlobalStyle\n```\n\n#### 2. Theme 적용하기\n\n> - **Theme 적용 방법** (여기선 일단 ThemeProvider 사용함)\n\n1. ThemeProvider 사용하기\n2. CSS Variable 사용하기\n\n- `styles/theme.ts` 생성 예시\n\n```ts\nimport { DefaultTheme } from \'styled-components\'\n\nexport const lightTheme: DefaultTheme = {\n  accent1: \'#f5fbfc\',\n  accent2: \'#f8c291\',\n  accent3: \'#d35400\',\n  text: \'#000000\',\n  bg1: \'#ffffff\',\n}\n\nexport const darkTheme: DefaultTheme = {\n  accent1: \'#121212\',\n  accent2: \'#bdc3c7\',\n  accent3: \'#2c3e50\',\n  text: \'#ffffff\',\n  bg1: \'#121212\',\n}\n```\n\n#### 3. `pages/_app.tsx` 추가\n\n```tsx\nimport type { AppProps } from \'next/app\'\nimport { useState } from \'react\'\nimport { RecoilRoot } from \'recoil\'\nimport { ThemeProvider } from \'styled-components\'\nimport GlobalStyle from \'../styles/GlobalStyle\'\nimport Layout from \'../components/Layout\'\nimport { darkTheme, lightTheme } from \'../styles/theme\'\n\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    <RecoilRoot>\n      <ThemeProvider theme={darkTheme}>\n        <GlobalStyle />\n        <Component {...pageProps} />\n      </ThemeProvider>\n    </RecoilRoot>\n  )\n}\n```\n\n#### 4. `styles/styled.d.ts` 생성\n\n테마 변수들의 타입을 선언하는 파일\n\n```ts:styles/styled.d.ts\nimport \'styled-components\'\n\ndeclare module \'styled-components\' {\n  export interface DefaultTheme {\n    accent1: string\n    accent2: string\n    accent3: string\n    text: string\n    bg1: string\n  }\n}\n```\n\n<br/><br/>\n\n---\n\n<br/><br/><br/><br/><br/>\n\n# 참고\n\n[밑바닥부터 Next.js 개발 환경 구축하기 - All in One](https://leo-xee.github.io/Next/next-setup-allinone/)\nhttps://kbwplace.tistory.com/151\neslint 옵션 설명 참고 - https://abangpa1ace.tistory.com/194\n[husky, lint-staged로 git commit 전에 eslint, prettier 체크하기](https://kyounghwan01.github.io/blog/etc/husky/#husky-lint-staged-%E1%84%89%E1%85%A5%E1%86%AF%E1%84%8E%E1%85%B5)\n\n다크모드 참고\n\n- [벨로퍼트 - 벨로그에 다크 모드 적용하기](https://velog.io/@velopert/velog-dark-mode#%EB%8B%A4%ED%81%AC-%ED%85%8C%EB%A7%88-%EB%8F%84%EC%9E%85%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%88%A0%EC%A0%81%EC%9D%B8-%EC%A4%80%EB%B9%84)\n- [styled-components typscript로 세팅하기](https://kyounghwan01.github.io/blog/React/styled-components/styled-components-preset/#package-json-%E1%84%89%E1%85%A5%E1%86%AF%E1%84%8E%E1%85%B5)\n',
  },
  {
    slug: 'open-graph',
    title: 'NextJS로 만든 블로그 이쁘게 공유하기 - Open Graph',
    content:
      '\n#### 정보가 없는 미리보기\n\n![230314-185422](/images/posts/open-graph/230314-185422.png)\n만약 위처럼 블로그를 공유했는데\n아무런 정보가 없고 뭐하는 사이트인지도 모르겠다면?\n링크 누르기가 싫어진다...\n\n<br></br>\n\n#### 정보가 풍부한 미리보기\n\n![230314-185428](/images/posts/open-graph/230314-185428.png)\n이번엔 위처럼 SNS에 블로그 링크를 공유할때\n좀 더 이쁘면서 정보도 풍부하게 미리볼 수 있다면?\n보는 사람들도 궁금해서 링크를 클릭할 것이다!\n\n<br></br><br></br>\n\n# Open Graph\n\n링크를 공유했을 때 정보를 표시해주는 open graph를 적용해보자!\nOpen Graph는 통일된 메타데이터를 작성하도록 정의한 규약이다. Facebook, Twitter는 자체 프로토콜을 가지고 있다.\n자세한 메타데이터 및 속성은 [Open Graph Protocol](https://ogp.me/)를 참고하면 된다.\n\n<br></br>\n\n## og 메타데이터 작성하기\n\n`next-seo` 라이브러리를 사용해도 되지만 복잡한 사이트구조가 아니라고 판단하여 직접 `meta`태그를 작성했다.\n\n- 기본 메타데이터 예시\n  밑의 4가지 속성은 필수로 작성해야하는 속성이다.\n\n```html\n<head>\n  <meta property="og:title" content="The Rock" />\n  <meta property="og:type" content="video.movie" />\n  <meta property="og:url" content="https://www.imdb.com/title/tt0117500/" />\n  <meta\n    property="og:image"\n    content="https://ia.media-imdb.com/images/rock.jpg"\n  />\n  ...\n</head>\n```\n\n- 블로그에 적용한 코드\n\n```tsx\n<Head>\n  {/* HTML Meta Tags */}\n  <title>{`${post?.title} | ${pageConfig.title}`}</title>\n  <meta name="description" content={`${pageConfig.title}`} />\n  <meta name="viewport" content="width=device-width, initial-scale=1" />\n\n  {/* Facebook Meta Tags */}\n  <meta\n    property="og:url"\n    content={`https://xmunt.vercel.app/blog/${post?.slug}`}\n  />\n  <meta property="og:type" content="website" />\n  <meta\n    property="og:site_name"\n    content={`${post?.title} | ${pageConfig.title}`}\n  />\n  <meta property="og:title" content={`${post?.title} | ${pageConfig.title}`} />\n  <meta property="og:description" content={post?.description} />\n  <meta property="og:image" content={`${DOMAIN}${post?.coverImage}`} />\n\n  {/* Twitter Meta Tags */}\n  <meta name="twitter:card" content="summary_large_image" />\n  <meta property="twitter:domain" content="xmunt.vercel.app" />\n  <meta\n    property="twitter:url"\n    content={`https://xmunt.vercel.app/blog/${post?.slug}`}\n  />\n  <meta name="twitter:title" content={`${post?.title} | ${pageConfig.title}`} />\n  <meta name="twitter:description" content={post?.description} />\n  <meta name="twitter:image" content={`${pageConfig.siteImg}`} />\n  <meta name="twitter:label1" content="Category" />\n  <meta name="twitter:data1" content={`${post?.category}`} />\n</Head>\n```\n\n#### 직접 메타태그 하나하나 작성하는게 번거롭다면?\n\n[Open Graph prewiew & generate](https://www.opengraph.xyz/url/https%3A%2F%2Fxmunt.vercel.app%2F) 이 사이트에서는 메타데이터가 적용됐는지 각 SNS 별 미리보기를 볼 수 있고, 속성을 입력하면 자동으로 메타태그 생성도 해준다.\n\n<br></br><br></br>\n\n# 문제: 카카오톡 미리보기 업데이트가 안될 때\n\n### 상황\n\n분명히 `meta` 태그 다 적용해서 배포했고 다른 사이트들에선 잘 적용되는데\n카톡에서만,, 계속 og가 적용안된 미리보기가 보였었다!\n\n![230314-185422](/images/posts/open-graph/230314-185422.png)\n\n### 원인\n\n- 캐시가 문제!\n- og `meta`태그를 안 넣었을 때 이미 카톡에 url 공유를 했었던 것!\n- pc, 모바일에서 이미 전에 url 공유를 했었어서 해당 url 캐시가 남아있어서 그 전 미리보기를 불러왔던 것이었다.\n\n### 해결\n\n이럴 때는 카카오톡 캐시를 삭제하면 된다! 캐시 삭제 후 og가 반영된 미리보기로 잘 보여졌다!\n\n#### PC 캐시 삭제하기\n\n[카카오 공유 디버거](https://developers.kakao.com/tool/debugger/sharing)에서 URL 입력 후 캐시 초기화\n\n#### 모바일 캐시 삭제하기\n\n카톡 하단 맨 오른쪽 `...`설정탭 - 맨 아래 앱 관리 - 저장공간 관리 - 캐시 데이터 삭제(사진,동영상,음성파일은 유지됨)\n',
  },
  {
    slug: 'optimization-01',
    title: '빌드 속도 최소화? 근데 이제 Webpack과 React을 곁들인',
    content:
      "\n> 프로젝트가 커질 수록 번들 크기는 무거워지고 빌드 속도가 느려질 수 있습니다. 사용자가 첫 페이지에 진입할 때 느린 초기 로딩을 경험하지 않게 하기 위해서 Webpack과 React를 활용하여 코드를 분할하고 빌드 속도를 개선하는 방법을 살펴보겠습니다.\n\n<br /><br />\n\n### 🕖 빌드 시간 측정하기\n\n- [speed-measure-webpack-plugin](https://github.com/stephencookdev/speed-measure-webpack-plugin)로 Webpack loader와 plugin의 빌드 속도를 측정할 수 있습니다.\n- 사용 예시\n  ```js\n  // webpack.common.js\n  const SpeedMeasurePlugin = require('speed-measure-webpack-plugin')\n  const smp = new SpeedMeasurePlugin()\n  const webpackConfig = smp.wrap({\n    plugins: [\n      //...\n    ],\n  })\n  ```\n\n### 📐 번들 크기 분석하기\n\n- [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)를 사용하여 번들 크기를 분석했습니다.\n- 사용 예시\n\n  ```js\n  // webpack.production.js\n  const BundleAnalyzerPlugin =\n    require('webpack-bundle-analyzer').BundleAnalyzerPlugin\n  const { merge } = require('webpack-merge')\n  const common = require('./webpack.common.js')\n\n  module.exports = merge(common, {\n    mode: 'production',\n    plugins: [\n      new BundleAnalyzerPlugin({\n        openAnalyzer: true, // 보고서를 브라우저로 자동 오픈\n      }),\n    ],\n    //...\n  })\n  ```\n\n### Webpack 개발 모드 참고사항\n\n1. devtool : 웹팩 공식 문서에서는 `eval-cheap-module-source-map` 을 권장\n2. 제외해야 할 플러그인\n   왜냐하면 개발 모드일때는 빌드 속도가 빠르고 디버깅하기 쉬워야하기 때문에 압축 등 최적화 작업이 불필요합니다.\n   - TerserPlugin\n   - [fullhash]/[chunkhash]/[contenthash]\n   - AggressiveSplittingPlugin\n   - AggressiveMergingPlugin\n   - ModuleConcatenationPlugin\n\n<br /><br />\n\n---\n\n<br /><br />\n\n# 빌드 시간 최적화 방법\n\ndevelopment 모드에서는 빠른 빌드 속도와 디버깅이 편하기 위해 파일압축 등의 최적화 작업이 불필요하지만, production 모드일 때는 번들 크기를 줄여야하기 때문에 압축(Minify), 난독화 등의 최적화 작업이 필요합니다. 따라서 번들 크기를 줄이거나 빌드 속도를 최적화하는 방법을 알아보겠습니다.\n<br />\n\n> **압축(Minify)**\n> : 공백/들여쓰기, 주석, debugger, console.log 등을 제거하는 작업\n> **난독화(Uglify)**\n> : 기존 변수명, 함수명을 다르게 치환하는 보안 처리 작업. 난독화 단계가 높을 수록 코드를 해석하고 실행하는 시간이 늘어난다.\n\n <br />\n\n1. 불필요한 loader, plugin 제거\n2. loader 교체하기\n3. Code Splitting\n\n<br /><br />\n\n## 1. 불필요한 loader, plugin 제거\n\n#### Webpack v5부터 추가된 Asset 모듈 유형 사용하기\n\nv5 이전까진 `file-loader`, `url-loader`, `raw-loader`를 사용했지만, v5 이후부터 이 loader들을 대체하기 위한 모듈 유형이 추가됐습니다. 따라서 불필요해진 loader들을 제거하고 최소한으로 loader를 관리할 수 있게 됐습니다.\n\n- [Asset Modules](https://webpack.kr/guides/asset-modules/)\n  - asset/resource : file-loader 대체\n  - asset/inline : url-loader 대체\n  - asset/source : raw-loader 대체\n- 사용예시\n  ```js\n  module: {\n      rules: [\n        {\n          test: /\\.(png|jpe?g|gif|ico|webp)$/,\n          type: 'asset/resource',\n          generator: {\n            filename: 'images/[hash][ext][query]',\n          },\n        },\n      ],\n    },\n  ```\n\n<br />\n\n## 2. loader 교체하기\n\n#### 트랜스파일 loader 교체하기\n\n제일 처음에는 `babel-loader`를 사용했었습니다.\n하지만 파일 압축 플러그인을 설치 안했을 때 빌드 속도가 4.6s였기 때문에 플러그인을 추가 설치한다면 속도가 늘어날 것으로 예상됐습니다. 그래서 아예 loader를 교체해 빌드 속도를 줄이고자 했습니다.\nloader 종류로는 `babel-loader`, `ts-loader`, `esbuild-loader`, `swc-loader` 등이 있습니다. 이 중 앞선 3개 로더를 중심으로 살펴보겠습니다.\n\n<br />\n\n#### 1. `babel-loader` - 4.6s 소요됨 (플러그인 미설치 기준)\n\n- 압축 플러그인 추가 설치 필요\n  `terser-webpack-plugin` : JS 축소 플러그인(webpack v5 이상이면 내장되어 있어서 추가 설치 불필요)\n  `css-minimizer-webpack-plugin` : CSS 축소 플러그인\n\n#### 2. `ts-loader`\n\n- 타입스크립트 사용 시\n- 한계점 : 타입 검사하는 시간 때문에 빌드 속도가 저하됨\n- 한계점 보완하기 위해 `forkTsCheckerWebpackPlugin` 설치 필요\n- `forkTsCheckerWebpackPlugin`\n  : 별도의 스레드에서 타입 검사 진행하므로 빌드 시간을 줄일 수 있다.\n  - `transpileOnly: true` 옵션 활성화해서 `ts-loader`의 타입 검사를 해제하고 트랜스파일링만 수행하게 합니다.\n    해당 옵션은 `forkTsCheckerWebpackPlugin`을 사용한다면\n    `transpileOnly: true` 옵션이 자동 활성화되어있지만\n    `ts-loader` v9.3.0 미만이라면 옵션을 활성화시켜줘야 합니다.\n  - 예시\n  ```js\n  const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin')\n  //...\n  module.exports = {\n    // ...\n    module: {\n      rules: [\n        {\n          test: /.([cm]?ts|tsx)$/,\n          loader: 'ts-loader',\n          options: {\n            transpileOnly: true, // ts-loader v9.3.0 미만 시 옵션 활성화\n          },\n        },\n      ],\n    },\n    plugins: [\n      new ForkTsCheckerWebpackPlugin(),\n      // ...\n    ],\n  }\n  ```\n\n#### 3. `esbuild-loader` - ✅ 선택 2.1s 소요됨\n\n- 압축 플러그인이 내장되어 추가 설치 불필요\n  `EsbuildPlugin` - JS 축소 플러그인\n- 사용 중인 라이브러리와 호환이 안될 수 있어서 브라우저에서 정상 동작하는지 확인 필요\n- 타입 검사를 위해서 build script에 tsc 추가\n  ```json\n  //package.json 예시\n  \"typecheck\": \"tsc --noEmit\",\n  \"build\": \"npm run typecheck && webpack\"\n  ```\n\n> ### esbuild 란?\n>\n> esbuild는 차세대 번들러로 webpack5보다 빠른 속도를 가지고 있습니다. [(esbuild가 빠른 이유 - esbuild 공식문서)](https://esbuild.github.io/faq/) > ![](https://velog.velcdn.com/images/xmun74/post/19ce4ad4-cc92-4554-bda1-b3b7f10e101a/image.png)\n> 이렇게나 빠른데 esbuild를 번들러로 사용하지 않는 이유가 있습니다!\n> 아직까진 안정화된 단계가 아닌 점과 주의할 사항으로 Hot-module reloading, TypeScript 타입 검사 등의 기능 지원은 앞으로 없다고 합니다.[(참고)](https://esbuild.github.io/faq/#upcoming-roadmap)\n> 그런데 esbuild는 `esbuild-loader`를 지원하기 때문에 webpack의 loader와 결합할 수 있어서 webpack의 빌드 성능을 개선하는 데 활용할 수 있습니다.\n\n<br /><br />\n\n### ✅ esbuild-loader 적용 예시\n\n- webpack.common.js\n\n```js\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst path = require('path')\nconst dotenv = require('dotenv')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst SpeedMeasurePlugin = require('speed-measure-webpack-plugin')\nconst webpack = require('webpack')\n\nconst smp = new SpeedMeasurePlugin() // 빌드속도 측정 플러그인\n\ndotenv.config()\nmodule.exports = smp.wrap({\n  entry: `${path.resolve(__dirname, './src')}/index.tsx`,\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[contenthash].bundle.js',\n    chunkFilename: '[name].[contenthash].chunk.bundle.js',\n    clean: true,\n    publicPath: '/',\n  },\n  resolve: {\n    extensions: ['.js', '.jsx', '.ts', '.tsx'],\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n    },\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.[jt]sx?$/,\n        exclude: /node_modules/,\n        loader: 'esbuild-loader', //esbuild-loader로 교체\n        options: {\n          target: 'es2015',\n        },\n      },\n      {\n        test: /\\.(png|jpe?g|gif|ico|webp)$/,\n        type: 'asset/resource',\n        generator: {\n          filename: 'images/[hash][ext][query]',\n        },\n      },\n      {\n        test: /\\.css?$/,\n        exclude: [],\n        use: ['style-loader', 'css-loader', 'postcss-loader'],\n      },\n      {\n        test: /\\.svg$/i,\n        issuer: /\\.[jt]sx?$/,\n        use: ['@svgr/webpack'],\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, './public/index.html'),\n      favicon: './public/favicons/favicon.ico',\n    }),\n    new webpack.EnvironmentPlugin(['API_URL', 'USER_IMG_FIELD', 'CLIENT_URL']),\n  ],\n})\n```\n\n- webpack.dev.js\n\n```js\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst { merge } = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  devtool: 'eval-cheap-module-source-map',\n  devServer: {\n    port: 3000,\n    open: true, // 개발 서버 실행하면 브라우저 자동 오픈\n    // hot: true, // HMR(Hot Module Replacement) 사용할 수 있게 함. 4버전부터 자동 활성화됨.\n    historyApiFallback: true, //spa에서 react-router-dom 사용할 때 404에러 발생 방지\n    compress: true, // gzip 압축\n  },\n  optimization: {\n    minimize: false, // Terser 압축 플러그인 비활성화\n  },\n})\n```\n\n- webpack.prod.js\n\n```js\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst { EsbuildPlugin } = require('esbuild-loader')\nconst BundleAnalyzerPlugin =\n  require('webpack-bundle-analyzer').BundleAnalyzerPlugin\nconst { merge } = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  plugins: [\n    new BundleAnalyzerPlugin({\n      openAnalyzer: true, //번들 보고서를 브라우저로 자동 오픈\n    }),\n  ],\n  optimization: {\n    minimizer: [\n      // EsbuildPlugin으로 JS 축소\n      new EsbuildPlugin({\n        target: 'es2015',\n        css: true, // CSS assets 축소\n      }),\n    ],\n  },\n})\n```\n\n<br /><br />\n\n### 로더 교체 전/후 빌드 속도 비교\n\n- `babel-loader`일 때 `speed-measure-webpack-plugin`으로 빌드 시간을 측정한 결과 4.65s 소요\n  ![](https://velog.velcdn.com/images/xmun74/post/bbffbbbc-7bc1-4b2b-a988-d9518690a38b/image.png)\n- `esbuild-loader`로 변경 후 2.12s로 **약 2초 감소**\n  ![](https://velog.velcdn.com/images/xmun74/post/3f624ea8-8f5d-4360-8f84-12a9fe4a4a83/image.png)\n\n<br /><br /><br /><br />\n\n## 3. Code-Splitting\n\n여러 개의 파일들을 하나의 파일로 번들링하다보니 용량이 커지게 됩니다.\n이로 인해 SPA일 때 사용자가 첫 페이지에 진입하면 모든 코드가 포함된 대용량의 파일을 다운받다보니 초기 로드 시간이 길어지는 문제가 발생합니다.\n때문에 사용자와의 상호작용이 늦어지게 되어 사용자 경험을 저하시키게 됩니다.\n초기 로드 시간이 길어지면 사용자 이탈이 증가하기 때문에 초기 렌더링 시간을 단축하는 것이 중요합니다.\n<br />\n따라서 이를 해결하기 위해 Code-Splitting이 나타나게 됐습니다.\n대용량인 하나의 번들링 파일을 여러 개의 파일로 분할하는 작업입니다.\n이렇게 코드 분할한 뒤 사용자가 첫 페이지에 진입 시 필요한 코드만 불러오면 되기 때문에 좋은 사용자 경험을 제공할 수 있게 됩니다.\n<br />\nCode-Splitting을 두가지로 나눠서 살펴보겠습니다.\n\n<br />\n\n1. [Webpack으로 코드 분할하기](https://webpack.kr/guides/code-splitting/)\n2. React lazy로 특정 컴포넌트를 분할하고 동적 import하기\n\n<br /><br />\n\n### 1. Webpack으로 코드 분할하기\n\n#### 청크 분할하기\n\n- optimization의 `splitChunks`\n  : 큰 번들을 작은 번들로 분리하여 로딩 속도 개선하는 작업\n  ```js\n  module.exports = {\n    output: {\n      path: path.resolve(__dirname, 'dist'),\n      filename: '[name].bundle.js',\n    },\n    optimization: {\n      splitChunks: {\n        chunks: 'all', // 모든 유형의 청크 포함\n      },\n    },\n  }\n  ```\n- 리액트 관련 패키지끼리 모아서 분리하기\n  리액트를 프로젝트 거의 모든 곳에서 사용하고 있기 때문에 별도의 번들로 분리했습니다. 초기에 리액트 번들 + main 번들을 다운받고나서 업데이트를 하면 리액트 번들을 다시 다운 안받기 위해서 분리했습니다.\n  ```js\n  optimization: {\n      splitChunks: {\n        chunks: 'all', // 리액트 외 것들 분리\n        // 리액트 관련 패키지들을 번들로 묶어서 분리\n        cacheGroups: {\n          reactVendor: { // 코드분할하는 그룹명 지정\n            // 정규 표현식으로 모듈 분리 대상 지정\n            test: /[\\\\/]node_modules[\\\\/](react|react-dom|react-router-dom)[\\\\/]/,\n            name: 'vendor-react', // 출력될 번들 파일명\n            chunks: 'all', // 모든 유형의 청크에서 해당 패키지 분리\n          },\n        },\n      },\n    },\n  ```\n- build 후 출력된 dist/index.html을 살펴보면 아래처럼\n  vender-react 번들, 674.~번들, main 번들로 분할된 것을 확인할 수 있습니다.\n  ![](https://velog.velcdn.com/images/xmun74/post/e21797f4-74bb-461e-8a67-bb5c707b43bc/image.png)\n- `webpack-bundle-analyzer`를 사용하여 확인한 번들\n  ![](https://velog.velcdn.com/images/xmun74/post/acde96b4-42d5-4ffe-91aa-fa7d999a9ecc/image.png)\n\n<br /><br /><br />\n\n### 2. React lazy 사용하기\n\n위에서 webpack의 code splitting을 통해 번들 파일을 분할했다면\nReact lazy 기능으로 필요할 때만 컴포넌트를 동적 import 해오도록 작업해줘야 합니다.\n\n#### React lazy, Suspense\n\n`React lazy`는 컴포넌트를 JS Chunk으로 분리하게 해줍니다. 예를 들어서 Home 페이지 컴포넌트를 따로 Home.Chunk 번들 파일로 분할해주는 것입니다.\n`Suspense`를 사용하면 지연이 발생할 때 로딩중인 스피너를 띄운다던지 로딩상태를 표시할 수 있습니다.\n<br />\n위에서 674 번들처럼 번들명이 id로 자동으로 생성된 것을 볼 수 있습니다. id로 자동 생성된 번들명이 아니라 직관적인 번들명으로 지정해보겠습니다.\n\n<br />\n\n#### 주석으로 번들명 지정하기\n\n- `/* webpackChunkName: \"번들명\" */` 주석으로 번들명 지정하기\n\n  ```tsx\n  import React, { Suspense, lazy } from 'react'\n\n  const Home = lazy(() => import(/* webpackChunkName: \"home\" */ '@/pages/Home'))\n  const Bible = lazy(\n    () => import(/* webpackChunkName: \"bible\" */ '@/pages/Bible')\n  )\n  const Profile = lazy(\n    () => import(/* webpackChunkName: \"profile\" */ '@/pages/Profile')\n  )\n\n  const App = () => (\n    <Router>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/bible\" element={<Bible />} />\n          <Route path=\"/profile\" element={<Profile />} />\n        </Routes>\n      </Suspense>\n    </Router>\n  )\n  ```\n\n- webpack.common.js에서 설정\n  `chunkFilename` : 고유 해쉬값으로 청크 파일명 생성하여 중복 방지\n  ```js\n  module.exports = {\n    output: {\n      path: path.resolve(__dirname, 'dist'),\n      filename: '[name].bundle.js',\n      // 분할된 청크 파일명 지정\n      chunkFilename: '[name].[chunkhash].bundle.js',\n    },\n  }\n  ```\n  위에 지정된 번들명으로 파일이 잘 생성된 것을 확인할 수 있습니다.\n  ![](https://velog.velcdn.com/images/xmun74/post/7a555cee-db22-4baa-b51e-225a82a2229e/image.png)\n\n#### TS 사용 시 tsconfig 설정 참고하기\n\n- module 설정\n  `\"module\": \"esnext\"`\n  동적 import를 사용하기 위해선 module이 다음과 같은 설정일 때 동작합니다.\n  'es2020', 'es2022', 'esnext', 'commonjs', 'amd', 'system', 'umd', 'node16', 'nodenext'\n- 주석 제거 설정 비활성화\n  `\"removeComments\": false`\n  TS 컴파일 과정에서 주석을 제거하면 Webpack에서 번들명 지정 주석을 읽기 전에 삭제되어 정상 작동안될 수 있습니다. 또한 Webpack에서도 Minify 압축할 때 주석을 제거하므로 tsconfig에서 해당 옵션을 비활성화합니다.\n  ```json\n  compilerOptions: {\n    \"module\": \"esnext\",\n    \"removeComments\": false,\n    // ...\n  }\n  ```\n\n<br /><br />\n\n### code splitting 전 후 번들 크기 비교\n\nyarn build를 하면 보고서가 브라우저에 자동으로 열립니다.\n밑 사진과 같이 main에 커서를 올려서 용량을 알 수 있습니다.\n<br />\n\n> - Stat - 파일 입력 크키 (축소 전 크기)\n> - Parsed - 파일 출력 크기 (Minify, Uglify 등 축소 후 크기)\n> - Gzipped - 압축돼서 네트워크에 로드되는 크기\n\n<br />\n\n- 전 - Stat : 738KB / Parsed : 739KB / Gzipped : 179KB\n  ![](https://velog.velcdn.com/images/xmun74/post/6c97f601-b227-4de8-b9b1-ba417cb526b6/image.png)\n- 후 - Stat : 753KB / Parsed : 400KB / Gzipped : 130KB\n  Gzipped 기준으로 **약 27% 감소**\n  ![](https://velog.velcdn.com/images/xmun74/post/91e32d7a-8252-4232-8452-09ae829d85a9/image.png)\n\n<br /><br /><br /><br />\n\n---\n\n<br /><br /><br /><br />\n\n# 참고\n\n[Webpack 공식문서 - 빌드 성능](https://webpack.kr/guides/build-performance/)\n[esbuild-loader github](https://github.com/esbuild-kit/esbuild-loader)\nhttps://www.codemzy.com/blog/react-bundle-size-webpack-code-splitting\n",
  },
  {
    slug: 'pitfalls-of-jwt',
    title: 'JWT도 함정은 있다!',
    content:
      '\n### 들어가기에 앞서\n\n먼저 로그인을 구현하는 인증방식으로 Session(세션인증)과 JWT(토큰인증)가 있습니다.\n비교적 최신에 나온 JWT는 많은 기술 블로그에서도 소개가 되면서 무조건 기본으로 채택하는 경우가 있습니다.\n그런데 정말 JWT가 좋으니깐 기본으로 채택해야 할까요?\n\n<br />\n\n먼저 세션 - 토큰 인증방식의 트레이드오프를 살펴보기 위해 각 특징에 대해서 간단히 살펴보고자 합니다.\n\n# 1. 세션(서버)기반 인증방식\n\n: 서버나 DB에 사용자 인증정보 저장하는 방식\n\n- 사용자가 로그인을 하면 인증정보를 서버의 세션 저장소에 저장하고 사용자에게 식별자로 Session ID를 발급해주게 됩니다. 식별자인 Session ID는 쿠키로 저장되어 전송,전달하지만 실제 중요한 인증정보는 서버나 DB에 저장되어 있습니다.\n\n#### 장점\n\n- 프론트엔드측의 인증이 쉬워진다.\n- 보안 측면에서 조금 유리\n  서버에서 인증정보를 관리하기 때문에 만약 해커가 세션 ID를 탈취하더라도 서버에서 해당 세션을 무효화하여 로그아웃시키면 됩니다.\n\n#### 단점\n\n- 확장성 문제로 서버측 비용 증가\n  사용자가 증가하게 되면 많은 트래픽을 처리해야 되므로 그만큼 DB 리소스가 더 필요해지게 됩니다. 그래서 서버 확장하거나 세션 분산 설계가 복잡해진다는 문제가 있습니다.\n\n# 2. 토큰기반 인증방식\n\n: 클라이언트 측에 사용자 인증정보 저장하는 방식\n\n#### 장점\n\n- 서버의 무상태성\n  클라이언트측에 토큰을 저장되기때문에 유저의 정보를 서버에 저장해두지 않습니다. 서버는 토큰 해독 여부만 판단하게 됩니다.\n- 서버 확장에 용이\n  서버가 무상태성을 가지게 되면서 서버 메모리 과부화에 대한 문제가 해결되고 사용자가 늘어나도 확장에 용이해지게 됩니다.\n\n## 토큰방식의 함정\n\n### 1. 크기 문제\n\n세션은 쿠키에 세션 ID만을 담아 전송하기 때문에 트래픽이 적게 사용됩니다. [참고 글](https://developer.okta.com/blog/2017/08/17/why-jwts-suck-as-session-tokens#size)에서의 비교를 보면 세션의 크키는 6 byte인 반면, JWT(최소한의 정보-`iss`, `sub`, `nbf`, `exp`, `ìat`, `jti`, `typ`)는 304 byte로 세션보다 약 50배 이상의 크기를 보유하고 있습니다.\n따라서 JWT가 상대적으로 크기 때문에 쿠키에서 사용될 때, 요청 당 오버헤드가 발생될 수 있다는 점이 있습니다.\n\n### 2. 서버에서 로그아웃 제어 불가\n\n만약 해커가 토큰을 탈취했다고 한다면, 토큰이 만료되지 않는 한 해커는 서버에 요청을 할 수 있게 됩니다. 그리고 서버의 무상태성 특징때문에 토큰이 탈취돼도 로그아웃을 강제로 못하는 문제가 있습니다.\n이러한 문제를 보안하기 위해서 다음의 작업들을 수행할 수도 있습니다.\n\n#### 1. access 토큰 짧은 만료기한 지정\n\n: 짧은 만료기한을 줘서 탈취돼도 오래 사용하지 못하도록 합니다.\n\n- **단점**\n  만료되기 전까지 해커가 요청을 보내게 된다는 점이 있고,\n  사용자가 매번 로그인해야되므로 편의성이 안좋아지는 단점이 생깁니다.\n\n#### 2. refresh 토큰 긴 만료기한 사용\n\n: 로그인을 유지하기 위해 access 토큰 발급받기 위한 긴 만료기한을 가진 토큰입니다. access의 짧은 만료기한으로 사용자가 매번 로그인하지 않도록 refresh가 있다면 갱신할 수 있도록 처리합니다.\n\n- **단점**\n  - access 만료기한 짧기 때문에 refresh 요청이 증가됩니다.\n  - 만약 해커가 refresh 토큰을 탈취했다면 문제가 심각해집니다. 그래서 보안이 중요한 서비스에서는 refresh 토큰을 사용하지 않기도 합니다.\n\n> #### Q) refresh 토큰이 탈취돼서 이를 로그아웃을 시키기 위해 서버 저장소를 두게 된다면?\n>\n> A) refresh 토큰 검증을 위해 중앙 집중식 저장소가 필요하게 된다. 그렇다면 서버 저장소, 클라이언트 저장이 필요해지면서 JWT의 최대 장점이었던 무상태성이 무효화됩니다. 따라서 세션과 유사한 방식으로 관리하게 됩니다.\n\n<br/>\n\n### 3. 클라이언트 측의 토큰 저장위치로 인한 보안문제\n\n브라우저의 웹 저장소(LocalStorage, SessionStorage)나 쿠키에 토큰을 저장하게 되면 XSS, CSRF 공격에 취약하다는 문제가 발생합니다.\n\n#### 1. LocalStorage | SessionStorage 저장 시\n\n저장하는 방법이 편리하긴 하지만 자바스크립트에서 `document.cookie`으로 접근이 가능하게 되면서 XSS(Cross Site Scripting) 공격에 취약하게 되므로 비권장됩니다.\n\n#### 2. Cookie 저장 시\n\n쿠키에 옵션을 주면 XSS, CSRF 공격에 조금 안전해질 수 있습니다.\n\n- 옵션\n  - `httpOnly` : XSS 공격에 조금 안전 (JS에서 `document.cookie`로 접근 불가)\n  - `secure=true` : `HTTPS` 일때만 쿠키 전송가능\n  - `sameSite=strict` : **CSRF(Cross-Site Request Forgery 사이트 간 요청 위조)** 방지.\n    같은 도메인일때만 쿠키 전송가능\n    - `lax`\n      명시안하면 적용되는 기본값. GET 요청에선 쿠키 전송가능. 다른 도메인으로 쿠키 전송불가\n    - `none`\n      도메인 달라도 항상 쿠키 전송가능. `secure` 옵션 붙여야 작동함\n    - `strict`\n      동일 도메인일때만 쿠키 전송가능\n\n<br/>\n\n> **😱 쿠키 secure 설정 시 주의사항**\n>\n> - 같은 도메인이더라도 `(FE 로컬)http - (서버)https` 환경에서는 refresh 쿠키 전달 못받음.\n>   서로 scheme이 달라서 다른 사이트로 인식한다. FE 로컬에서 작업할 때는 [추가 작업](https://velog.io/@yaytomato/React-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-https%EB%A1%9C-%EB%A1%9C%EC%BB%AC-%ED%85%8C%EC%8A%A4%ED%8C%85%ED%95%98%EA%B8%B0)이 필요하다.\n\n> **😱 쿠키 sameSite 설정 시 주의사항**\n>\n> - BE 서버가 FE와 같은 도메인일때만 사용가능.\n>   배포환경은 BE-FE 같은 도메인이라 괜찮지만\n>   개발환경에서 BE, FE가 다르면 크로스도메인 이슈 발생\n>\n> - 추가 세팅 필요\n>   도메인이 서로 다르면 서버에서 cors header를 설정하거나 refresh 토큰 요청을 인증된 사이트에서만 하도록 세팅해줘야한다.\n>   FE에서 `axios.defaults.withCredentials = true;` 설정도 필요하다.\n\n<br/>\n\n#### 각 토큰의 저장 위치는?\n\n1. access 토큰 저장소 - 로컬 변수로 저장\n\n   - 변수에 저장해서 XSS, CSRF공격으로부터 안전.\n   - 단, 새로고침하면 변수가 없어지므로 refresh로 재갱신 받는 요청을 수행해야 합니다. (slient refresh)\n\n2. refresh 토큰 - `secure httpOnly sameSite` 쿠키에 저장\n   - `httpOnly`- XSS에 조금 안전\n   - `secure` - HTTPS으로만 접속 가능\n   - `sameSite=strict`- CSRF에 조금 안전\n\n#### JWT 전달방식 정리\n\n1. 로그인 요청 성공 시, 응답으로 Access(짦은 유효기한) 발급받고 쿠키로 Refresh(긴 유효기한) 토큰을 발급받기.\n2. Refresh는 서버에서 `httpOnly secure sameSite` 옵션 설정한 쿠키로 저장하여 전송.\n3. Access는 클라이언트에서 로컬 변수에 저장하고, 권한 필요한 요청마다 Authorization 헤더에 `Bearer ${accessToken}`의 규격으로 전송.\n4. slient refresh로 Access 재발급 후 갱신하기\n\n- Access 만료 시)\n  쿠키에 Refresh가 이미 담겨진 상태로 요청마다 전송되어서 refresh로 재발급받는 API(`/refresh`)에 요청하고 응답으로 Access 받아서 갱신하기\n- 새로고침 시)\n  변수로 저장한 Access가 없어져서 재발급을 받아야 함.\n  쿠키에 Refresh가 이미 담겼기 때문에 refresh로 재발급받는 API(`/refresh`)에 요청하고 응답으로 Access 받아서 갱신하기\n\n5. Refresh 만료 시 재발급 후 갱신하거나 or 로그아웃 시키는 로직으로 구현\n\n#### 추가 참고사항\n\n- 강제 로그아웃을 위해 refresh를 서버에 저장할 수 있습니다.\n- 단, JWT에서 서버의 무상태성이란 장점은 무효화되고 세션과 비슷하게 관리하게 됩니다.\n\n<br/><br/><br/><br/>\n\n---\n\n<br/><br/>\n\n# 마치며\n\n결국 상황에 맞게 고려해서 방식을 채택해야 합니다. 서비스의 규모, 동시 접속자 수, 보안이 중요한 서비스 등등 상황들을 따져보고 선택하거나 두가지 인증 방식을 결합하여 구현할 수도 있습니다.\n각각의 트레이드 오프가 무엇인지 확인해보면서 전통적인 방식의 세션과 비교적 최신방식의 토큰 중 상황에 맞춰서 선택할 필요가 있습니다.\n<br/>\n따라서 JWT를 무조건 깃헙의 템플릿(보일러플레이트)에 기본으로 구성한다던지 앞으로의 프로젝트에 사용할 지는 충분히 고민을 해 본 후에 적용하는 것이 적절하다고 생각했습니다.\n<br/>\n만약, 보안이 중요한 서비스에서 강제 로그아웃을 구현해야한다면 서버의 refresh 저장소 구축에 대해서는 결국 세션과 유사한 방식이 되기 때문에 이렇게 된다면 그냥 세션을 사용하면 되지 않을까라는 생각이 들었습니다.\n또한 여기서 소개한 방법들이 모두 완벽한 정답은 아니므로 참고한다는 의미로 봐주시고 혹시나 잘못된 정보가 있었다면 자유롭게 댓글로 남겨주시면 감사하겠습니다.\n\n---\n\n<br/><br/><br/><br/>\n\n# 참조\n\n- [JWT should not be your default for sessions](https://evertpot.com/jwt-is-a-bad-default/)\n- [LocalStorage vs. Cookies: All You Need to Know About Storing JWT Tokens Securely in the Front-End](https://codeburst.io/localstorage-vs-cookies-all-you-need-to-know-about-storing-jwt-tokens-securely-in-the-front-end-70dc0a9b3ad3)\n- [🍪 프론트에서 안전하게 로그인 처리하기 (ft. React)](https://velog.io/@yaytomato/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%90%EC%84%9C-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0#%F0%9F%A7%9E%E2%99%82%EF%B8%8Ftldr)\n- [[프로젝트] Refresh Token 적용하기](https://pomo0703.tistory.com/208#recentComments)\n- [Access Token과 Refresh Token을 어디에 저장해야 할까?](https://velog.io/@ohzzi/Access-Token%EA%B3%BC-Refresh-Token%EC%9D%84-%EC%96%B4%EB%94%94%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C#%EA%B8%B0%ED%98%B8-1%EB%B2%88-%EB%A1%9C%EC%BB%AC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-or-%EC%84%B8%EC%85%98-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80)\n- 로그아웃 관련 참고 - [SpringBoot + Jwt를 이용한 로그아웃](https://velog.io/@joonghyun/SpringBoot-Jwt%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B7%B8%EC%95%84%EC%9B%83)\n',
  },
  {
    slug: 'return-2024',
    title: '2024년 회고, 그리고 2025년 목표',
    content:
      '\n![250105-233221](/images/posts/return-2024/250105-233221.png)\n\n# 2024 log\n\n### 1. 이게 개발자다\n\n2024년은 주니어 개발자로 1년차를 맞이하던 해였습니다. 개발자를 직업으로 결정할 당시에는 사람들과 소통이 그래도 적은 직업이니깐 "적성에 맞겠지?" 라는 생각을 막연하게 가지고 있었습니다. 물론 회사 밖 사람들과 소통할 일은 없었습니다,, 그렇지만 회사 동료분들과^^ 아주~ 많은 소통을 하는 직업이였습니다.(기획자, 디자이너...) 그래도 기획자보다는 소통이 적다는 것에 마음에 위안(?!)을 삼으며,,, 소프트 스킬을 계속해서 늘려가야겠다고 생각했습니다. 그리고 이렇게 협업을 진행하면서 느낀점은 단순히 개발만 잘하는 것이 아니라, 업무에 대해서 주체적으로 생각하고 끊임없이 고민해서 적절한 결과물을 도출해내는 것이 중요하다고 깨닫게 됐습니다.\n\n<br />\n그리고 회사 내에서 기능 개발 작업을 빼고는 백오피스 2개를 개발하게 됐습니다. 시간 단축을 위한 프로젝트 하나와 시스템 안정성 향상을 위한 프로젝트로 각각 나눠서 진행했습니다. 이때 기획자 없이 진행을 했었는데 오랜만에 기획부터 하려니깐 창작의 기쁨(?!)을 느끼며 재밌게 개발할 수 있었습니다. 이 과정에서 다양한 사람과 협업을 하게 됐는데 여러 이해관계자의 말을 듣고 이를 기획으로 반영하는 것은 참 어려웠지만 그만큼 보람찬 작업이었습니다.\n\n<br />\n그렇게 1년을 채울 무렵 면접자가 되었습니다(?). 마음의 안식처였던.. 동료 개발자의 퇴사로 인해 면접자로 들어가서 기술 면접을 담당하게 되었다고 합니다....! 불과 일년전만 하더라도 지원자였는데...면접자로 들어가려니 감회가 남달랐습니다. 면접자분들이 다 이런 마음이셨구나.. 라는 생각이 들기도 했고 기술면접을 오랜만에 다시 공부하려니 부담이 되기도 했습니다. 그렇지만 제 이력서 또한 객관적으로 바라볼수가 있어서 나름대로 도움이 된다고 생각했습니다.\n\n<br /><br />\n\n### 2. 2024년에 한 활동\n\n#### 개발관련 활동\n\n- 기술서적 2권 스터디(2권밖에...못읽었다..)\n- 자료구조 스터디\n- 글또 스터디 시작(2주에 1개 블로그 글 포스팅)\n\n#### 개인적 활동\n\n- 헬스 시작(약 9개월간 다짐 끝에...)\n- 우당탕탕 자취 시작(오레오즈는 내 동반자)\n- 여행 3회(일본, 대만, 부산)\n\n<br /><br /><br /><br /><br />\n\n# 2025년 목표\n\n### 개발자로서의 목표\n\n#### 1. 지식을 체화시키기\n\n2024년 기술서적을 많이 읽지는 못했지만, 그래도 공부를 꾸준히 이어나갔습니다. 하지만 학습을 하고 나서 시간이 지나면 다시 잊어버리곤 했습니다. 뭐랄까 체화가 안돼서 기억에 안남는 느낌을 받았습니다.\n<br />\n그런데 최근 `널널한 개발자 유튜브`를 보다가 인상에 남은 말이 있었습니다. 공부에 대해서 말씀하시는 내용이었는데,\n"개념이 있고 그에 따른 실체가 있다. 개념에 대해서만 깊게 파다보면 책을 덮게 된다,,,"라는 느낌의 내용이었습니다. 그동안 너무 개념위주의 공부를 하다보니 이게 손에서 자꾸 빠져나가는 듯한 느낌을 받았습니다. 기억에 오래남지 않는 것이죠, 그래서 앞으로는 알고리즘 등의 공부를 하면 개인 프로젝트나 회사에 적용시킨다던지의 노력을 해보려고 합니다.\n\n#### 2. 능동적으로 기술부채 해결하기\n\n현재 회사에서는 기술부채에 대한 해결을 하기 위해서 충분한 시간을 확보하는 것은 쉽지 않은 상황입니다. 하지만 현재 몸담고 있는 이곳에서 단순하게 주어진 일만 하다보면 스스로에게도 아쉬움이 남을 것 같다고 생각이 들었습니다. 그래서 최근에는 작은 변화부터 시작하기 위해서 코딩컨벤션을 적용하는 시도를 할 수 있었습니다.\n<br />\n사실 초기에는 vue2에서 vue3로 마이그레이션을 계획했었습니다. 하지만 신규 기능 개발 요청이 들어오면서 충분한 시간이 주어지지 않았고, 결국에 마이그레이션 작업을 완료하지 못하게되는 경험을 하게 됐습니다.\n이 경험을 바탕으로, 이제는 리소스가 감당 가능한 범위에서 실질적인 개선을 하나씩 해나가는 방향으로 나아가고자 합니다. 작더라도 실현 가능한 작업들을 차근차근 고쳐나가는 경험을 해보고 싶습니다.\n\n<br /><br />\n\n### 개인적인 목표\n\n#### 1. 악기를 배우자\n\n이것은 개발 외적으로의 리프레쉬를 위한 취미가 필요하다고 생각되어서 목표를 삼게 되었습니다. 악기를 연주하는 동안에는 잡생각도 없어지고 일단은 신나기때문에,,, 새로운 악기를 배워보려고 합니다,,, 일단은 기타를 칠 줄 아니깐 일렉기타를 배워보려고 생각중입니다!\n\n#### 2. 기술서적 6권 + 일반서적 6권\n\n개발자로 노선을 틀게 되면서 기술서적을 주로 읽게 됐습니다. 그러다보니 일반서적을 전혀 안읽게 되었고 말의 어휘나 표현이 풍부하지 못하다는 생각을 하곤 했습니다. 안그래도 로봇같다는 말을 듣곤 했는데,,, 감성을 잃게 되다보니깐 리액션도 반사적으로 기계처럼 하게 되었습니다,,,,, 아무튼 그래서 2024년에는 적어도 6권의 일반서적을 읽는 것을 목표로 삼으려합니다!\n',
  },
  {
    slug: 'sitemap-seo',
    title: 'NextJS로 만든 블로그 글 검색되게 하자! - sitemap, 검색엔진',
    content:
      '\n작성한 블로그 글이 네이버, 구글 등에서 검색되게 하고 싶다면?\n각 사이트 검색엔진에 블로그 주소를 등록하고 sitemap을 생성해야한다!\n\n# 1. sitemap\n\n[구글 사이트맵 설명](https://developers.google.com/search/docs/crawling-indexing/sitemaps/overview?hl=ko)\nsitemap이란?\n사이트에 있는 페이지, 동영상 등의 정보를 제공하는 파일이다.\n검색엔진이 sitemap 파일을 읽고 더 효율적으로 사이트를 크롤링할 수 있게 도움을 준다.\n따라서 검색했을 때 해당 사이트가 검색되게 하려면? sitemap을 생성해서 등록해주면 된다.\n검색엔진에 사이트맵 URL을 추가해야되기 때문에 먼저 sitemap 파일부터 생성해보자!\n\n## 방법 1. `next-sitemap` 라이브러리로 sitemap.xml 만들기\n\n- [next-sitemap](https://github.com/iamvishnusankar/next-sitemap) 라이브러리 설치\n\n```bash\nnpm i -D next-sitemap\n```\n\n- `next-sitemap.config.js` 생성하고\n\n  ```js:next-sitemap.config.js\n  /** @type {import(\'next-sitemap\').IConfig} */\n  module.exports = {\n    siteUrl: \'본인 사이트 url\',\n    changefreq: \'daily\',\n    priority: 0.7,\n    sitemapSize: 7000,\n    generateRobotsTxt: true,\n    exclude: [],\n  }\n  ```\n\n- `tsconfig.json`에 "next-sitemap.config.js"을 추가한다\n\n  ```json:tsconfig.json {6} showLineNumbers\n  "include": [\n    "next-env.d.ts",\n    "**/*.ts",\n    "**/*.tsx",\n    "**/*.d.ts",\n    "next-sitemap.config.js"\n  ],\n  ```\n\n- `package.json` 수정\n  ` "build": "next build && next-sitemap && next export",`\n\n- npm run build 하면\n  `public/robots.txt`, `public/sitemap.xml`, `public/sitemap-0.xml` 파일 생성됨\n  원격 push 안되게 gitignore에 추가하기\n\n> - `sitemap.xml` - 어떤 URL을 크롤링하는 지 알려주는 역할\n> - `robots.txt` - 어떤 URL에 접근할 수 있는지 검색엔진 크롤러에 알려주는 역할\n\n## 방법 2. 직접 sitemap.xml 만들기\n\n원래는 `next-sitemap` 라이브러리를 사용했는데 자꾸 구글 콘솔에 인식이 안되서 직접 만들기로 했다.\n\n# 2. 검색엔진 등록 방법\n\n### 검색엔진 종류\n\n내 블로그는 주로 사용하는 구글과 네이버 검색엔진을 등록하기로 했다.\n\n- 구글 서치 콘솔 - [Google Search Console](https://search.google.com/search-console/welcome?utm_source=about-page)\n- 네이버 서치 어드바이저- [Naver Search Advisor](https://searchadvisor.naver.com/)\n- [다음 검색등록](https://register.search.daum.net/index.daum)\n\n## [Google Search Console](https://search.google.com/search-console/welcome?utm_source=about-page)\n\n1. 사이트 등록 - 도메인이 있다면 도메인을 등록하거나, URL접두어를 등록하기\n   ![230308-123054](/images/posts/sitemap-seo/230308-123054.png)\n\n2. 아래의 HTML `meta` 태그를 `_document.tsx` `Head`에 추가\n   ![230308-123528](/images/posts/sitemap-seo/230308-123528.png)\n\n```js:_document.tsx {4-7} showLineNumbers\n    return (\n      <Html>\n        <Head>\n          <meta\n            name="google-site-verification"\n            content="복붙"\n          />\n          {/*  */}\n        </Head>\n          {/*  */}\n      </Html>\n    )\n```\n\n3. 배포까지 하면 `확인` 클릭\n4. 사이트맵 url `sitemap.xml` 제출\n\n![230309-111659](/images/posts/sitemap-seo/230309-111659.png)\n\n## [Naver Search Advisor](https://searchadvisor.naver.com/console/board)\n\n1. 사이트 등록\n2. `_document.tsx`에 HTML `meta` 태그 추가\n3. 배포 후 `소유확인` 클릭\n4. 요청 - 사이트맵 제출 `본인 url/sitemap.xml` 입력\n5. 검증 - robots.txt - 수집요청 클릭, 검증 확인받기\n6. 설정 - 수집주기설정 - `빠르게`\n',
  },
  {
    slug: 'tsserver',
    title: 'tsserver란?',
    content:
      '\n<br /><br /><br /><br />\n\n![250202-230741](/images/posts/tsserver/250202-230741.png)\nts server가 뭔지 모르시겠다구요?! 하지만 타입스크립트를 써봤다면 다를 해봤을 `Restart TS Server`...\n그동안 멋모르고 지나갔던 TS Server에 대해서 알아보도록 하겠습니다!\n\n<br /><br /><br /><br />\n\n# tsserver란?\n\nTypeScript Standalone Server (aka TS Server)는 언어 서비스를 제공하는 독립적인 서버입니다. 여기서 언어 서비스란 IDE 같은 개발 환경에서 코드 자동완성(IntelliSense), 정의로 이동(Go to Definition), 타입 검사 등의 서비스를 말합니다.\n예를들면 밑처럼 호버시 타임검사 해주는 것을 확인할 수 있습니다.\n![](https://velog.velcdn.com/images/xmun74/post/6a6cc16e-092a-42fe-a48d-975554ac7e42/image.png)\n\nTypeScript와 같이 언어와 관련된 기능을 제공하기 때문에 언어 서비스라고 부릅니다.\nTS 서버는 JSON 프로토콜을 통해 IDE 또는 에디터와 통신하며, 실시간으로 코드를 분석해 오류나 경고를 반환하고, 필요한 정보를 에디터에 제공합니다.\n우리가 TypeScript를 설치하고 나면 vscode 상에서 타입검사 등을 할 수 있게 도와주는 것이 바로 tsserver라고 생각하시면 됩니다.\n\n<br /><br />\n\n[공식문서](<https://github.com/microsoft/TypeScript/wiki/Standalone-Server-(tsserver)#definition>)를 살펴보니 실행파일은 typescript를 설치한 다음 밑 폴더경로에서 찾을 수 있습니다.\n\n```bash\nnpm install --save typescript // 설치 후\nls node_modules\\typescript\\lib\\tsserver.js\n// .yarn\\sdks\\typescript\\lib\\tsserver.js // or yarn으로 설치 시\n```\n\n<br />\n\n---\n\n<br /><br /><br />\n\n그런데 갑자기 궁금해서 Vue 프로젝트에서 `node_modules\\typescript\\lib\\tsserver.js` 해당 경로가 있나 찾아보니 파일이 존재했습니다. 해당 프로젝트는 typescript를 설치하지도 않았는데 왜 있었을까요?\n![](https://velog.velcdn.com/images/xmun74/post/0ca263cf-8b85-4a5c-afcd-c23fc105ed1d/image.png)\n\n<br /><br />\n\n그 이유는 vscode에는 TypeScript가 내장되어 있습니다. 그리고 또 프로젝트의 설치된 패키지나 플러그인이 TypeScript를 의존성으로 설치하고 있기 때문입니다.\n<br />\n\nVSCode에서 명령 팔레트`(Ctrl + Shift + P 또는 Cmd + Shift + P)`를 활성화한 다음,\n`TypeScript: Select TypeScript Version` 입력해보면 밑과 같은 사진을 확인할 수 있습니다.\n\n1. `Use VS Code\'s Version`: VSCode에 내장된 version\n2. `Use Workspace Version`: 프로젝트 node_modules 내 version\n\n- ![](https://velog.velcdn.com/images/xmun74/post/120bcae3-f30e-455e-a59e-cad8de48dcfa/image.png)\n\n- 혹은 vscode 하단에 `{}` 클릭 후 버전을 확인하는 방법도 있습니다. [(사진출처)](https://code.visualstudio.com/docs/typescript/typescript-compiling#_compiler-versus-language-service)\n  ![](https://velog.velcdn.com/images/xmun74/post/7045fc4c-7ddd-4888-a8e9-5c55f581d7c2/image.png)\n\n<br />\n\n단 VSCode에 내장된 TypeScript는 오로지 `편집기 기능`에 목적을 뒀습니다. 그렇기 때문에 자동완성, 정의 이동 과 같은 기능을 지원하는 것에 그칩니다. 그래서 tsc 실행하거나 tsconfig.json 적용하려면 프로젝트에 직접 typescript를 설치해야합니다.\n\n---\n\n<br /><br /><br /><br />\n\n### 1. 동작 과정\n\n1. vscode에서 `.ts` 혹은 `.tsx` 파일 열면 백그라운드에서 자동으로 tsserver가 실행됩니다.\n2. IDE(클라이언트)가 해당 파일 초기화하도록 tsserver에 파일경로, ts버전, 옵션 등을 포함해서 요청합니다.\n3. 그러면 tsconfig.json 보고 tsserver가 프로젝트를 설정합니다.\n4. 이후 IDE에서 코드입력 혹은 저장 시 코드완성, 타입검사 등 서비스 사용하기 위해 tsserver에 요청합니다.\n5. tsserver는 코드를 분석한 후 응답을 반환합니다.\n\n<br /><br /><br />\n\n### 2. ts server 로그 확인하기 (vs code)\n\n1. `Ctrl + Shift + P` → "TypeScript: Open TS Server logs" 클릭\n   클릭하면 파일로 이동하며 해당 파일에서 실시간 로그를 확인할 수 있습니다.\n   가장 상단을 보면 TS Server 시작되는 것을 확인할 수 있습니다. - [참고](https://github.com/microsoft/TypeScript/wiki/Getting-logs-from-TS-Server-in-VS-Code)\n\n```bash\nInfo 0    [19:12:58.515] Starting TS Server\nInfo 1    [19:12:58.515] Version: 5.1.3\nInfo 2    [19:12:58.515] Arguments: /Users/~~~ //  파일경로 및 vscode 위치 표시\n```\n\n<br />\n\n그리고 가장 하단을 보면 실제로 언어 서비스 기능을 사용한 내용에 대해서 request, response 로그를 실시간으로 기록하고 있는 것을 살펴볼 수 있었습니다.\n![](https://velog.velcdn.com/images/xmun74/post/12e70ac9-6a18-4920-b978-f8ec645535bb/image.png)\n\n<br /><br /><br />\n\n### 3. 특징\n\n- JSON-RPC 프로토콜 사용\n- Node.js 환경에서 실행되는 백그라운드 프로세스(내 컴퓨터에서 별도의 프로세스로 실행됨)\n- 편집기와 IDE(VS Code, WebStorm 등) 지원\n\n<br /><br />\n\n## JSON-RPC 프로토콜\n\ntsserver는 편집기 및 IDE(VS Code 등)와의 통신을 위해서 [JSON-RPC (JavaScript Object Notation-Remote Procedure Call)](https://en.wikipedia.org/wiki/JSON-RPC) 기반의 프로토콜을 사용하고 있습니다.\n먼저 JSON 프로토콜 예시 내용을 살펴보기 위해 ts server 로그파일을 들어가보면 아래와 같은 JSON 객체 결과를 확인할 수 있습니다.\n\n<br />\n\n1. 요청 `(VSCode => tsserver)`\n\n- quickinfo : 코드위에서 마우스 호버 시 해당코드의 타입 정보를 가져오는 요청\n\n```bash\nInfo 1267 [19:46:46.993] request:\n    {\n      "seq": 210,             // 요청 시퀀스 번호\n      "type": "request",\n      "command": "quickinfo", // 요청 명령어\n      "arguments": {\n        "file": "/Users/username/Documents/파일경로.tsx",\n        "line": 12,\n        "offset": 28\n      }\n    }\n```\n\n<br />\n\n2. 응답 `(VSCode <= tsserver)`\n\n```bash\nPerf 1268 [19:46:46.994] 210::quickinfo: elapsed time (in milliseconds) 1.7008\n// 위는 성능로그. 요청 처리하는 데 걸린 시간 1.7ms\nInfo 1269 [19:46:46.995] response:\n\n{\n  "seq": 0,                // 응답 시퀀스번호\n  "type": "response",\n  "command": "quickinfo",\n  "request_seq": 210,       // 요청 시퀀스 번호\n  "success": true,          // 요청 성공여부\n  "body": {\n    "kind": "parameter",    // 대상이 함수의 매개변수임\n    "kindModifiers": "",\n    "start": { "line": 12, "offset": 24 },\n    "end": { "line": 12, "offset": 29 },\n    "displayString": "(parameter) label: any",   // 변수 label의 타입정보\n    "documentation": [],\n    "tags": []\n  }\n}\n```\n\n<br />\n\n3. 통신 방식 (stdin / stdout)\n   1. tsserver는 독립적인 node.js 프로세스를 실행합니다.\n   2. vscode => tsserver로 stdin(표준입력)을 통해 JSON 메시지를 요청하고\n   3. tsserver는 stdout(표준출력)으로 응답을 반환합니다.\n   4. vscode는 응답을 읽고 UI 업데이트합니다.\n\n```ts:microsoft/TypeScript/src/tsserver/nodeServer.ts\n\nfunction startNodeSession(options: StartSessionOptions, logger: ts.server.Logger, cancellationToken: ts.server.ServerCancellationToken) {\n    const rl = readline.createInterface({\n        input: process.stdin, // 표준입력으로 요청받음\n        output: process.stdout, // 표준출력으로 응답보냄\n        terminal: false,\n    });\n```\n\n<br /><br /><br /><br />\n\n## 사용 가능한 IDE\n\n- Visual Studio Code\n- Tide\n- Neovim 등....\n  - ![](https://velog.velcdn.com/images/xmun74/post/5b515aa6-c537-4935-ac7a-a018483841d5/image.png)\n  - 하지만 Nvim-Typescript의 깃헙을 들어가보면 DEPRECATED 되어 있다. 이유는 Neovim 0.5가 출시되면서 LSP가 공식적으로 지원되기 때문에 마이그레이션을 하라는 내용이 기술되어 있습니다....\n\n<br />\n\n참고로 VSCode는 JSON-RPC 프로토콜을 사용하고, 다른 IDE는 표준 LSP 프로토콜을 사용합니다.\n먼저 JSON-RPC가 개발됐고 이후에 Microsoft가 LSP를 공식표준으로 만든 케이스입니다.\n따라서 TS Server는 원래 JSON-RPC 기반이지만, 다른 IDE에서는 LSP를 통해서 사용될 수 있습니다.\n\n<br /><br />\n\n### LSP란?\n\nLSP(Language Server Protocol)는 소스코드편집기나 IDE와 언어 인텔리전스 도구를 제공하는 서버간에 사용되는 개방형 [JSON-RPC(JSON Remote Procedure Call)](https://en.wikipedia.org/wiki/JSON-RPC) 기반 프로토콜입니다. 여러 언어 서버를 표준화하기 위해서 개발됐고, 원래는 Microsoft용으로 개발되었지만 현재는 표준이 됐습니다. - [참고](https://en.wikipedia.org/wiki/Language_Server_Protocol)\n\n<br /><br /><br /><br />\n\n# 참고\n\n- [Standalone Server (tsserver) - microsoft/TypeScript github](<https://github.com/microsoft/TypeScript/wiki/Standalone-Server-(tsserver)>)\n',
  },
  {
    slug: 'v8-engine-01',
    title: 'JavaScript 실행하기 전 과정: V8 엔진의 작업 흐름',
    content:
      '\n# V8 엔진이란?\n\nC++로 작성된 Google의 오픈소스 **자바스크립트 및 WebAssembly 엔진**입니다. 오픈소스이기 때문에 [v8 github](https://github.com/v8/v8/tree/main)에서 소스코드를 확인할 수 있습니다.\n물론 자바스크립트 엔진에는 v8 외에도 Firefox (SpiderMonkey), Safari (JavaScriptCore), Microsoft Edge (Chakra 기반이었지만 최근 [Chromium](https://support.microsoft.com/en-us/microsoft-edge/download-the-new-microsoft-edge-based-on-chromium-0f4a3dd7-55df-60f5-739f-00010dba52cf), V8을 사용하여 다시 만들어짐) 등이 있습니다.\nChrome과 Node.js 등에서 사용되고, 자바스크립트 코드를 파싱하고 실행합니다. 또한 실행 속도를 높이는 등의 최적화 작업을 수행하기 위해서 JIT(Just In Time)컴파일러를 사용하고 있습니다.\n\n<br /><br /><br />\n\n---\n\n<br /><br /><br />\n\n## 파이프라인\n\nV8 엔진의 작업흐름을 전체적으로 파악하기 위해서 파이프라인을 살펴보도록 하겠습니다. 그런데 파이프라인의 역사?도 조금씩 변경된 부분들이 있어서 간단하게 살펴보고 넘어가겠습니다.\n\n#### 파이프라인의 변경\n\n- 2017년 이전 : Full-codegen + Crankshaft (+Ignition +TurboFan)\n  이후에 Ignition과 TurboFan로 대체되게 됩니다. [(사진출처)](https://v8.dev/blog/ignition-interpreter)\n\n  - ![](https://velog.velcdn.com/images/xmun74/post/e77dd87e-c8ec-42b0-8e00-f47b58c5954f/image.png)\n\n- 2017~2021년 : Ignition + TurboFan [(사진출처)](https://docs.google.com/presentation/d/1OqjVqRhtwlKeKfvMdX6HaCIu9wpZsrzqpIVIwQSuiXQ/edit#slide=id.g1453eb7f19_0_391)\n\n  - ![](https://velog.velcdn.com/images/xmun74/post/28911015-48f5-49d1-b2c1-946fa792f6e5/image.png)\n\n- 2021년(v9.1부터 변경된 파이프라인) : Ignition + `Sparkplug` + TurboFan [(사진출처)](https://v8.dev/blog/sparkplug)\n\n  - 중간에 Sparkplug가 추가되었습니다. ![](https://velog.velcdn.com/images/xmun74/post/a8b0f6bf-bd50-4658-87cf-be50cbeed96f/image.png)\n\n---\n\n- [(사진출처)](https://medium.com/@yanguly/sparkplug-v8-baseline-javascript-compiler-758a7bc96e84)![](https://velog.velcdn.com/images/xmun74/post/52b0873d-fe19-41cd-945e-4dcb8f47372f/image.png)\n\n이렇게 가장 최신의 파이프라인을 가지게 되었고 밑 내용대로 작업이 이뤄지게 됩니다.\n\n#### 1. JS 코드 -> AST로 Parsing\n\n- JavaScript 코드 -> AST(Abstract Syntax Tree: 추상구문트리로)로 파싱\n  코드를 컴퓨터가 쉽게 이해하도록 구조화하는 작업입니다.\n\n#### 2. Ignition(인터프리터)으로 Byte code 생성\n\n- AST를 바탕으로 바이트코드(Byte code)를 생성합니다.\n- 가상머신에서 실행되며 이때 인터프리터가 작동됩니다.\n\n#### 3. Sparkplug(비최적화 컴파일러)로 기계어 생성\n\n- 비최적화된 컴파일러로 바이트코드를 빠르게 네이티브 코드(기계어)로 변환\n\n#### 3. TurboFan(성능 최적화 컴파일러)로 기계어 생성\n\n- JIT 컴파일러 사용해서 바이트코드를 네이티브 코드(기계어)로 변환\n\n#### 4. 실행\n\n- 생성한 네이티브 코드를 CPU에서 실행\n  - 초기실행에서는 비최적화된 네이티브 코드가 실행되고\n  - 이후 성능최적화 작업을 거쳐 최적화된 네이티브 코드를 실행합니다.\n\n<br /><br />\n\n---\n\n## 1. JS를 AST로 파싱 : 코드 구조 이해하기\n\n사람이 작성한 JS 코드를 컴퓨터가 이해할 수 있도록 계층적 구조로 만들어줘야 합니다.\n\n```js\nlet x = \'문자열\' // 지금은 문자열 String\nx = 1 // 이제는 숫자 Number\n```\n\n그리고 JS는 동적 언어이기 때문에 실행중에 타입이 바뀌기도 합니다. 실행 전에 타입을 고정하기가 어렵습니다. 이러한 JS의 복잡한 동작을 처리하기 위해서는 먼저 코드 구조를 파악해야합니다. 그래서 코드를 실행하기 전에 컴퓨터가 이해하기 쉬운 AST로 구조화해두게 됩니다. 이렇게 해두면 이후 컴파일이나 최적화 작업을 효율적으로 처리할 수 있습니다. 타입 정보는 이후 코드를 실행할 때 동적으로 학습하게 됩니다.\n<br/>\n\n1. parser\n   즉시 실행에 필요한 코드를 전체 파싱합니다. 하지만 처리시간이 상대적으로 깁니다.\n\n   - AST, 스코프 생성\n   - 문법 오류 검출\n   - 소스코드 [(v8/src/parsing/parser.cc)](https://github.com/v8/v8/blob/main/src/parsing/parser.cc)\n\n2. [pre-parser](https://v8.dev/blog/preparser)\n   즉시 실행에 필요한 코드가 아니고 나중에 실행될 코드일 때 사용하는 파서입니다.\n\n   - AST 미생성, 스코프 생성\n   - 일부 문법 오류만 검출\n   - 소스코드 [(v8/src/parsing/preparser.cc)](https://github.com/v8/v8/blob/main/src/parsing/preparser.cc)\n\n<br/>\n파서는 위에 parser와 pre-parser(lazy-parser) 2개로 구분되어 사용됩니다.\n실행되지 않는 함수나 코드를 전부 일반 파서로 처리하면 초기 로딩시간이 길어지기 때문에 pre-parser(lazy-parser)로 초기 로딩 시간을 단축시키는 것이 목적입니다.\n\n- 예시 코드\n\n  ```js\n  const name = \'유재석\'\n  console.log(name) // parser\n\n  function greeting() {\n    console.log(\'Hello!\') // pre-parser\n  }\n\n  greeting() // 나중에 호출될 때 parser\n  ```\n\n<br/><br/>\n그리고 밑처럼 AST로 파싱한 결과물을 보고 싶다면 [AST Explorer](https://astexplorer.net/) 사이트에서 테스트해볼 수 있습니다.\n\n- JS 코드\n\n```js\nconst name = \'유재석\'\n```\n\n- AST 파싱 후\n\n```json\n{\n  "type": "Program",\n  "start": 0,\n  "end": 19,\n  "body": [\n    {\n      "type": "VariableDeclaration", // 변수 선언\n      "start": 0,\n      "end": 19,\n      "declarations": [\n        {\n          "type": "VariableDeclarator", // 대입문\n          "start": 6,\n          "end": 18,\n          "id": {\n            "type": "Identifier", // 변수 식별자\n            "start": 6,\n            "end": 10,\n            "name": "name" // 식별자명\n          },\n          "init": {\n            "type": "Literal", // 리터럴 값\n            "start": 13,\n            "end": 18,\n            "value": "유재석", // 실제 값\n            "raw": "\'유재석\'"\n          }\n        }\n      ],\n      "kind": "const"\n    }\n  ],\n  "sourceType": "module"\n}\n```\n\n<br /><br />\n\n---\n\n## 2. Ignition interpreter로 Byte code로 변환하기\n\n- [이미지 출처 - v8](https://v8.dev/blog/background-compilation)\n  ![](https://velog.velcdn.com/images/xmun74/post/55e235c0-1763-480e-b152-4ce4c86ac7d0/image.png)\n\n: 코드 한줄 실행할때마다 AST를 받아서 바이트코드로 반환해주는 인터프리터\n<br/>\n\n- **메모리 사용량을 감소**하기 위해 컴파일러가 아닌 인터프리터를 사용\n  : 컴파일러는 실행되지 않을 코드까지 네이티브 코드(기계어)로 변환해서 메모리 낭비가 발생하지만,\n  인터프리터는 바이트코드로 변환하기 때문에 상대적으로 용량도 작고, 한 줄씩 실행될때마다 변환하여 메모리 사용에 효율적입니다.\n  <br />\n\n- 이전 방식이었던 Full-codegen 대체하는 인터프리터\n  Full-codegen 컴파일의 단점으로 인해 인터프리터 단계가 추가되었다고 보시면 됩니다. 초기에 코드 실행 시 복잡한 네이티브 코드 생성이나 최적화를 건너뛰고, 빠르게 바이트코드를 사용해서 실행시키는 것에 초점이 맞춰져 있습니다.\n  <br />\n\n  > 마지막으로 바이트코드를 생성하는 것이 Full-codegen의 기준 컴파일된 코드를 생성하는 것보다 빠르기 때문에 Ignition을 활성화하면 일반적으로 스크립트 시작 시간이 개선되고 결과적으로 웹 페이지 로드도 개선됩니다.\n  >\n  > [- v8 Launching Ignition and TurboFan 본문 중 -](https://v8.dev/blog/launching-ignition-and-turbofan)\n\n<br />\n- 터미널에서 바이트코드 출력해보기\n  코드를 바이트코드로 보고 싶으면 `node --print-bytecode index.js`를 실행해보면 확인할 수 있습니다. 참고사항으로는 만약 함수면 함수를 실행해야 결과물을 확인할 수 있습니다.\n\n<br /><br />\n\n---\n\n## 3. Sparkplug 비최적화 컴파일러 도입\n\n: 터보팬과 달리 최적화를 수행하지 않고 바이트코드를 -> 기계어 코드로 빠르게 생성하는 컴파일러\n\n- 이그니션 - 터보팬의 중간단계인 **비최적화 컴파일러**\n- 바이트코드 기반으로 네이티브코드(기계어) 생성하므로 속도가 빠름\n- 터보팬에 비해서 최적화 작업을 생략하기 때문에 메모리 사용량 적음(최적화는 터보팬에 맡김)\n  최적화하는 데에는 비용이 발생합니다. 그런데 이전에 너무 섣부린 최적화로 인한 비용이 발생했었기 때문에 이러한 문제를 덜고자 심플한 비최적화 컴파일러를 도입하게 됩니다.\n\n## 4. 필요시 Turbofan compiler로 성능 최적화\n\n: 최적화 작업을 수행해서 바이트코드를 머신코드로 변환하는 컴파일러\n\n- 바이트코드를 분석해서 JIT 컴파일러로 성능 최적화 작업을 수행합니다.\n- 터미널에서 최적화 코드 로그 출력해보기\n  `node --trace-opt index.js`\n\n<br/><br/><br/><br/>\n\n> ### 자동차 엔진의 구조를 메타포로 사용한 용어 설명\n\n처음에 작업흐름을 쭉 살펴보면 용어들이 굉장히 생소하게 느껴질 수 있습니다. 하지만 이 용어들이 어디서 차용되었는지를 이해하면 나중에 해당 내용들을 다시봐도 직관적으로 이해할 수 있기 때문에 마지막으로 간단하게 살펴보겠습니다.\n\n#### V8\n\n: 경주용 자동차나 비행기에서 사용되는 엔진으로, v자 형태의 8기통 고성능 엔진인 [v8](https://en.wikipedia.org/wiki/V8_engine)의 이름을 따서 만들었습니다. (이게 진짜 엔진이름인 줄은 몰랐습니다..)\n\n<img\n  src="/images/posts/v8-engine-01/241123-223547.png"\n  width="200"\n  height="200"\n/>\n\n#### Ignition(점화)\n\n: 엔진을 가동시키는 점화 작업으로, JS코드를 빠르게 실행가능한 단계인 바이트코드로 변환하는 작업을 떠올리면 됩니다.\n\n#### TurboFan\n\n: 자동차 엔진의 터보차저로 고성능 가속 작업에 해당합니다. 이는 성능 최적화 작업을 수행하는 JIT 컴파일러를 떠올리면 됩니다.\n\n<br /><br /><br /><br />\n\n---\n\n<br /><br /><br /><br />\n\n여기까지 V8 엔진의 작업 흐름에 대해서 살펴보았습니다. 이번 편에서는 Spartplug나 TurboFan에 대해서 깊게 보지 않았는데... 관련 내용들이 살펴볼게 좀 있고, 뭔가 글이 너무 길어질 것 같아서 다음 블로그 글로 써보려고 합니다!\n\n<br /><br /><br /><br />\n\n---\n\n# 참고\n\n- [V8 github](https://github.com/v8/v8)\n- https://evan-moon.github.io/2019/06/28/v8-analysis/\n- [Youtube - BlinkOn 6 Day 1 Talk 2: Ignition - an interpreter for V8](https://www.youtube.com/watch?v=r5OWCtuKiAk)\n',
  },
  {
    slug: 'v8-engine-02',
    title: 'JavaScript 실행하기 전 과정: 컴파일 과정에 대해서',
    content:
      "\n# 목차\n\n- 컴파일러 차이 AOT vs JIT\n- Sparkplug\n- Maglev\n- TurboFan\n- 히든 클래스\n\n<br /><br />\n\n---\n\n<br /><br />\n\n컴파일 전략을 컴파일 시점에 따라 구분되는 AOT(Ahead-of-Time)과 JIT(Just-In-Time)으로 나눠서 설명해보겠습니다.\n여기서 `Time`은 코드실행시간으로 `런타임`을 말합니다.\n\n## 1. AOT(Ahead-of-Time) 컴파일러\n\n: 런타임 이전(코드 실행 전)에 미리 정적으로 컴파일(소스코드를 기계어로 변환)\n\n- 정적언어에 적합 : (예시) C/C++, Swift, Rust\n- 컴파일 시간 김 : 실행 전 모든 코드를 완전히 컴파일합니다.\n- 초기 실행 속도가 빠름 : 실행 후 추가 작업이 없으므로 초기 실행 속도가 빠릅니다.\n\n## 2. JIT(Just-In-Time) 컴파일러\n\n: **런타임(코드 실행시점)일때 동적으로** 컴파일(소스코드를 기계어로 변환)\n<br />\n\n> 자바스크립트는 동적 타이핑 언어이기 때문에 실행 중에 최적화가 필요하므로 JIT 컴파일러를 사용합니다.\n\n<br />\n- 동적언어에 적합 : (예시) JavaScript, Ruby 등\n- 컴파일 시간 짧음 : 실행 중 필요한 부분씩 컴파일합니다.\n- 초기 실행 속도 비교적 느림 : 초기 실행에 컴파일 작업이 포함되기 때문에 비교적 느리지만, 최적화를 통해 점진적으로 성능이 향상됩니다.\n- 런타임 정보(변수 등)에 접근 가능\n\n<br /><br /><br /><br />\n\n---\n\n<br /><br />\n\n![241222-202514](/images/posts/v8-engine-02/241222-202514.png)\n\n## [Sparkplug](https://v8.dev/blog/sparkplug)\n\n: 💥 빠른 초기 실행을 위해 최적화 작업이 제거된 JIT 컴파일러.\n\n- 바이트코드를 최적화되지 않은 머신 코드로 컴파일\n- `낮은 코드품질`로 `빠르게` 컴파일하여 초기 실행 속도 높임\n- Ignition과 TurboFan 사이에서 갭이 너무 크기 때문에 기본 JIT를 도입\n- 자주 실행되지 않는 코드나 최적화가 필요없는 코드에 적용\n\n## [Maglev](https://v8.dev/blog/maglev)\n\n: 🚅 반복 실행되는 코드에 간단한 최적화를 수행하는 JIT 컴파일러\n\n- 2023년에 추가된 Sparkplug와 TurboFan 사이에서 트레이드오프를 줄이게 위해 도입한 SSA기반의 최적화 컴파일러.\n- Sparkplug보다 개선된 코드 품질(성능)\n- TurboFan보다는 빠른 속도\n- Sparkplug보다 약 20배 느리게 코드를 생성하지만, TurboFan보다는 10~100배 빠르게 코드를 생성\n- 코드가 자주 실행될 경우 Sparkplug에서 Maglev로 전환\n\n## [TurboFan](https://v8.dev/docs/turbofan)\n\n: 🚀 고성능 최적화 작업의 JIT 컴파일러.\n\n- `높은 코드품질`의 `느린 속도`로 컴파일(~100배 속도차이)\n- 많이 사용되는 코드 hot code를 최적화시킴\n- 최적화 코드가 더이상 사용되지 않으면 역최적화(Deoptimization) 진행\n- 히든클래스, 인라인 캐싱 등 최적화 기법 사용\n\n## 실행 및 Profiling\n\n: 코드를 실행하고 나서 많이 사용되는 코드인지 프로파일링하여 데이터를 수집하고, hot code면 TurboFan에 전달하여 최적화 진행할 수 있도록 도움을 줍니다.\n\n- 런타임 중 코드의 성능 데이터를 모니터링하여 수집\n- hot code를 분석 : 많이, 자주 사용되는 코드를 확인 (함수 호출 빈도, 루프 실행 획수, 객체 구조 변경 등)\n- Deoptimization : 최적화 코드가 런타임 상황에 부적절해지면 역최적화 작업\n\n<br /><br />\n\n---\n\n<br /><br /><br /><br />\n\n# 동적으로 변하는 객체의 프로퍼티를 어떻게 빨리 탐색할까?\n\n### 자바스크립트는 동적 타이핑 언어 (Dynamic Typing)\n\n```js\nconst obj = {}\nconsole.log(obj) // {}\n\nobj.mc = '유재석'\nconsole.log(obj) // {mc: '유재석'}\n\nobj.age = 50\nconsole.log(obj) // {mc: '유재석', age: 50}\n```\n\nJS는 동적 언어로 런타임에 객체의 프로퍼티의 데이터타입, 순서, 값, 수가 변경될 수 있습니다. 그래서 프로퍼티 값 읽을 때마다 찾아내는 동적 탐색이 필요합니다. 이 동적탐색은 속도 저하때문에 성능 이슈가 있습니다.\n그래서 v8엔진은 동적탐색보다 빠른 객체의 프로퍼티 접근 처리를 위해 내부적으로 히든클래스를 사용하여 최적화합니다.\n\n## 히든 클래스 Hidden Class\n\n히든 클래스는 TurboFan의 최적화 방법으로 객체의 구조와 속성을 추적하여 빠른 접근이 가능하도록 최적화하는 작업입니다.\n<br/>\n\n> ` Hidden Class = Maps = Structure = Shapes`\n> : Hidden Class 명칭에서 JS에서의 Class와 혼동을 막기 위해 다르게 부르기도 합니다. 그리고 엔진 별로 지칭하는 용어를 다르게 부릅니다.\n>\n> - V8 - Maps\n> - JavaScriptCore(Safari) - Structure\n> - SpiderMonkey (Firefox) - Shapes\n\n<br/>\n\n#### 특징\n\n1. 각 프로퍼티에 대해서 offset을 가짐\n   > offset이란? 객체의 프로퍼티가 메모리에서의 상대 위치를 나타내는 주소\n2. 새로운 프로퍼티 추가/제거 시 새로운 히든 클래스로 생성\n\n![241222-221147](/images/posts/v8-engine-02/241222-221147.png)\n객체의 프로퍼티명 `x`, `y`는 히든클래스에 저장됩니다. 그리고 해당 프로퍼티의 offset(몇번째 인덱스에 위치하는지)가 생성됩니다.\n\n### 장점: 동일한 프로퍼티를 가진 다른 객체일 때 재사용\n\n![241222-221210](/images/posts/v8-engine-02/241222-221210.png)\n위 예시는 `obj`와 `obj2` 두 객체의 프로퍼티 구조와 순서가 모두 동일합니다. 그렇기 때문에 동일한 히든 클래스를 공유하여 재사용한다는 장점이 있습니다.\n이는 동일한 구조의 객체를 반복해서 만들어도 객체 프로퍼티 접근 시 동적탐색을 피해서 이미 생성된 히든클래스를 재사용합니다.\n\n### 지양: 객체 프로퍼티를 동적 생성할 때\n\n![241222-222924](/images/posts/v8-engine-02/241222-222924.png)\n\n```js\nconst obj = {}\nobj.x = 2 // 히든 클래스 H1 생성\nobj.y = 3 // 히든 클래스 H2로 전환\n```\n\n맨 처음 빈 객체`{}`로 시작해서 이후 동적으로 프로퍼티가 추가되고 있는 코드일때는\n한 줄 씩 실행될때마다 새로운 히든 클래스를 생성하게 됩니다. 이렇게 되면 기존 히든클래스에서 다른 히든클래스로 생성되면서 성능에 영향을 미칩니다. 따라서 속성을 동적으로 추가하는 방식을 지양하는게 좋습니다.\n<br/>\n\n> 객체 초기 생성 시 모든 프로퍼티를 초기화로 생성하거나 동일한 순서와 구조로 생성하자.\n\n<br/><br/><br/>\n\n### 개발자도구에서 확인하기\n\n1. 콘솔에 코드 입력\n\n   ```js\n   function Broadcast(title) {\n     this.title = title\n   }\n   const one = new Broadcast('무모한 도전')\n   const two = new Broadcast('무한도전')\n   ```\n\n2. Memory 탭 - Heap snapshot - Take snapshot 클릭해서 스냅샷 찍기\n   ![](https://velog.velcdn.com/images/xmun74/post/317d88b0-b5b7-4221-9503-b661abe70ea3/image.png)\n\n3. 'Broadcast'로 필터 검색하기\n   - 참조하는 히든클래스 ID가 동일함\n     ![](https://velog.velcdn.com/images/xmun74/post/cf810dd2-1a9e-4be0-a1c6-99e64d7f3250/image.png)\n\n#### 객체 프로퍼티를 동적 생성한 경우도 확인해보기\n\n생성자 함수로 생성된 one 객체에 프로퍼티를 추가해보겠습니다.\none객체는 새로운 프로퍼티가 생성됐기 때문에 신규 히든클래스(map)이 생성됩니다.\n\n```js\nfunction Broadcast(title) {\n  this.title = title\n}\nvar one = new Broadcast('무모한 도전')\nvar two = new Broadcast('무한도전')\n// 여기까지 one, two는 같은 히든 클래스 참조\none.short = '무도' // 추가됨\n// 여기부터 one, two는 서로 다른 히든 클래스 참조\n```\n\n스냅샷을 다시 찍어보면 Map ID가 달라진 것을 확인할 수 있습니다. one, two 객체가 서로 다른 히든 클래스를 참조하고 있습니다.\n![](https://velog.velcdn.com/images/xmun74/post/28778d1b-6529-4e88-aba0-d9c3e2e91f96/image.png)\n\n<br /><br /><br />\n\n---\n\n<br /><br />\n\n# 참고\n\n- [Maps (Hidden Classes) in V8 - v8](https://v8.dev/docs/hidden-classes)\n\n- [V8의 히든 클래스 이야기 - LINE](https://engineering.linecorp.com/ko/blog/v8-hidden-class)\n\n- [V8의 자바스크립트를 위한 성능 팁 - web.dev](https://web.dev/articles/speed-v8?hl=ko&source=post_page-----2e136ec1cfeb--------------------------------)\n\n- https://mathiasbynens.be/notes/shapes-ics\n\n- [JIT 취약점 되살리기: Chrome 브라우저에서 Maglev 컴파일러 버그의 힘 활용 - Tencent Security Xuanwu Lab PPT](https://medium.com/@vxrl/javascript-debugging-with-maglev-compiler-6b2a26cb1a3a)\n\n- https://i.blackhat.com/EU-23/Presentations/EU-23-Liu-Reviving-JIT-Vulnerabilities.pdf\n",
  },
]
