export const cachedPosts = [
  {
    slug: 'crlf',
    title: '개행.줄바꿈.EOL(end-of-line)문자란? - CR, LF',
    content:
      '\n# 어쩌다 LF를 검색…?\n\n다짜고짜 LF와 CR에 대해서 알고싶어서(?!) 이를 검색해본 건 아니고\n아래와 같은 에러를 만나서 이에 대해 알아보게되었다.\n윈도우 환경에서(중요) eslint, prettier를 설정하던 중 코드의 마침부분마다 에러가 표시되고 있었다.\n\n### 에러\n\n```\nDelete `␍`\n```\n\n![241013-173454](/images/posts/crlf/241013-173454.png)\n\n<br />\n\n### 원인\n\n- 회사는 윈도우고 개인 노트북은 맥인데,\n  맥에서 작성했던 prettierrc를 그대로 복붙했더니 문제가 발생했던 것이다.\n\n### 해결 방법\n\n- "endOfLine": "lf"에서 "auto"로 변경\n  `"endOfLine": "auto",`\n\n```js\n{\n  "semi": true,\n  "singleQuote": false,\n  "tabWidth": 2,\n  "trailingComma": "es5",\n  "arrowParens": "avoid",\n  "bracketSameLine": false,\n  "bracketSpacing": true,\n  //  "endOfLine": "lf", // 삭제\n  "endOfLine": "auto", // 추가\n   "printWidth": 120,\n  "proseWrap": "preserve"\n}\n\n```\n\n- Prettier v2.0.0부터 endOfLine의 기본값이 auto에서 lf로 변경됨\n  - [Options · Prettier](https://prettier.io/docs/en/options.html#end-of-line)\n\n---\n\n<br /><br />\n\n# 줄바꿈의 시작\n\n![](https://velog.velcdn.com/images/xmun74/post/267298e1-ed2e-46c7-9f27-4ca5a9ac02d7/image.gif)\n\n- [참고 영상](https://www.youtube.com/watch?v=FkUXn5bOwzk)\n\n![241013-173532](/images/posts/crlf/241013-173532.png)\n\nLF와 CR이란 용어는 `타자기`에서 부터 의미가 시작된다.\n\n타자를 입력할 때마다 종이가 오른쪽에서 왼쪽으로 움직이는데\n한 줄을 다 입력해서 오른쪽 끝에 다다르면 다음줄 + 맨 처음으로 이동해야한다.\n이때 2가지의 동작이 이뤄진다.\n\n1. 왼쪽 레버를 오른쪽으로 당겨서 종이의 맨 왼쪽으로 이동하고\n2. 다음줄로 넘어가기 위해 종이를 위로 올려서 세로 줄넘김을 한다.\n\n- `Carriage`란 종이를 고정해주는 롤처럼 생긴 장치다.\n- `Carriage Return`은 레버를 당겨서 종이를 맨 왼쪽으로 이동시키기는 것을 뜻한다.\n- `Line Feed`는 한줄만큼 종이를 위로 올려서 세로 줄넘김하는 것을 말한다.\n\n<br />\n\n### 1. CR `\\n`\n\nCarriage Return : 커서를 맨앞으로 이동 (가로)\n\n### 2. LF `\\r`\n\nLine Feed : 커서는 그대로인 상태에서 다음줄로 이동 (세로)\n\n### CRLF `\\r\\n`\n\nCarriage Return Line Feed : 커서 맨앞 이동 + 다음줄 이동\n\n- CR과 LF의 조합\n\n<br /><br />\n\n## 운영체제 별 개행\n\n코드 작성할 때 키보드 `엔터` 키를 누를때마다 개행문자라는 보이지 않는 문자가 삽입된다.\n그런데 운영체제마다 기본으로 채택하고 있는 line ending 개행문자(줄바꿈) 처리방식이 다르다.\n\n#### 1. Windows OS\n\n- 두가지를 조합한 CRLF `\\r\\n` 채택\n- 윈도우에서 LF 개행으로 된 파일을 읽을 때 깨짐 현상 발생\n  1. 줄바꿈 충돌로 글자가 붙여서 보여짐\n  2. 글자 제일 마지막에 특수문자 `^M` 이 출력됨\n\n#### 2. UNIX 및 MAC OS(9 버전 이후)\n\n- LF `\\n` 채택\n- MAC OS 9 이전 버전 (매킨토시:Machintosh) - CR 채택\n  원래 초창기 9버전 이전에는 CR를 사용했지만,\n  그 이후부터는 Unix와 일치하는 LF로 변경됐다.\n\n![241013-173706](/images/posts/crlf/241013-173706.png)\n\n> - 이스케이프 시퀀스란?\n>   프린트할 수 없지만 개념상 있는 문자 (예: 개행`\\n`, 탭`\\t`)\n\n<br/>\n- 자바스크립트에서 keyCode가 13이면 엔터를 의미하는데 이 아스키코드에서 나온 것이다.\n\n<br /><br />\n\n# 그러면 왜 지금은 개행방식이 나눠졌나?\n\n1963~1968년까지 ISO(국제표준화기구)에서는 개행문자로 CR+LF를 채택했다. 밑 사진의 텔레타이프라는 전신타자기에서 주로 사용됐다.\n\n그러다가 1964년 등장한 멀틱스 운영체제에서부터 개행문자를 LF만으로 채택하기 시작했다. 이는 컴퓨터가 막 등장하던 시기여서 메모리 비용이 비쌌기 때문에 바이트가 작은 LF만은 채택한 것이다.\nUnix와 리눅스도 멀틱스의 관례를 이어나가게 됐다.\n윈도우는 1981년 등장한 DOS 운영체제의 CR+LF 방식의 관례를 따르게 된 것이다.\n\n- [텔레타이프 (전신타자기)](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%8B%A0%ED%83%80%EC%9E%90%EA%B8%B0)\n  ![241013-173750](/images/posts/crlf/241013-173750.png)\n\n<br /><br /><br /><br />\n\n# Git에서의 줄 끝\n\nGit으로 개발자들과 협업하는데 윈도우와 맥을 혼용해서 코드를 올리고 있었다면,\n컴퓨터에서는 CRLF와 LF의 각 바이트 값이 다르기 떄문에 다르게 인식한다.\n그래서 형상관리 툴에서는 개행방식이 다르면 diff로 인식되어 서로 다른 코드라고 보게 된다.\n따라서 git commit할 때 실제 변경하지 않은 파일도 개행방식이 다른 것 때문에 변경된 것으로(CRLF에서 LF로 변환 또는 반대) 잘못 인식하게 된다.\n\n- 윈도우에서 `git add .` 시 밑과 같은 warning을 만나게 된다.\n\n```\nwarning: LF will be replaced by CRLF in 파일경로\nThe file will have its original line endings in your working directory\n```\n\n이는 커밋 내역, 코드 이력관리에 좋지 않으므로 설정이 필요하다.\n\n> 협업 시 개발자 간 사용중인 OS가 다를 경우 Git에서 예기치 않은 문제가 생길 수 있다.\n\n### [해결방법](https://docs.github.com/ko/get-started/getting-started-with-git/configuring-git-to-handle-line-endings?platform=mac)\n\n- Windows OS\n\n```bash\ngit config --global core.autocrlf true\n```\n\n1. Git에서 가져올 때 - Git LF -> Windows CRLF로 변경\n2. Git에 전송할 때 - Window CRLF -> Git LF로 변경\n\n- Mac OS\n\n```bash\ngit config --global core.autocrlf input\n```\n\n- [Prettier 참고](https://prettier.io/docs/en/options.html#end-of-line)\n\n<br /><br /><br /><br />\n\n#### VSCode 개행 확인\n\n- 윈도우 VSCode는 개행이 CRLF로 기본설정 되어 있다.\n  ![241013-173810](/images/posts/crlf/241013-173810.png)\n\n- 맥 VSCode는 개행이 LF로 기본설정 되어 있다.\n  ![241013-173817](/images/posts/crlf/241013-173817.png)\n\n<br /><br /><br /><br />\n\n# 참고\n\n- [Carriage return - wiki](https://en.wikipedia.org/wiki/Carriage_return#Computers)\n\n- [Why is the line terminator CR+LF? - Microsoft, Raymond Chen](https://devblogs.microsoft.com/oldnewthing/20040318-00/?p=40193)\n\n- https://www.aleksandrhovhannisyan.com/blog/crlf-vs-lf-normalizing-line-endings-in-git/\n\n- [개발 용어 : 캐리지 리턴(CR), 라인 피드 (LF) 알아보기](https://jw910911.tistory.com/90)\n\n- [LF와 CRLF의 차이 (Feat. Prettier)](https://velog.io/@jakeseo_me/LF와-CRLF의-차이-Feat.-Prettier)\n',
  },
  {
    slug: 'giscus',
    title: 'Next.js 블로그에 댓글기능 추가하기 - Giscus',
    content:
      "\n# 댓글 기능을 추가하자\n\n#### 댓글기능을 구현한 오픈소스들\n\n오픈소스를 사용해서 손쉽게 댓글기능을 추가할 수 있다.\n그 중 [giscus](https://giscus.app/ko)는 Github API를 사용하여 Discussions으로 불러오기 때문에 대댓글을 작성할 수 있고 시간순/인기순 정렬, 리액션 추가, 지연 로딩 등을 지원해줘서 해당 오픈소스를 선택했다.\n\n1. [giscus](https://giscus.app/ko) - Github Discussions 기능을 사용\n2. [utterances](https://utteranc.es/) - Github Issue 기능을 사용\n3. [disqus](https://disqus.com/)\n\n<br></br>\n\n# Setting\n\n1. Github 블로그 프로젝트 레포가 `Public`이어야 함\n2. [Discussions 기능 활성화](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/enabling-or-disabling-github-discussions-for-a-repository)\n\n- 레포 Settings - Features탭에 Discussions 체크\n  ![](https://velog.velcdn.com/images/xmun74/post/a9d1c359-10f6-4adb-b278-ef75eb261b45/image.png)\n\n3. 해당 레포에 [giscus 앱 설치](https://github.com/apps/giscus)\n4. [한글 공식문서](https://giscus.app/ko)따라 설정하기\n   설정 부분 보면서 원하는대로 config를 정하면 자동으로 `script` 태그를 생성해주는데 이 `script` 태그를 코드에 넣으면 된다.\n   ```html\n   <script\n     src=\"https://giscus.app/client.js\"\n     data-repo=\"[복붙]\"\n     data-repo-id=\"[복붙]\"\n     data-category=\"General\"\n     data-category-id=\"[복붙]\"\n     data-mapping=\"pathname\"\n     data-strict=\"0\"\n     data-reactions-enabled=\"1\"\n     data-emit-metadata=\"0\"\n     data-input-position=\"bottom\"\n     data-theme=\"preferred_color_scheme\"\n     data-lang=\"ko\"\n     data-loading=\"lazy\"\n     crossorigin=\"anonymous\"\n     async\n   ></script>\n   ```\n\n# 블로그에 적용한 코드\n\n- Next.js를 기반으로 `script`태그에 config 속성 적용한 코드\n\n  ```tsx\n  import { useRouter } from 'next/router'\n  import { useEffect, useRef, useState } from 'react'\n  import { useRecoilValue } from 'recoil'\n  import { getLocalStorage } from '../lib/localStorage'\n  import themeState from '../states/atoms/theme'\n\n  export default function Giscus() {\n    const refEl = useRef<HTMLDivElement>(null)\n    const router = useRouter()\n\n    function getInitTheme() {\n      if (typeof window !== 'undefined') {\n        const localTheme = getLocalStorage('theme')\n        if (localTheme) {\n          return localTheme\n        }\n        return 'light'\n      }\n      return 'light'\n    }\n    const theme = useRecoilValue(themeState) === 'dark' ? 'dark' : 'light' // 테마 토글버튼 클릭 시 변경하기\n\n    useEffect(() => {\n      const curTheme = getInitTheme() === 'dark' ? 'dark' : 'light' // 새로고침 시 저장된 테마 불러오기\n      if (!refEl.current || refEl.current.hasChildNodes()) return\n\n      const scriptEl = document.createElement('script')\n      scriptEl.src = 'https://giscus.app/client.js'\n      scriptEl.async = true\n      scriptEl.crossOrigin = 'anonymous'\n      scriptEl.setAttribute('data-repo', 'xmun74/xmunt')\n      scriptEl.setAttribute('data-repo-id', 'R_kgDOIwVyxg')\n      scriptEl.setAttribute('data-category', 'General')\n      scriptEl.setAttribute('data-category-id', 'DIC_kwDOIwVyxs4CUrIr')\n      scriptEl.setAttribute('data-mapping', 'pathname')\n      scriptEl.setAttribute('data-strict', '0')\n      scriptEl.setAttribute('data-reactions-enabled', '1')\n      scriptEl.setAttribute('data-emit-metadata', '0')\n      scriptEl.setAttribute('data-input-position', 'bottom')\n      scriptEl.setAttribute('data-theme', curTheme)\n      scriptEl.setAttribute('data-lang', 'en')\n      scriptEl.setAttribute('data-loading', 'lazy')\n\n      refEl.current.appendChild(scriptEl)\n    }, [])\n\n    useEffect(() => {\n      const iframe = document.querySelector<HTMLIFrameElement>(\n        'iframe.giscus-frame',\n      )\n      iframe?.contentWindow?.postMessage(\n        { giscus: { setConfig: { theme } } },\n        'https://giscus.app',\n      )\n    }, [theme])\n\n    return <section ref={refEl} />\n  }\n  ```\n\n- theme에 맞게 댓글테마도 변경해야해서 테마와 관련된 코드를 추가했다.\n  https://github.com/giscus/giscus/issues/336 를 참고하여 코드를 작성했다.\n\n#### 참고\n\nhttps://github.com/giscus/giscus/issues/336\n",
  },
  {
    slug: 'git-branch',
    title: 'Git 브랜치 전략',
    content:
      '\n# Git Flow\n\n깃 플로우는 2010년도 Vincent Driessen이 제안한 전략이다. 브랜치 전략을 검색하면 나오는 유명한 도식도도 밑 포스팅 하단 링크에 들어가면 확인할 수 있다.\n\n- [A successful Git branching model - Vincent Driessen이 제안한 브랜치 전략(2010년)](https://nvie.com/posts/a-successful-git-branching-model/)\n\n![241027-221924](/images/posts/git-branch/241027-221924.png)\n\n위 그림에 정의된 브랜치를 나열하면 밑처럼 구성되어 있다.\n\n1. `master(main)` : 배포된 프로덕션 브랜치\n2. `develop` : 다음 버전 개발 완료 후 main 브랜치로 머지\n3. features(`feature/branch-name`) : 기능 개발 후 develop 브랜치로 머지\n4. releases(`release/v1.1`)\n   : develop 브랜치에서 따와서 bugfix나 수정을 하고 배포 준비 테스트를 마치면 main, develop 브랜치에 머지\n5. hotfixes(`hotfix/v1.1`)\n   : 배포 후 문제 발생 시 main에서 가져와서 문제해결 후 main, develop 브랜치에 머지\n\n<br />\n\n#### 💁 누가 사용하는 것이 적합한가요?\n\n1. 안정적으로 관리 가능한 장기간의 릴리스 주기를 가진 팀\n2. 병렬적으로 다중 버전관리가 필요한 `앱, 라이브러리/프레임워크` 등에 적합할 수 있다.\n   - 이유\n     - **앱**을 사용자가 업데이트 안할 수도 있기 때문에 이전 버전도 지원해야 함\n     - **라이브러리/프레임워크**들은 특정 버전으로 설치가 가능함.\n       예) `npm -D react@^16.8.0 react-dom@16.8.0`\n\n> ### 웹 개발자들은 Git Flow가 복잡해요 🤯\n>\n> `웹 어플리케이션 개발자들은 ...`\n>\n> - 하루에 **여러 번 배포**하기도 하는데\n>   복잡한 git flow는 작업 속도를 늦추고, 다양한 브랜치를 관리하는데 복잡도가 증가한다는 단점이 있습니다. 이는 빠른 개발 사이클과 안맞기 때문입니다.\n>\n> - 병렬적으로 다중 버전관리가 아닌, **가장 최신의 단일 버전만을 관리**하면 되기 때문입니다.\n>   이에 대한 내용은 Vincent Driessen님의 [글 상단](https://nvie.com/posts/a-successful-git-branching-model/) `반성문`이라는 코멘트에서 확인할 수 있다.\n>   ![241027-221940](/images/posts/git-branch/241027-221940.png)\n\n---\n\n<br /><br />\n\n# [GitHub Flow](https://githubflow.github.io/)\n\n: main 브랜치와 함께 기능 브랜치로는 feature를 사용하는 전략\n\n1. `master(main)` : 배포되는 브랜치\n2. `features` : 기능 브랜치\n\n- 바로 밑에서 소개하는 TBD와 유사하지만, 차이점을 말해보자면 밑과 같은 내용이 있다.\n- GitHub에서의 브랜치는 장기간의 기능 브랜치라는 점에서 차이가 있다.\n- GitHub Flow는 기능이 완료된 이후에 머지 수행하지만, TBD는 하루에도 여러번 병합을 수행한다.\n- GitHub Flow는 기능 개발 주기가 긴 반면, TBD는 빠르면서 점진적인 개발 주기를 가져간다.\n\n<br /><br /><br /><br />\n\n---\n\n# [Trunk-based Development(TBD)](https://trunkbaseddevelopment.com/)\n\n: 모든 개발자가 `trunk(or main)` 단일 브랜치를 항상 배포 가능한 상태로 유지하는 방식.\n\n- 각 개발자들은 신규 기능을 바로 main에 작은 단위로 commit한다.\n- 브랜치를 사용하려면 작은 단위의 짧은 수명을 가진 feature 브랜치를 사용한다.\n- 빠른 릴리스가 가능\n- [Google](https://cloud.google.com/architecture/devops?hl=ko), Facebook 등 대규모 연속 배포, 고속 릴리스를 안정적으로 수행하는 대규모 서비스에서 사용하는 방식.\n\n> trunk(나무 줄기:주요코드)라는 명칭과 branch(나뭇가지:기능,변경사항)를 비유로 사용.\n\n![241027-221952](/images/posts/git-branch/241027-221952.png)\n\n#### 특징\n\n1. 짧은 수명(sort-lived)의 기능 브랜치\n   : 머지 지옥(충돌해결 문제)을 되도록 피하기 위해서 장기간의 브랜치를 사용하지 않는다. commit의 단위를 작게 가져가거나, 브랜치의 기간을 짧게 가져간다.\n2. 빠른 코드 리뷰, 페어 프로그래밍\n   : main에 바로 commit 해야되기 때문에 코드의 안정성과 품질이 보장되어야한다. 그래서 이를 위해서 페어 프로그래밍이나 코드리뷰 등의 과정이 필요하다.\n   페어 프로그래밍을 하면서 자연스럽게 코드 내용에 대해서 공유, 오류 검출 등의 작업을 하거나 아니면 빠른 코드리뷰를 통해서라도 코드 품질을 높이는 작업을 수행한다.\n3. 자동화 테스트 구축\n   : 마찬가지로 코드 안정성과 품질을 보장하기 위한 테스트 과정이 필요하다. 테스트를 통과했을 때 머지가 되도록 자동화 테스트가 구축되어야 한다.\n4. 소규모 CI/CD 자동화\n5. 큰 기능 개발의 경우는 Feature Toggles 사용\n   : 큰 단위의 신규 기능이어서 장기간 작업이 이뤄질 경우에 main에 푸시할 경우, 해당 기능은 아직 운영에 보이지 않게 비활성화해야하는 경우가 있다. 이런 경우는 아직 작업 진행중인 기능을 비활성화한 상태로 병합할 수 있도록 Feature Toggle를 사용한다. 또는 브랜치 추상화([Branch by abstraction](https://trunkbaseddevelopment.com/branch-by-abstraction/))를 활용한다.\n\n<br />\n\n#### [Feature Toggles(Feature Flags)](https://martinfowler.com/articles/feature-toggles.html)란?\n\n- 특정 기능을 배포 이후 비활성화 또는 활성화해서 토글할 수 있음.\n- 특정 기능을 특정 유저에게만 운영환경에서 테스트 가능하게 활성화할 수 있음.\n\n---\n\n<br /><br />\n\n## GitLab Flow\n\n: GitLab을 활용하여 Merge, CI/CD와 연관되고 다양한 환경에서의 배포에 초점이 맞춰진 전략 - [GitLab 참고](https://about.gitlab.com/blog/2023/07/27/gitlab-flow-duo/)\n\n1. `master(main)`\n   : feature가 완료되어 pr을 받고 production에 나가는 브랜치(이전 develop과 동일)\n2. `feature` : master에서 파생되고 머지\n3. `pre-production`\n   : master와 production 사이의 단계로 테스트 서버에 배포해서 테스트하는 브랜치\n4. `production` : 배포 브랜치\n\n---\n\n<br /><br /><br /><br />\n\n# 참고\n\n- https://trunkbaseddevelopment.com/\n- [A successful Git branching model - Vincent Driessen](https://nvie.com/posts/a-successful-git-branching-model/)\n',
  },
  {
    slug: 'github-actions-be-01',
    title: 'Github Actions - 백엔드 CI/CD 구축하기',
    content:
      "\n## 도입 배경\n\n#### [문제] 프리티어 EC2 인스턴스에서 서버 빌드가 너무 오래 걸린다.\n\n![](https://velog.velcdn.com/images/xmun74/post/62f62e8b-b94b-4c90-b403-c76f1bca95f3/image.png)\nnodeJS, express, Typescript로 백엔드를 만들어서 인스턴스 내에서 빌드하는 과정이 있었습니다. 그런데 EC2 인스턴스에서 `yarn tsc` 빌드 명령어를 수행하면 30분 이상 그냥 저대로 멈춰있었습니다.\n계속 저 상태로 놔두면 인스턴스 상태검사(연결성 검사)에서 통과되지 않는 상황으로 바뀌기도 했습니다. 상태검사가 통과가 안되는 상태로 바뀌면 EC2 인스턴스 콘솔과 SSH 클라이언트에서 접속이 불가해지는 문제로 이어졌습니다. 그래서 상태검사를 통과시키기 위해 인스턴스 중지했다가 다시 시작해야 했습니다.\n\n#### [원인] 프리티어 t2.micro 인스턴스 메모리 부족\n\n프리티어로 사용중이던 t2.micro 인스턴스는 1G 메모리밖에 안돼서 서버 빌드가 중단되거나 오래 걸린다고 합니다. 인스턴스 유형을 바꾸고 돈을 더 내면 간단한 문제지만, 개인 프로젝트였기 때문에 프리티어 계정을 사용하여 무료로 이용해야 한다는 제한을 두고 진행해야했습니다.\n\n#### [해결 방법]\n\n1. [스왑 파일로 디스크의 RAM을 임시 메모리로 끌어와 사용하는 것](https://repost.aws/ko/knowledge-center/ec2-memory-swap-file)\n   단점\n   - 스왑 공간은 디스크에 위치하기 때문에 RAM에 비해 느린 HDD을 사용하게 되어 I/O 속도가 느려져서 서버 성능이 저하될 수 있음\n2. 인스턴스 외 환경에서 빌드, 배포하기 (CI/CD)\n\n1번 방법은 서버 성능 저하와 메모리 관리 복잡성이 증가한다는 단점이 존재하기때문에 현재 상황에서는 2번인 인스턴스 외 환경에서 빌드/배포하는 방법을 선택했습니다.\n원래는 CI/CD를 빌드/배포 자동화의 도구라고만 생각했었는데 위 배경처럼 메모리가 부족한 문제 상황에서 해결 방법으로 선택할 수 있음을 다시 배울 수 있었습니다.\n<br /><br />\nCI/CD로는 Github Actions, 젠킨스 등이 있습니다. Github Actions는 무료 계정으로 현재 월 2000분, 500MB까지 무료로 사용할 수 있다고 합니다. ([GitHub Actions 청구 정보](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#included-storage-and-minutes))\n그래서 Github Actions를 사용해서 구축해보았습니다.\n\n<br /><br /><br /><br />\n\n---\n\n<br />\n\n# Github Action 흐름\n\n> Github에 PUSH(트리거) - Build - Test - Deploy\n\n제 NodeJS 백엔드는 Test가 없기 때문에 일단 크게 Build와 Deploy의 흐름으로 작성했습니다.\n시작하기에 앞서 루트에 `.github/workflows` 폴더 생성 후 `파일명.yml`파일을 생성합니다.\n\n#### 진행 과정\n\n1. Github 특정 브랜치에 Push하면\n2. 빌드한 다음 빌드된 결과물을 압축\n3. 압축된 빌드 결과물을 EC2 인스턴스에 전송\n4. 배포 과정을 담은 sell script 실행\n\n## 1. Github 특정 브랜치에 PUSH하면\n\n```yml\nname: CI-CD-server\n\non:\n  push:\n    branches:\n      - master\n```\n\n- `on` : `jobs`이 실행될 상황 정의.\n  master 브랜치에 push할 때 jobs를 실행하게 했습니다.\n\n## 2. 빌드한 다음 빌드된 결과물을 압축\n\n```yml\njobs:\n  build-and-deploy-server:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [18.x]\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: ⎔ Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: ⎔ Install packages\n        run: yarn\n```\n\n- `jobs` - 실행될 작업 내용을 작성.\n\n1. `actions/checkout@v3`\n   Runner(workflow 실행환경)가 현재 Github 저장소 소스코드에 체크아웃됩니다.\n2. `⎔ Use Node.js ${{ matrix.node-version }}`\n   인스턴스와 동일한 node 버전(18.x)으로 적용합니다.\n3. `⎔ Install packages`\n   yarn 명령어로 패키지들 설치합니다.\n\n```yml\n\t  - name: ⎔ Build server\n        env:\n          COOKIE_SECRET: ${{ secrets.COOKIE_SECRET}}\n          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME}}\n          MYSQL_PWD: ${{ secrets.MYSQL_PWD}}\n          MYSQL_HOST: ${{ secrets.MYSQL_HOST}}\n          PORT: ${{ secrets.PORT}}\n          KAKAO_ID: ${{ secrets.KAKAO_ID}}\n          FRONTEND_URL: ${{ secrets.FRONTEND_URL}}\n          REDIS_HOST: ${{ secrets.REDIS_HOST}}\n          REDIS_PORT: ${{ secrets.REDIS_PORT}}\n          REDIS_PWD: ${{ secrets.REDIS_PWD}}\n        run: |\n          yarn build\n\n      - name: ⎔ Package dist Folder\n        run: tar -czvf dist.tar.gz dist\n```\n\n4. `⎔ Build server`\n   env 환경변수들을 가져오고 빌드하기\n5. `⎔ Package dist Folder`\n   빌드한 dist 폴더를 tar 파일로 압축하기\n\n## 3. 압축된 빌드 결과물을 EC2 인스턴스에 전송\n\n```yml\n- name: ⎔ Deploy to Amazon ECS\n  uses: appleboy/scp-action@master\n  with:\n    host: ${{ secrets.EC2_IP }}\n    username: ${{ secrets.EC2_USER }}\n    key: ${{ secrets.EC2_PEM_KEY }}\n    source: 'dist.tar.gz'\n    target: ${{ secrets.SERVER_PATH }}\n```\n\n#### [appleboy/scp-action@master](https://github.com/appleboy/scp-action)\n\n: GitHub Actions에서 사용되는 SCP(Secure Copy Protocol)를 이용한 파일 전송 액션입니다. 이는 workflow가 실행된 후에 생성된 파일들을 다른 서버로 안전하게 복사하는 데 사용합니다.\n\n- 액션에 전달할 값 (유출하면 안됨)\n  - host: EC2 퍼블릿 IP 주소\n  - username: EC2 인스턴스 접속위한 사용자명\n  - key: 인스턴스 생성할 때 다운받은 pem key\n  - source: 복사할 파일. 빌드폴더를 압축한 파일을 적었습니다.\n  - target: 복사한 파일이 전송될 서버 내 경로.\n\n#### Github에 secrets 등록하기\n\n1. GitHub 레포에서 Settings > Secrets > `New repository secret` 클릭\n2. `Name` 필드에 지정할 이름(예:EC2_KEY)을 입력하고,\n   `Value` 필드에 복사한 키 내용을 붙여넣기\n3. `Add secret` 클릭하여 저장\n\n#### pem 파일 로컬에서 여는 방법\n\n1. 로컬 터미널에서 해당 pem파일이 위치하는 폴더로 가서\n2. `cat 파일명.pem` 입력\n3. (-----BEGIN RSA PRIVATE KEY----- 로 시작하여 -----END RSA PRIVATE KEY----- 로 끝나는 부분) 전체를 복사\n4. GitHub Secrets에 등록하기\n\n## 4. 배포 과정을 담은 sell script 실행\n\n```yml\n- name: ⎔ Execute shell script\n  uses: appleboy/ssh-action@master\n  with:\n    host: ${{ secrets.EC2_IP }}\n    username: ${{ secrets.EC2_USER }}\n    key: ${{ secrets.EC2_PEM_KEY }}\n    script: |\n      cd ${{ secrets.SERVER_PATH }}\n      sudo tar -xzvf dist.tar.gz\n      git pull origin 브랜치명\n      yarn\n      pm2 kill\n      pm2 start dist/index.js\n```\n\n#### [appleboy/ssh-action@master](https://github.com/appleboy/ssh-action)\n\n: SSH(Secure Shell: 원격 컴퓨터를 안전하게 제어하고 전송하기 위한 프로토콜)를 통해 원격 서버에 접속하여 명령어를 실행하는 액션.\n\n- host, username, key는 scp와 똑같이 입력했습니다.\n- script\n  평소 코드를 push하고 인스턴스에서 반복 작업하던 명령어들을 script에 작성합니다. 여기서 위에서 압축했던 파일을 압축해제하는 코드를 추가합니다.\n  ```bash\n  cd 프로젝트폴더\n  sudo tar -xzvf dist.tar.gz  #빌드폴더 파일압축 해제\n  git pull origin 브랜치명\n  yarn\n  pm2 kill  #실행중이던 pm2 종료\n  pm2 start dist/index.js   #pm2 실행하기\n  ```\n\n---\n\n## 전체 코드\n\n```yml\nname: CI-CD-server\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build-and-deploy-server:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [18.x]\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: ⎔ Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: ⎔ Install packages\n        run: yarn\n\n      - name: ⎔ Build server\n        env:\n          COOKIE_SECRET: ${{ secrets.COOKIE_SECRET}}\n          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME}}\n          MYSQL_PWD: ${{ secrets.MYSQL_PWD}}\n          MYSQL_HOST: ${{ secrets.MYSQL_HOST}}\n          PORT: ${{ secrets.PORT}}\n          KAKAO_ID: ${{ secrets.KAKAO_ID}}\n          FRONTEND_URL: ${{ secrets.FRONTEND_URL}}\n          REDIS_HOST: ${{ secrets.REDIS_HOST}}\n          REDIS_PORT: ${{ secrets.REDIS_PORT}}\n          REDIS_PWD: ${{ secrets.REDIS_PWD}}\n        run: |\n          yarn build\n\n      - name: ⎔ Package dist Folder\n        run: tar -czvf dist.tar.gz dist\n\n      - name: ⎔ Deploy to Amazon ECS\n        uses: appleboy/scp-action@master\n        with:\n          host: ${{ secrets.EC2_IP }}\n          username: ${{ secrets.EC2_USER }}\n          key: ${{ secrets.EC2_PEM_KEY }}\n          source: 'dist.tar.gz'\n          target: ${{ secrets.SERVER_PATH }}\n\n      - name: ⎔ Execute shell script\n        uses: appleboy/ssh-action@master\n        with:\n          host: ${{ secrets.EC2_IP }}\n          username: ${{ secrets.EC2_USER }}\n          key: ${{ secrets.EC2_PEM_KEY }}\n          script: |\n            cd ${{ secrets.SERVER_PATH }}\n            sudo tar -xzvf dist.tar.gz\n            git pull origin 브랜치명\n            yarn\n            pm2 kill\n            pm2 start dist/index.js\n```\n\n- Github에 push 후, CI/CD가 잘 작동하는 것을 확인할 수 있었습니다.\n  ![](https://velog.velcdn.com/images/xmun74/post/660cd926-c776-4ef7-8081-ee4cc8557032/image.png)\n\n<br /><br />\n\n---\n\n<br /><br /><br /><br /><br />\n\n참고\n\n- [zero-black 벨로그 - [github-actions] 리액트 빌드하기](https://velog.io/@zero-black/github-actions-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0)\n- [oscar0421 벨로그 -[github action] 빌드부터 배포까지!](https://velog.io/@oscar0421/github-action-%EB%B9%8C%EB%93%9C%EB%B6%80%ED%84%B0-%EB%B0%B0%ED%8F%AC%EA%B9%8C%EC%A7%80#workflow-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0)\n",
  },
  {
    slug: 'github-actions-fe-01',
    title: 'Github Actions - 프론트엔드 CI/CD 구축하기 (S3, CloudFront)',
    content:
      '\n# IAM\n\nIAM(Identity and Access Management)\n: 외부에서 AWS 리소스에 대한 액세스 권한을 안전하게 제어하는 서비스\n\n- 예시\n  - Github Actions에서 S3에 접근할 때.\n  - NodeJS에서 S3에 이미지 업로드하기 위해서 S3에 접근할 때\n\n---\n\n# 1. IAM 사용자 생성하기\n\nGithub Actions에서 S3에 업로드하고 CloudFront의 캐시를 무효화하기 위해서 IAM 사용자를 사용하여 접근해보겠습니다.\n\n- IAM - 사용자 메뉴 - 사용자 생성\n  ![](https://velog.velcdn.com/images/xmun74/post/af81dce3-b0ba-4ff2-978e-cd90feebb2de/image.png)\n- 사용자 이름 입력\n  ![](https://velog.velcdn.com/images/xmun74/post/3bce27ab-0ad6-4784-90bb-580d58ff895b/image.png)\n- 직접 정책 연결 체크 후\n  `AmazonS3FullAccess`와 `CloudFrontFullAccess` 체크.\n  Github Actions에서 S3와 CloudFront에 접근할 것이기에 위에 2개를 체크해줬다.\n  ![](https://velog.velcdn.com/images/xmun74/post/a5748d37-d2d8-4374-aaba-8a8b10a0bf21/image.png)\n  ![](https://velog.velcdn.com/images/xmun74/post/948ecdfd-49dc-4905-9a2d-9525edc5d41e/image.png)\n- 검토 후 사용자 생성\n  ![](https://velog.velcdn.com/images/xmun74/post/62162fb4-96b0-49fd-999c-d7d2342b9cf5/image.png)\n- 생성된 사용자 이름 클릭\n  ![](https://velog.velcdn.com/images/xmun74/post/a322554a-2a01-4be6-935b-3ebbee72a87c/image.png)\n- 보안 자격 증명 탭 - 액세스 키 만들기\n  : 외부에서 사용할 수 있게 액세스 키를 생성한다.\n  ![](https://velog.velcdn.com/images/xmun74/post/71f79d3d-c8d2-4e4b-8ab7-20a30f36f060/image.png)\n- 사용 사례 - 서드 파티 (깃헙 등)\n  ![](https://velog.velcdn.com/images/xmun74/post/65c2955f-aa20-4a12-96b8-2e4ea98a4b8d/image.png)\n- 설명 태그 설정 - 설정하고 - 액세스 키 만들기\n  ![](https://velog.velcdn.com/images/xmun74/post/40ebafd2-3611-418f-aa58-6326643e4fcf/image.png)\n- 액세스 키 생성됨\n  🚨 이 페이지에서 바로 나가지 말고 깃헙 secrets에 등록하기\n  페이지를 나가면 다시 액세스 키를 보거나 다운받을 수 없습니다!\n  이 키는 절대 외부로 유출하면 안되기 때문에 Github Secret에 등록하여 깃헙에 올라가지 않게 합니다.\n  ![](https://velog.velcdn.com/images/xmun74/post/456d57cd-92aa-4f84-9165-8dd045e13aa1/image.png)\n- ✅[필수] 깃헙 레포 - Settings > Actions > New ~ secret 해서 등록하기\n  ![](https://velog.velcdn.com/images/xmun74/post/f767e337-a5ab-4469-b491-b7318aa063a3/image.png)\n\n---\n\n# 2. Github Actions CI/CD 작성\n\n#### jobs 진행 과정\n\n1. NodeJS 세팅\n2. yarn install\n3. build 하기\n4. AWS 인증 정보 설정\n5. AWS S3에 배포하기\n6. [AWS CloudFront 캐시 무효화](https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html)\n\n```yml\nname: CI-CD-biblical-web\n\non:\n  push:\n    branches:\n      - master\n    paths:\n      - \'apps/web/**\'\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [18.x]\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: ⎔ Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: ⎔ Monorepo install\n        uses: ./.github/actions/yarn-install\n\n      - name: ⎔ Build web\n        working-directory: apps/web\n        env:\n          API_URL: ${{ secrets.API_URL}}\n          USER_IMG_FIELD: ${{ secrets.USER_IMG_FIELD}}\n          CLIENT_URL: ${{ secrets.CLIENT_URL}}\n        run: |\n          yarn build\n\n      - name: ⎔ Configure AWS credentials\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          aws-access-key-id: ${{ secrets.AWS_KEY_ID }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}\n          aws-region: ap-northeast-2\n\n      - name: ⎔ Deploy to AWS S3\n        run: |\n          aws s3 sync --delete --region ap-northeast-2 apps/web/dist s3://S3버킷명\n\n      - name: ⎔ Invalidate AWS CloudFront Cache\n        run: |\n          aws cloudfront create-invalidation --distribution-id ${{ secrets.AWS_DISTRIBUTION_ID }} --paths "/*"\n```\n\n#### AWS S3에 배포하기\n\n`aws s3 sync --delete --region ap-northeast-2 apps/web/dist s3://버킷명`\n\n- sync : S3 버킷과 로컬폴더 간 동기화하기\n- --delete : 로컬에서 삭제된 파일은 S3 버킷에서도 삭제된다\n- --region ap-northeast-2 : 리전을 서울로 지정\n- apps/web/dist : 빌드폴더 경로\n  <br />\n\n#### AWS CloudFront 캐시 무효화\n\n`aws cloudfront create-invalidation --distribution-id ${{ secrets.AWS_DISTRIBUTION_ID }} --paths "/*"`\n\n- --paths "/\\*" : 모든 파일에 대한 캐시 무효화\n- 캐시 무효화하는 이유\n  : CloudFront의 캐시 정책을 `CachingOptimized`로 선택한 경우,\n  캐시 유지시간이 기본 TTL 24시간으로 설정되어 있다. 따라서 S3 버킷을 재업로드 후 변경된 사항을 배포된 cloudfront에서 바로 확인하고 싶다면 캐시 무효화를 해줘야 한다.\n- 참고로 캐시 객체 무효화는 매월 1000개 경로까지 무료이고 그 이상부터 경로당 0.005 USD 비용이 발생한다. ([CloudFront 비용](https://aws.amazon.com/ko/cloudfront/pricing/))\n\n<br /><br /><br /><br /><br />\n',
  },
  {
    slug: 'google-analytics',
    title: 'NextJS 블로그에 Google Analytics 추가하기',
    content:
      "\n# [Google Analytics](https://analytics.google.com/analytics)\n\n구글에서 무료로 제공하는 도구로 사이트에 들어오는 사용자 유입, 조회수, 사용자 유형 등을 분석하여 통계를 내준다\n\n1. 관리 - 데이터스트림 - 스트림 추가 - 내사이트 입력\n2. 태그 안내보기 - `직접 설치`\n3. 파일 설정 - [NextJS 예시](https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics/pages/_app.js)\n\n- 공식예시가 gtag.js여서 ts 타입 정의를 위해 설치\n\n  ```bash\n  npm i -D @types/gtag.js\n  ```\n\n- `lib/gtag.tsx` 생성\n\n```tsx:lib/gtag.tsx showLineNumbers\nimport { useRouter } from 'next/router'\nimport { useEffect } from 'react'\n\nexport const GA_TRACKING_ID = `G-로 시작하는 id복붙`\n\n// https://developers.google.com/analytics/devguides/collection/gtagjs/pages\nexport const pageview = (url: URL) => {\n  window.gtag('config', GA_TRACKING_ID, {\n    page_path: url,\n  })\n}\n\n// https://developers.google.com/analytics/devguides/collection/gtagjs/events\nexport const event = (\n  action: Gtag.EventNames,\n  { event_category, event_label, value }: Gtag.EventParams,\n) => {\n  window.gtag('event', action, {\n    event_category,\n    event_label,\n    value,\n  })\n}\n\n// page view\nexport const useGtag = () => {\n  const router = useRouter()\n  useEffect(() => {\n    const handleRouteChange = (url: URL) => {\n      pageview(url)\n    }\n    router.events.on('routeChangeComplete', handleRouteChange)\n    router.events.on('hashChangeComplete', handleRouteChange)\n    return () => {\n      router.events.off('routeChangeComplete', handleRouteChange)\n      router.events.off('hashChangeComplete', handleRouteChange)\n    }\n  }, [router.events])\n}\n```\n\n- `_app.tsx`에 추가하기\n\n```tsx:_app.tsx showLineNumbers\nimport Script from 'next/script'\nimport * as gtag from '../lib/gtag'\nimport isDev from '../lib/isDev'\n// 생략\nexport default function App({ Component, pageProps }: AppProps) {\n  gtag.useGtag()\n\n  return (\n    <RecoilRoot>\n      {/* 생략 */}\n      {!isDev && (\n        <>\n          <Script\n            id=\"gtag-init\"\n            dangerouslySetInnerHTML={{\n              __html: `\n                window.dataLayer = window.dataLayer || [];\n                function gtag(){dataLayer.push(arguments);}\n                gtag('js', new Date());\n                gtag('config', '${gtag.GA_TRACKING_ID}', {\n                  page_path: window.location.pathname,\n                });\n              `,\n            }}\n          />\n          {/* Global Site Tag (gtag.js) - Google Analytics */}\n          <Script\n            strategy=\"afterInteractive\"\n            src={`https://www.googletagmanager.com/gtag/js?id=${gtag.GA_TRACKING_ID}`}\n          />\n        </>\n      )}\n\n      {/* 생략 */}\n      <Component {...pageProps} />\n    </RecoilRoot>\n  )\n}\n\n```\n\n- `{!isDev && ( ... ) }` 배포 모드일때만 해당 script를 추가하게 함\n- 배포 후 사이트 html Elements탭에서 `id=\"gtag-init\"`으로 검색해서 잘 추가됐는지 확인하기\n- 구글 애널리틱스에 표시되기까지 24-48시간 정도 걸린다고 한다..\n\n## 실시간 사용자 수 보기\n\n- [Google Analytics](https://analytics.google.com/analytics)에 왼쪽 탭에서 `보고서` 클릭 - `실시간` 클릭\n  밑처럼 실시간 사용자 수를 분석한 통계를 볼 수 있다!\n  ![230316-132736](/images/posts/google-analytics/230316-132736.png)\n\n# Google Search Console과 연결\n\n구글에서 검색해서 들어온 통계를 보기 위해서 연결하기\n\n- 관리자 - Search Console 링크 - 연결\n  ![230309-161524](/images/posts/google-analytics/230309-161524.png)\n\n#### 구글 콘솔에서 사이트 통계보기\n\n- [구글 콘솔](https://search.google.com/search-console) - 개요 - 오른쪽 상단 `Search Console Insights` 클릭\n\n---\n\n#### 참고\n\n- [nextjs예시](https://github.com/vercel/next.js/tree/canary/examples/with-google-analytics)\n- https://kimyanglogging.tistory.com/3\n- https://velog.io/@yunsungyang-omc/Next.js-Google-Analystics-%EC%9D%B4%EC%8B%9D%ED%95%98%EA%B8%B0\n",
  },
  {
    slug: 'module-federation-01',
    title: 'Module Federation이란?',
    content:
      "\n## 들어가며\n\n모듈 페더레이션이라는 키워드가 왜 등장했는지 그 배경을 잠시 알아보겠습니다. 먼저 모듈 페더레이션은 결국 MFE 마이크로 프론트엔드를 구현하기 위한 방식들 중 하나입니다. 그러기에 앞서 MFE가 무엇인지 간단하게 살펴보겠습니다.\n<br />\n\n## MFE(Micro-Frontend) 등장\n\nThoughtWorks Technology Radar(기술 트렌드 조사 사이트)를 살펴보면 대략 2016년도부터 '마이크로 프론트엔드' 아키텍쳐에 대한 개념이 알려지기 시작하면서 이 아키텍쳐를 적용하려는 시도가 늘어났습니다.\n이 개념이 발전하게된 과정을 살펴보면,\n먼저 기존에 사용했던 `모놀리식`(한 패키지 안 여러 개의 서비스) 아키텍쳐의 단점으로 서비스 확장의 어려움, 서비스 별 배포가 어려움, 긴 빌드시간 등에 대한 해결책으로 `마이크로서비스` 아키텍쳐가 등장했는데 이 원칙을 프론트엔드 진영에 적용한 것이 `MFE(Micro-Frontend)`입니다.\n<br />\n\n물론 무조건 마이크로서비스 아키텍쳐가 정답이라는 말은 아닙니다. [마이크로서비스 한계점에 대한 글](https://news.hada.io/topic?id=7839)을 참고하여 서비스 규모나 비용과 생산성 간 트레이드오프 등을 따져보며, 정말 우리 서비스에 맞는지 검토한 후에 도입하는 것이 적절합니다.\n<br />\n\nMFE를 간단히 설명하자면 한 패키지에 묶여있던 거대한 서비스를 마이크로 서비스로 쪼개서 `독립적으로 배포`하고, 쪼개진 서비스를 `통합`할 수 있어야 한다. 예를 들면 밑처럼 모노레포를 사용하여 카드추천, 비대면 계좌개설, 부동산 등의 서비스로 쪼개는 것을 살펴볼 수 있습니다.\n\n- [자료 참고](https://speakerdeck.com/raon0211/toseuyi-maikeuropeuronteuendeu-akitegceo-geurigo-jadonghwa?slide=37)\n  ![](https://velog.velcdn.com/images/xmun74/post/ab6b86fe-51d9-4bc2-8652-d8840b19222a/image.png)\n  <br />\n\n그렇다면 밑의 그림처럼 분리된 여러 개의 서비스들이 독립적인 CI/CD를 진행하고 하나의 웹 페이지로 조립해야하는 통합 과정이 필요합니다.\n\n- [그림 참고](https://martinfowler.com/articles/micro-frontends.html)\n  ![](https://velog.velcdn.com/images/xmun74/post/ecd52c29-6fe2-4d06-87a6-61f18a60ca93/image.png)\n\n<br /><br />\n\n## 통합 방식\n\n[마틴 파울러 사이트의 글](https://martinfowler.com/articles/micro-frontends.html#IntegrationApproaches)에서 소개된 방식들을 간단히 살펴보겠습니다. 방식에 대한 자세한 내용은 해당 글을 참고하시고, 이 외에도 여러 방식이 존재합니다. 나눠진 코드 조각들을 하나로 통합하는 방식들입니다.\n그 중 JavaScript를 통한 런타임 통합 방식으로 Moduel Federation이 있습니다.\n<br />\n\n1. 서버 측 템플릿 구성\n2. 빌드 타임 통합\n3. iframe을 통한 런타임 통합\n4. JavaScript를 통한 런타임 통합\n   - 직접 구현하기\n   - Sigle-SPA 라이브러리\n   - Module Federation\n5. 웹 컴포넌트를 통한 런타임 통합\n\n<br />\n\n위 방식 중에서 JavaScript를 통한 런타임 통합으로 Module Federation에 대한 구현은 밑과 같은 방식들이 있습니다.\n\n<br />\n\n- Webpack5의 [ModuleFederationPlugin](https://webpack.kr/plugins/module-federation-plugin/)\n  : Webpack5부터 내장된 모듈 페더레이션 플러그인입니다.\n- [vite-plugin-federation](https://github.com/originjs/vite-plugin-federation)\n  : 모듈 페더레이션을 지원하는 Vite/Rollup 플러그인으로, Webpack에서 영감을 받았고 Webpack Module Federation과 호환이 됩니다.\n\n<br /><br />\n\n# Module Federation\n\n: `런타임에 통합`되어 각 앱이 서로 `코드를 공유`하는 기능입니다.\n\n`다른 애플리케이션의 코드`를 `런타임`에 가져와서 `동적 로드`할 수 있는 플러그인입니다. 양뱡향으로 모듈 페더레이션이 가능하기 때문에 A 앱에서 B 앱의 코드를 불러올 수 있고 이 반대 상황도 가능합니다.\n2020년 10월에 릴리즈된 Webpack5부터 추가된 내장 기능으로 처음 소개됐습니다. 넷플릭스나 아마존, AWS 등 해외 대기업에서도 사용하고 있다고 합니다.\n<br />\n\n#### Q, 왜 런타임에 하나?\n\n빌드 타임에서 통합한다면, 만약 A 애플리케이션 모듈이 수정될 때 이를 사용하던 다른 B,C 애플리케이션도 다시 빌드/배포해야해서 마이크로 프론트엔드의 장점인 독립적 배포가 어려워집니다.\n런타임에 통합하면, A 애플리케이션 모듈이 업데이트되면 이 코드를 사용하던 B 애플리케이션을 배포 안해도 A 코드의 변경사항이 실시간으로 반영됩니다. 따라서 런타임에 각 서비스가 개별적으로 배포해서 동적으로 로딩할 수 있게 됩니다.\n<br /><br />\n\n### 주요 용어 정리\n\n- 모듈 : Webpack으로 번들링 가능한 리소스 (JS, CSS, HTML, JSON, Asset ..)\n\n1. Host - 하나로 통합된 컨테이너.\n2. Remote - Host로 통합될 모듈.\n   다른 애플리케이션에서 사용하도록 노출(expose)해야 한다.\n3. Local - 현재 애플리케이션 내 단일 빌드에 포함되는 일반적인 모듈\n4. Exposes - 원격 모듈로 노출할 부분 지정.\n   expose하면 Host가 원격 모듈의 코드를 사용할 수 있게 된다.\n5. Container - 다른 애플리케이션에서 로드 가능한 단위\n   ![](https://velog.velcdn.com/images/xmun74/post/95ba106b-f474-4edd-af1b-4bf5a7921b22/image.png)\n\n<br /><br />\n\n## 간단한 코드 예시\n\n### 1. 원격에서 Webpack 설정하기\n\n예를 들어 app1 애플리케이션의 Header.js를 공유하려고 expose하는 경우입니다.\n\n- `name`은 모듈 페더레이션을 수행하는 앱 간 유일한 container 이름이어야 합니다.\n- `filename`은 해당 앱에 대한 정보를 담는 Manifest 파일명을 지정하는 옵션으로 기본값이 remoteEntry.js입니다.\n- `exposes`는 노출할 모듈들을 정의합니다. value 경로에 위치한 로컬 모듈을 key 경로의 원격 모듈로 expose합니다.\n\n```js\n// 원격a-services/webpack.config.js\nconst { ModuleFederationPlugin } = require('webpack').container\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1', // 원격 모듈 이름 - 중복 불가\n      filename: 'remoteEntry.js',\n      exposes: {\n        // 원격 모듈에서 공유할 항목\n        // `./Header` path로 `./src/components/Header.tsx`의 로컬 모듈을 expose함\n        './Header': './src/components/Header.js',\n      },\n    }),\n    // 번들링할 때 remoteEntry.js 파일 생성\n  ],\n}\n```\n\n### 2. 호스트에서 Webpack 설정하기\n\n- `remotes` - 사용할 원격 모듈 목록\n\n```js\nnew ModuleFederationPlugin({\n    name: 'app2', // 호스트 이름\n    remotes: {\n       app1: 'app1@http://localhost:3001/remoteEntry.js',\n    },\n}),\n```\n\n- 호스트에서 원격 모듈 import해서 사용하기\n\n```jsx\nimport 구현체 from '{container 원격 모듈 이름}/{exposes의 key 값}'\n// Static import\nimport Header from 'app1/Header'\n// Dynamic import\nconst Header = React.lazy(() => import('app1/Header'))\n```\n\n### 3. 공유 모듈 설정하기\n\n- 호스트나 원격 모듈 전부 공통적으로 사용하는 공유 모듈이 있다면 이를 설정하여 런타임에 1번만 로딩하게 하는 설정입니다. 이로 인해 요청 횟수가 줄어들게 됩니다.\n- [SharedConfig](https://github.com/webpack/webpack/blob/1f99ad6367f2b8a6ef17cce0e058f7a67fb7db18/declarations/plugins/sharing/SharePlugin.d.ts#L41)를 보면 다양한 옵션들이 있습니다.\n\n```js\nnew ModuleFederationPlugin({\n  shared: {\n    ...deps,\n    react: {\n      sigleton: true,\n      requiredVersion: '^18.0.0',\n    },\n  },\n})\n```\n\n<br /><br />\n\n---\n\n# 마치며\n\nMFE는 복잡도가 높기 때문에 대규모 서비스에서 서비스 특성에 따라서 확실한 장점이 있을 때 도입하는 것이 맞다고 생각했습니다.\n다른 발표 자료들을 찾아볼 때 사용하는 기술, 의사결정 등 사용하는 예시마다 적용하고 선택하는 방식이 다 달라서 완벽한 best practice는 없다고 느껴졌습니다.\n그리고 추가로 [module-federation-examples](https://github.com/module-federation/module-federation-examples) 깃헙에서 SSR, 양방향 호스트 등 다양한 예제들을 소개하고 있으니 참고하면 됩니다.\n\n<br /><br /><br /><br />\n\n참고\n\n- [Micro Frontends - Martin Fowler 사이트](https://martinfowler.com/articles/micro-frontends.html)\n- [Module Federation - Webpack 공식문서](https://webpack.js.org/concepts/module-federation/)\n- https://github.com/module-federation/module-federation-examples\n- [Webpack 5 Module Federation으로 Micro-Frontends 운영하기 - FEConf 유튜브](https://www.youtube.com/watch?v=0Eq6evGKJ68)\n- [[SaaS] Micro Frontends를 위해 Module Federation 적용하기 - 강남언니 블로그](https://blog.gangnamunni.com/post/saas-microfrontends/)\n",
  },
  {
    slug: 'nextjs-infinite-scroll-two',
    title: '무한스크롤 구현에서 뒤로가기 시 스크롤 유지를 해보자',
    content:
      "\n# 뒤로가기 시 이전 스크롤 위치로 복구하기\n\n무한 스크롤로 많은 목록들을 스크롤해서 내렸다가\n1개 글을 클릭한 후\n뒤로가기를 눌렀는데 맨 위로 되돌아가졌다.\n아까 그 위치로 계~속 스크롤해서 내려가자니 여간 불편한 게 아니다...\n이러한 사용자 경험을 향상시키기 위해 이전 스크롤 위치를 기억해서 복구할 필요가 있다!\n\n### 구현할 것\n\n- 경로 변경 전(글 목록 -> 글 상세)에 스크롤위치 저장하기\n- 뒤로가기를 해서 해당 경로에 왔는 지 체크\n- 뒤로가기로 왔으면 저장했던 스크롤위치로 복구\n\n### 구현 코드\n\n```tsx:useScrollRestoration.tsx\nimport { useRouter } from 'next/router'\nimport { useEffect } from 'react'\nimport {\n  getSessionStorage,\n  removeWebStorage,\n  setSessionStorage,\n} from '../webStorage'\n\nexport default function useScrollRestoration() {\n  const router = useRouter()\n\n  useEffect(() => {\n    let scrollStore: null | { x: number; y: number }\n\n    const onRouteChangeStart = () => {\n      setSessionStorage('scroll-position', {\n        x: window.pageXOffset,\n        y: window.pageYOffset,\n      })\n      //   console.log('1. 경로변경 전 저장', window.pageXOffset, window.pageYOffset)\n    }\n\n    const onRouteChangeComplete = () => {\n      if (scrollStore) {\n        const { x, y } = scrollStore\n        // console.log('3. 경로변경 후 (복구)', scrollStore)\n        setTimeout(() => window.scrollTo(x, y), 50)\n        scrollStore = null\n        removeWebStorage('scroll-position', 'session')\n      }\n    }\n\n    router.beforePopState(() => {\n      scrollStore = getSessionStorage('scroll-position')\n      //   console.log('2. 뒤로가기 전 실행', scrollStore)\n      return true\n    })\n    router.events.on('routeChangeStart', onRouteChangeStart)\n    router.events.on('routeChangeComplete', onRouteChangeComplete)\n\n    return () => {\n      router.events.off('routeChangeStart', onRouteChangeStart)\n      router.events.off('routeChangeComplete', onRouteChangeComplete)\n    }\n  }, [])\n}\n```\n\n위 해당 코드를 `_app.tsx`에서 실행시켰다. 먼저 코드를 보면서 설명해보자면,\nnext-router의 [router.events](https://nextjs.org/docs/api-reference/next/router#routerevents)를 활용하여 경로가 이동될 때 함수를 실행하게 했다.\n참고로 라우터 이벤트는 useEffect에서 구독하여 실행해야한다.\n\n- `routeChangeStart(url, { shallow })` - 경로가 변경되기 시작할때 발생\n\n- `routeChangeComplete(url, { shallow })` - 경로가 완전히 변경되면 발생\n\n- [router.beforePopState](https://nextjs.org/docs/api-reference/next/router) - 경로 작동 전 실행함. return값이 true면 popstate를 호출함\n\n  - [popstate](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event) : 뒤로가기/앞으로가기 버튼 클릭 시 호출됨\n\n#### 구현 과정\n\n> 경로 이동 예시 : 글 목록 (스크롤 후)=> 글 상세\n\n1. 경로 이동 시작될 때(routeChangeStart) 스크롤위치를 sessionStorage에 저장\n2. 뒤로가기 클릭해서 경로 작동되기 전에(beforePopState) sessionStorage에 저장된 값을 변수(scrollStore)에 할당함\n3. 경로 완전히 변경된 후(routeChangeComplete) 변수에 저장된 값이 있으면 스크롤 위치 복구 후 다시 초기화해줌\n\n# 문제\n\n# 참고\n\nhttps://coffeeandcakeandnewjeong.tistory.com/94\nhttps://helloinyong.tistory.com/300\n",
  },
  {
    slug: 'nextjs-infinite-scroll',
    title: 'Intersection Observer API로 무한스크롤 구현하기',
    content:
      "\n## 적용하는 이유\n\n이전에는 블로그에서 글 목록 페이지에 접속했을 때 모든 글을 출력해주고 있었습니다.\n예를 들어 100개 글이 있다면 1번 요청에 100개를 받아오는 방식이었습니다.\n그래서 긴 목록을 렌더링할 때 사용하는 페이지네이션이나 무한스크롤을 적용하여 필요한 데이터만 나눠 받을 수 있게 하는 방법으로 구현하고자 했습니다.\n<br/>\n먼저 페이지네이션은 페이지 이동을 위해 따로 클릭을 해야하지만\n무한스크롤은 그냥 스크롤만 하면 추가 데이터를 볼 수 있습니다.\n따라서 사용자 경험을 높이기 위해서 스크롤만해서 새 데이터를 볼 수 있는 무한스크롤을 선택했습니다. 이 글에서는 무한스크롤 방식을 Intersection Opserver API를 사용하여 구현하고자 합니다.\n\n### 무한 스크롤 한계점\n\n- 뒤로가기 시 이전 스크롤 위치 기억하는 추가 작업 필요\n- 푸터 찾기 어려워짐\n\n## 무한스크롤 구현 방법\n\n1. scroll event\n\n   - throttle이나 requestAnimationFrame으로 구현\n     : 스크롤 이벤트 성능 개선을 위해서 위에 해당된 추가 작업이 필요하다\n\n2. Intersection Opserver API\n\n#### 구현 사항\n\n- 최하단까지 스크롤하면 N개 데이터 fetch하기\n- 받아올 다음 데이터 없거나 로딩중일 때 fetch 중지\n\n#### 추가 구현 사항\n\n- 목록에서 스크롤 내리고 1개 상세페이지로 들어갔다가\n  뒤로가기 누르면 이전 스크롤 위치 기억하기\n- 로딩중일 때, 스켈레톤 UI 로드\n\n---\n\n# Intersection Opserver API\n\n[Intersection Opserver API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) 는 상위요소나 viewport에서 해당 요소가 교차될 때 변경사항을 비동기식으로 관찰할 수 있게 하는 API다. 예를 들어 컴퓨터 화면에서 특정 요소가 보여질 때를 관찰하여 콜백함수를 실행하게 하는 것이다.\n\n## 1. Intersection Opserver 개념\n\n#### Intersection Observer 인스턴스 생성하기\n\n```js\nlet options = {\n  root: document.querySelector('#scrollArea'),\n  rootMargin: '0px',\n  threshold: 1.0,\n}\n\n// Intersection Opserver 생성\n// 요소가 관찰되면 1번째 인자인 콜백함수 실행, 2번쨰 인자로 옵션 지정\nlet observer = new IntersectionObserver(callback, options)\n```\n\n#### options\n\n- `root` - 대상이 root에 들어오면 콜백함수를 실행함. (기본값인 `null`은 viewport가 지정됨)\n- `rootMargin` - root의 margin값 [상,오,하,왼] 지정 가능. (기본값 0)\n- `threshold` - 대상의 가시성 비율을 나타내는 숫자나 배열로, 대상이 얼마나 보이느냐에 따라 콜백함수 실행함. 0.5 - 대상이 root에서 50% 보이면 감지 / 1.0- 대상 전체가 보이면 감지 (기본값 0)\n\n#### callback 함수\n\n타겟 요소의 관찰이 시작될 때 실행되는 콜백함수\n\n```js\nlet callback = (entries, observer) => {\n  entries.forEach((entry) => {\n    // entry.isIntersecting :target의 교차여부를 boolean값으로 출력\n    // entry.target\n  })\n}\n```\n\n- `entries` - target의 배열. 현재상태에 대한 속성들이 존재함.\n- `observer` - 콜백함수 호출한 observer\n\n#### 메서드\n\n```js\n// 타겟 관찰 시작\nobserver.observe(target)\n// 타겟 관찰 중단\nobserver.unobserve(target)\n// 모든 관찰 중단\nobserver.disconnect()\n```\n\n#### 관찰할 요소 타겟팅하기\n\n```tsx\n/* JS 버전 */\nlet target = document.querySelector(\"#listItem\");\nobserver.observe(target);\n\n/* React + TS 버전 */\nlet target = useRef<HTMLDivElement>(null);\nobserver.observe(target.current as Element);\n// ...\nreturn (\n{/* ... */}\n<div ref={target}></div>\n)\n```\n\n---\n\n## 2. 커스텀 훅 만들기\n\n커스텀 훅으로 만들어두면 무한 스크롤, 스켈레톤 UI, 지연 로딩 등에서도 재사용할 수 있으므로 Hook으로 분리하여 구현해봅시다.\n\n```tsx:useIntersect.tsx\n/* NextJS + TS 버전 */\nimport { useCallback, useEffect, useRef } from 'react'\n\ninterface IntersectionObserverInit {\n  root?: Element | Document | null\n  rootMargin?: string\n  threshold?: number | number[]\n}\n\ntype IntersectHandler = (\n  entry: IntersectionObserverEntry,\n  observer: IntersectionObserver,\n) => void\n\nconst defaultOptions = {\n  root: null,\n  rootMargin: '0px',\n  threshold: 1.0,\n}\n\nexport default function useIntersect(\n  onIntersect: IntersectHandler,\n  options?: IntersectionObserverInit,\n) {\n  const target = useRef<HTMLDivElement>(null)\n\n  const callback = useCallback(\n    (entries: IntersectionObserverEntry[], observer: IntersectionObserver) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          onIntersect(entry, observer)\n        }\n      })\n    },\n    [onIntersect],\n  )\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(callback, {\n      ...defaultOptions,\n      ...options,\n    })\n    if (target.current) {\n      observer.observe(target.current as Element)\n    }\n    return () => observer && observer.disconnect()\n  }, [target, callback, options])\n\n  return target\n}\n```\n\n#### React에서는 useEffect 안에서 인스턴스 생성\n\nuseEffect에서 렌더링이 되고 나서 해당 target이 있을 때 `observe()`로 관찰을 시작하고\n`return()`문에서 언마운트될 때 `disconnect()`하여 관찰을 중단한다.\n\n<br />\n\n### Hook 사용처\n\n```tsx\nexport default function Blog() {\n  const [blogs, setBlogs] = useState([])\n  const [page, setPage] = useState(0)\n  const [nextPage, setNextPage] = useState(true)\n  const [isLoading, setIsLoading] = useState(false)\n\n  const fetchData = async () => {\n    setIsLoading(true)\n    const { contents, pageNumber, isLastPage } = await blogsApi.getBlogs(\n      page,\n      8,\n    )\n    setBlogs(blogs.concat(contents))\n    setPage(pageNumber + 1)\n    setNextPage(!isLastPage)\n    setIsLoading(false)\n  }\n\n  const target = useIntersect(async (entry, observer) => {\n    observer.unobserve(entry.target)\n    if (nextPage && !isLoading) {\n      fetchData() // 다음페이지 있고 로딩중 아닐때 fetch 하기\n    }\n  })\n  return (\n    <>\n      {/* fetch로 받은 limit있는 N개 목록 ... */}\n      <div ref={target}>{isLoading && <div>Loading...</div>}</div>\n    </>\n  )\n}\n```\n\n#### 최하단까지 스크롤하면 N개 데이터 fetch하기\n\nfetch로 받아온 제한된 개수를 가진 목록이 있고, 그 목록 바로 밑에 target을 두어서 target에 도달했을 때 새 데이터를 fetch 받도록 했습니다.\n\n#### 다음 데이터가 있고, 로딩중이 아닐 때만 fetch하기\n\n최하단까지 스크롤했을 때 데이터 fetch를 계속 반복하면 안되기 때문에\n조건문에 해당될 때만 fetch하도록 구성해야 합니다.\n예를 들어 다음 데이터가 있고, 로딩중이 아닐때만 fetch를 하도록 합니다.\n\n# 마치며\n\n목록을 출력하는 방법으로 무한 스크롤이 있지만 이 방법에도 한계점이 있습니다. 밑처럼 추가 구현해야 될 사항들이 있습니다.\n\n- 뒤로가기 시 이전 스크롤 위치 기억하기\n- 불러온 데이터만큼 DOM 노드 증가하기 때문에 렌더링 최적화 작업 필요\n- 로딩중일 때 스켈레톤 UI 출력하기\n\n이 중에서 뒤로가기 구현은 스크롤 위치를 기억해야한다는 점이 있습니다.\n먼저 무한스크롤로 데이터를 N개까지 로드한 이후에 상세 페이지로 이동했다가 뒤로가기로 돌아오면 데이터가 초기화되어 있습니다.\n간단하게 구현하려면 상세페이지를 모달로 구현하거나 이전 데이터를 전부 저장해놓는 방법이 있습니다.\n하지만 이전 데이터가 100페이지가 넘는다거나 대량의 데이터라면 저장하기가 부담스럽습니다.\n또는 세션스토리지에 스크롤높이를 저장해두고, 뒤로가기시 padding-bottom으로 저장해둔 값을 설정하는 방법이 있습니다. 하지만 이도 1페이지부터~N페이지까지 전부 요청을 다시 해야되기 때문에 서버에 부담이 가고 로딩시간이 길어진다는 점이 있습니다.\n<br/>\n그리고 이와 연관되서 DOM 노드 수가 증가한다는 문제가 발생됩니다. 이전 데이터를 다 불어오면 DOM 노드 수가 증가하기 때문에 그만큼 렌더링 시간도 증가한다는 문제가 있습니다. 따라서 가상화목록(or windowing)이라는 렌더링 최적화방식을 적용해야 할 필요성이 있습니다.\n이와 관련된 내용은 다음 포스트부터 설명하도록 하겠습니다.\n<br/>\n무한스크롤 방식이 사용자 경험 향상에 도움이 되지만, 한계점이 있고 이에 따라 추가적인 작업을 구현해야 한다는 점이 있습니다. 모든 사이트가 무한스크롤을 사용하지 않는 것은 이러한 문제들이 있었기 때문이라고 생각했습니다. 따라서 각 방식의 트레이드오프를 비교해서 해당 서비스에 맞는 효과적인 방식을 선택하는 것이 바람직하다고 생각합니다.\n\n<br /><br /><br />\n\n---\n\n> 참고\n\n[실전 Infinite Scroll with React - kakaoenterprise](https://tech.kakaoenterprise.com/149)\n[(React) 무한 스크롤 기능 구현하기 : used by Intersection Observer - 2](https://velog.io/@yunsungyang-omc/React-%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-used-by-Intersection-Observer-2)\n[무한 스크롤(Infinite scroll) 구현하기](https://velog.io/@eunoia/%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4Infinite-scroll-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)\n[[React] 무한 스크롤 적용하기](https://velog.io/@sjoleee_/React-%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4#%EB%AC%B4%ED%95%9C%EC%8A%A4%ED%81%AC%EB%A1%A4%EC%9D%84-%EB%8F%84%EC%9E%85%ED%95%98%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0)\n",
  },
  {
    slug: 'nextjs-setting-ts',
    title:
      'NextJs + TS 셋팅 - eslint, prettier, styled-components (husky, lint-staged, airbnb)',
    content:
      '\n[Next.js 공식문서](https://nextjs.org/docs/basic-features/typescript)\n\n#### 개발환경\n\n- next.js - 13.1.1\n- typescript - 4.9.4\n- eslint (+ airbnb규칙) - 8.31.0\n- prettier - 2.8.2\n- husky - 8.0.0\n- lint-staged - 13.1.0\n- styled-components - 5.3.6\n\n# Next.js + TS 설치\n\n### 1. Next.js + TS 새 프로젝트로 생성하는 방법 1\n\n```bash\nnpx create-next-app@latest --ts 프로젝트명\n#or\nyarn create next-app --typescript 프로젝트명\n#or\npnpm create next-app --ts 프로젝트명\n\n#eslint 설치하겠냐는 질문에 yes 선택\n```\n\n```diff-json:package.json showLineNumbers\n{\n  "name": "xmunt",\n  "version": "0.1.0",\n  "private": true,\n  "scripts": {\n    "dev": "next dev",\n    "build": "next build",\n    "start": "next start",\n    "lint": "next lint"\n  },\n  "dependencies": {\n    "@next/font": "13.1.1",\n    "@types/node": "18.11.18", //ts 관련 패키지\n    "@types/react": "18.0.26", //ts 관련 패키지\n    "@types/react-dom": "18.0.10",\n    "eslint": "8.31.0",\n    "eslint-config-next": "13.1.1",\n    "next": "13.1.1",\n    "react": "18.2.0",\n    "react-dom": "18.2.0",\n    "typescript": "4.9.4"\n  }\n}\n\n```\n\n<br/><br/>\n\n### 2. 기존 프로젝트(Next.js )에서 Next.ts로 생성하는 방법 2\n\n```bash\ntouch tsconfig.json\nnpm install --save-dev @types/react @types/node\nnpm run dev  # 잘 실행되면 됨 tsconfig.json에 자동 설정됨\n```\n\n<br/><br/><br/><br/>\n\n# 1. ESLint 설정\n\nNext.js 버전 `11.0.0` 부터 ESLint가 함께 통합됐기 때문에\nNext 설치 때 eslint 설치에 yes했다면,\nESLint를 추가 설치하거나 `.eslintrc.json`을 따로 생성하지 않아도 됨.\n(만약 next 설치할때 eslint 설치하겠냐는 질문에 no 했다면 해야겠지만,)\n\n- airbnb, google, next 등 다양한 규칙들이 있다. 그 중에 대표적인 airbnb 규칙을 사용해서 설치하고자 한다.\n\n<br/>\n\n## Airbnb 규칙 설정\n\n### 1. `eslint-config-airbnb` - 리액트 관련 규칙\n\n- 리액트 관련된 경우 사용\n\n> - eslint-config-airbnb의 의존성 패키지 목록 확인 명령어\n\n```bash\nnpm info "eslint-config-airbnb@latest" peerDependencies\n```\n\n- 위 명령어를 통해 조회된 종속 패키지목록이다.\n  버전에 맞는 패키지들을 같이 설치해줘야 한다\n  ```bash\n  {\n    eslint: \'^7.32.0 || ^8.2.0\',\n    \'eslint-plugin-import\': \'^2.25.3\',\n    \'eslint-plugin-jsx-a11y\': \'^6.5.1\',\n    \'eslint-plugin-react\': \'^7.28.0\',\n    \'eslint-plugin-react-hooks\': \'^4.3.0\'\n  }\n  ```\n\n#### 설치하기\n\n```bash\n#1. airbnb + 종속 패키지까지 설치하기\nnpx install-peerdeps --dev eslint-config-airbnb\n#또는 각각 개별적 설치\nnpm install -D eslint eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-ally\n\n#2. TypeScript 관련 airbnb, lint 패키지 설치하기\nnpm install -D eslint-config-airbnb-typescript @typescript-eslint/eslint-plugin @typescript-eslint/parser\n```\n\n<br/><br/><br/>\n\n### 2. `eslint-config-airbnb-base` - 리액트 제외 규칙\n\n- 리액트를 안 쓰는 경우 설치\n- 종속성 패키지 확인 명령어\n  ```bash\n  npm info "eslint-config-airbnb-base@latest" peerDependencies\n  ```\n\n#### 설치하기\n\n```bash\nnpx install-peerdeps --dev eslint-config-airbnb-base\n```\n\n- `.eslintrc.json`에 설정 추가\n\n```js:.eslintrc.json\n"env": {\n    "br/owser": true,\n    "node": true,\n  },\n  "extends": "airbnb-base",\n  "rules": {\n    "linebr/eak-style": 0,\n  },\n```\n\n<br/><br/><br/>\n\n# 2. Prettier 설치\n\n#### 1. Prettier 및 플러그인 설치하기\n\neslint와 prettier를 함께 사용할 시 규칙들이 충돌됨으로 의존성 패키지들을 설치해야 한다.\n\n```bash\nnpm install -D prettier eslint-plugin-prettier eslint-config-prettier\n```\n\n- `eslint-plugin-prettier` : eslint에서 prettier랑 충돌할 규칙 비활성화\n- `eslint-config-prettier` : 포매팅할때 prettier 사용하게 하기\n\n#### 2. `.prettierrc` 파일 생성\n\n```js:.prettierrc\n{\n  "semi": false,\n  "singleQuote": true,\n  "tabWidth": 2,\n  "trailingComma": "all"\n}\n```\n\n- `"semi": false` - 세미콜론 사용여부. (Next.js는 세미콜론 `;` 사용안해서 false함)\n- `"singleQuote": true` - 작은 따옴표 `\'` 사용\n- `"tabWidth": 2,` - 탭 너비 설정\n- `"trailingComma": "all"` - 여러 줄일때 마지막에 후행 콤마 사용\n\n<br/><br/><br/>\n\n### `.eslintrc.json` 설정\n\n- 주석설명있는 버전\n\n```js:.eslintrc.json\n{\n  "root": true,\n  "parser": "@typescript-eslint/parser",\n  "plugins": ["@typescript-eslint", "prettier"],\n  "parserOptions": {\n    "project": "./tsconfig.json",\n    "createDefaultProgram": true\n  },\n  "env": { // 전역객체를 eslint가 인식하는 구간\n    "br/owser": true, // document나 window 인식되게 함\n    "node": true,\n    "es6": true\n  },\n  "ignorePatterns": ["node_modules/"], // eslint 미적용될 폴더나 파일 명시\n  "extends": [\n    "airbnb",\n    "airbnb-typescript",\n    "airbnb/hooks",\n    "next/core-web-vitals",\n    "plugin:@typescript-eslint/recommended", // ts 권장\n    "plugin:prettier/recommended" // eslint의 포매팅을 prettier로 사용.\n    "prettier" // eslint-config-prettier prettier와 중복된 eslint 규칙 제거\n  ],\n  "rules": {\n    "react/react-in-jsx-scope": "off", // react 17부턴 import 안해도돼서 기능 끔\n    // 경고표시, 파일 확장자를 .ts나 .tsx 모두 허용함\n    "react/jsx-filename-extension": ["warn", { "extensions": [".ts", ".tsx"] }],\n    "no-useless-catch": "off" // 불필요한 catch 못쓰게 하는 기능 끔\n  }\n}\n```\n\n- rules\n  배열의 첫번째 값을 0,1,2나 "off", "warn", "error"로 규칙 표시\n\n## Error\n\n#### 1. `npm run lint` 실행 시 뜨는 에러내용\n\n```bash\nError: "prettier/@typescript-eslint" has been merged\ninto "prettier" in eslint-config-prettier 8.0.0.\nSee: https://github.com/prettier/eslint-config-prettier/blob/main/CHANGELOG.md#version-800-2021-02-21\n```\n\n#### 2. 원인\n\nextends에 `"prettier/@typescript-eslint"` 속성 때문\n블로그글들 참고하면서 했는데 이 설정 있으면 `npm run lint`가 실행안됨\n\n#### 3. 해결방법\n\neslint-config-prettier 버전 8부터\n`"prettier/@typescript-eslint"` 속성이 `"prettier"`로 병합됨\n\n- `prettier/@typescript-eslint`를 extends 설정에서 제거 후 `"prettier"` 추가\n  [버전 8부터 병합된 내용 공유한 깃허브 ](https://github.com/prettier/eslint-config-prettier/blob/main/CHANGELOG.md#version-800-2021-02-21)\n  [perttier/@typescript-eslint 가 제거됐다는 글](https://stackoverflow.com/questions/65675771/eslint-couldnt-find-the-config-prettier-typescript-eslint-after-relocating)\n\n## `.eslintrc.json`\n\n- 주석 없는 버전\n  ```js:.eslintrc.json\n  {\n    "root": true,\n    "parser": "@typescript-eslint/parser",\n    "plugins": ["@typescript-eslint", "prettier"],\n    "parserOptions": {\n      "project": "./tsconfig.json",\n      "createDefaultProgram": true\n    },\n    "env": {\n      "br/owser": true,\n      "node": true,\n      "es6": true\n    },\n    "ignorePatterns": ["node_modules/"],\n    "extends": [\n      "airbnb",\n      "airbnb-typescript",\n      "airbnb/hooks",\n      "next/core-web-vitals",\n      "plugin:@typescript-eslint/recommended",\n      "plugin:prettier/recommended",\n      "prettier"\n    ],\n    "rules": {\n      "react/react-in-jsx-scope": "off",\n      "react/jsx-props-no-spreading": 0,\n      "@typescript-eslint/semi": "off",\n      "react/jsx-filename-extension": ["warn", { "extensions": [".ts", ".tsx"] }],\n      "no-useless-catch": "off"\n    }\n  }\n  ```\n\n<br/><br/><br/><br/>\n\n# 실행하기\n\n> #### 실행 순서\n>\n> prettier(코드스타일 자동정리) -> eslint(규칙검사) -> 코드 수정\n\n## 1. prettier 실행\n\n- `npx prettier --write pages`\n  ![](https://velog.velcdn.com/images/xmun74/post/aa53cd56-3b27-4604-8014-271e34af2a92/image.png)\n\n## 2. eslint 실행\n\n- `npm run lint`\n- 만약 밑처럼 에러가 난다면 구글링해서 `.eslintrc` rules에서 해당 속성을 끄거나 설정해주면 된다.\n  ![](https://velog.velcdn.com/images/xmun74/post/f61cd481-12c1-4539-ac08-28dfbff020fe/image.png)\n- (난 위에 `.eslintrc.json`에서 해당 속성들을 설정해뒀다)\n  ![](https://velog.velcdn.com/images/xmun74/post/e4dedd9f-8ba4-403d-8aa7-bf4c646779c2/image.png)\n\n<br/><br/>\n\n---\n\n<br/><br/>\n\n# 3. husky와 lint-staged로 편리하게 사용하기\n\n> git commit할 때 변경된 파일만 eslint, prettier 자동 실행하기\n\n### 1. husky\n\n- git hook(커밋,푸시 등) 제어하는 npm 라이브러리\n- git commit 시 eslint, prettier 실행 자동화하기\n\n### 2. lint-staged\n\n- staged된 파일만 특정 명령어 실행하는 도구\n- commit 시 전체가 아니라 변경된 파일만 eslint, prettier 실행하기\n\n#### 설치하기\n\n#### 1. [husky 권장설치 공식문서](https://typicode.github.io/husky/#/?id=automatic-recommended)\n\n```bash\nnpx husky-init && npm install       # npm\nnpx husky-init && yarn              # Yarn 1\nyarn dlx husky-init --yarn2 && yarn # Yarn 2+\npnpm dlx husky-init && pnpm install # pnpm\n```\n\n- 설치하면 package.json 수정됨, husky 설치됨, .husky/pre-commit 생성\n- 설치 후 package.json에 추가된 부분\n\n  ```js:package.json\n    "scripts": {\n      //\n      "prepare": "husky install"\n    },\n  ```\n\n#### 2. lint-staged 설치\n\n```bash\nnpm i -D lint-staged\n```\n\n#### 3. package.json에 명령어 추가하기\n\n변경된 js,jsx,ts,tsx 파일만 밑 명령어 실행하게 함\n\n```js:package.json\n"lint-staged": {\n    "*.{js,jsx,ts,tsx}": [\n      "prettier --write",\n      "eslint --fix"\n    ]\n  }\n```\n\n#### 4. `.husky/pre-commit` 에 명령어 추가 [(참고)](https://github.com/okonet/lint-staged#examples)\n\n```bash\n#!/usr/bin/env sh\n. "$(dirname -- "$0")/_/husky.sh"\n\nnpx lint-staged # 추가\n\n```\n\n<br/><br/><br/><br/>\n\n# 4. styled-components 설정\n\n#### 설치하기\n\n```bash\nnpm i styled-components\nnpm i -D @types/styled-components  # ts 위한 설치\n```\n\n### 1. SSR 설정하기\n\n- 첫 화면 렌더링 때도 css 적용하게 해주기\n- Next.js에서 styled-components에 대한 SSR 추가 설정이 필요하다\n\n> #### 🔺 옛날 방법 (Next.js 12버전 이하)\n\n1. babel 플러그인 설치\n\n```bash\nnpm i -D babel-plugin-styled-components\n```\n\n2. [`.babelrc` 파일 생성 후 추가](https://styled-components.com/docs/tooling#usage)\n\n```js\n{\n  "presets": ["next/babel"],\n  "plugins": [\n    [\n      "babel-plugin-styled-components",\n      {\n        "ssr": true,\n        "fileName": true,\n        "displayName": true,\n      }\n    ]\n  ]\n}\n```\n\n#### ✅ 최신방법 (Next.js 12 버전 이상)\n\nnext 버전 12부터 컴파일러에서 바벨 플러그인`babel-plugin-styled-components`을 포트하고 있음\nhttps://nextjs.org/docs/advanced-features/compiler#styled-components\n\n1. `next.config.js` 에 추가 설정하기\n\n```js:next.config.js\n/** @type {import(\'next\').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  compiler: {\n    // 추가\n    styledComponents: true, // 추가\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n<br/>\n\n2. `pages/_document.tsx` 수정\n\n- 참고 - [next 공식문서](https://nextjs.org/docs/advanced-features/custom-document#customizing-renderpage), [dev글](https://dev.to/sumukhakb210/using-styled-components-with-nextjs-12-and-typescript-in-2021-3439), [참고블로그](https://been.tistory.com/m/56)\n\n```tsx:pages/_document.tsx\nimport Document, {\n  Html,\n  Head,\n  Main,\n  NextScript,\n  DocumentContext,\n  DocumentInitialProps,\n} from \'next/document\'\nimport { ServerStyleSheet } from \'styled-components\'\n\nclass MyDocument extends Document {\n  static async getInitialProps(\n    ctx: DocumentContext,\n  ): Promise<DocumentInitialProps> {\n    const sheet = new ServerStyleSheet()\n    const originalRenderPage = ctx.renderPage\n\n    try {\n      ctx.renderPage = () =>\n        originalRenderPage({\n          enhanceApp: (App) => (props) =>\n            sheet.collectStyles(<App {...props} />),\n        })\n      const initialProps = await Document.getInitialProps(ctx)\n\n      return {\n        ...initialProps,\n        styles: (\n          <>\n            {initialProps.styles}\n            {sheet.getStyleElement()}\n          </>\n        ),\n      }\n    } finally {\n      sheet.seal()\n    }\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head />\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    )\n  }\n}\n\nexport default MyDocument\n```\n\n<br/><br/>\n\n- ssr 적용 전 소스코드에 css 없음\n  ![](https://velog.velcdn.com/images/xmun74/post/24654ab4-de3a-4ae6-a2d0-b00f6a27bcc7/image.png)\n- ssr 적용 후 소스코드에 css가 포함됨\n  ![](https://velog.velcdn.com/images/xmun74/post/614e5b02-77d1-4173-b3a2-87e4786a347a/image.png)\n\n<br/><br/>\n\n### 2. GlobalStyle, Theme 적용하기\n\n- `npm i styled-reset` - 기본으로 적용되는 css 리셋하는 패키지 설치\n\n```bash\nnpm i styled-reset\n```\n\n#### 1. GlobalStyle 전역스타일 설정\n\n- `styles/GlobalStyle.ts` 생성 예시\n\n```ts:styles/GlobalStyle.ts\nimport { createGlobalStyle } from \'styled-components\'\nimport reset from \'styled-reset\'\n\nconst GlobalStyle = createGlobalStyle`\n  ${reset}\n  * {\n    box-sizing: border-box;\n    padding: 0;\n    margin: 0;\n  }\n  body {\n    height: 100%;\n  }\n  button {\n    cursor: pointer;\n    background-color: inherit;\n  }\n  a {\n    text-decoration:none;\n    color:inherit;\n  }\n`\nexport default GlobalStyle\n```\n\n#### 2. Theme 적용하기\n\n> - **Theme 적용 방법** (여기선 일단 ThemeProvider 사용함)\n\n1. ThemeProvider 사용하기\n2. CSS Variable 사용하기\n\n- `styles/theme.ts` 생성 예시\n\n```ts\nimport { DefaultTheme } from \'styled-components\'\n\nexport const lightTheme: DefaultTheme = {\n  accent1: \'#f5fbfc\',\n  accent2: \'#f8c291\',\n  accent3: \'#d35400\',\n  text: \'#000000\',\n  bg1: \'#ffffff\',\n}\n\nexport const darkTheme: DefaultTheme = {\n  accent1: \'#121212\',\n  accent2: \'#bdc3c7\',\n  accent3: \'#2c3e50\',\n  text: \'#ffffff\',\n  bg1: \'#121212\',\n}\n```\n\n#### 3. `pages/_app.tsx` 추가\n\n```tsx\nimport type { AppProps } from \'next/app\'\nimport { useState } from \'react\'\nimport { RecoilRoot } from \'recoil\'\nimport { ThemeProvider } from \'styled-components\'\nimport GlobalStyle from \'../styles/GlobalStyle\'\nimport Layout from \'../components/Layout\'\nimport { darkTheme, lightTheme } from \'../styles/theme\'\n\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    <RecoilRoot>\n      <ThemeProvider theme={darkTheme}>\n        <GlobalStyle />\n        <Component {...pageProps} />\n      </ThemeProvider>\n    </RecoilRoot>\n  )\n}\n```\n\n#### 4. `styles/styled.d.ts` 생성\n\n테마 변수들의 타입을 선언하는 파일\n\n```ts:styles/styled.d.ts\nimport \'styled-components\'\n\ndeclare module \'styled-components\' {\n  export interface DefaultTheme {\n    accent1: string\n    accent2: string\n    accent3: string\n    text: string\n    bg1: string\n  }\n}\n```\n\n<br/><br/>\n\n---\n\n<br/><br/><br/><br/><br/>\n\n# 참고\n\n[밑바닥부터 Next.js 개발 환경 구축하기 - All in One](https://leo-xee.github.io/Next/next-setup-allinone/)\nhttps://kbwplace.tistory.com/151\neslint 옵션 설명 참고 - https://abangpa1ace.tistory.com/194\n[husky, lint-staged로 git commit 전에 eslint, prettier 체크하기](https://kyounghwan01.github.io/blog/etc/husky/#husky-lint-staged-%E1%84%89%E1%85%A5%E1%86%AF%E1%84%8E%E1%85%B5)\n\n다크모드 참고\n\n- [벨로퍼트 - 벨로그에 다크 모드 적용하기](https://velog.io/@velopert/velog-dark-mode#%EB%8B%A4%ED%81%AC-%ED%85%8C%EB%A7%88-%EB%8F%84%EC%9E%85%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%88%A0%EC%A0%81%EC%9D%B8-%EC%A4%80%EB%B9%84)\n- [styled-components typscript로 세팅하기](https://kyounghwan01.github.io/blog/React/styled-components/styled-components-preset/#package-json-%E1%84%89%E1%85%A5%E1%86%AF%E1%84%8E%E1%85%B5)\n',
  },
  {
    slug: 'open-graph',
    title: 'NextJS로 만든 블로그 이쁘게 공유하기 - Open Graph',
    content:
      '\n#### 정보가 없는 미리보기\n\n![230314-185422](/images/posts/open-graph/230314-185422.png)\n만약 위처럼 블로그를 공유했는데\n아무런 정보가 없고 뭐하는 사이트인지도 모르겠다면?\n링크 누르기가 싫어진다...\n\n<br></br>\n\n#### 정보가 풍부한 미리보기\n\n![230314-185428](/images/posts/open-graph/230314-185428.png)\n이번엔 위처럼 SNS에 블로그 링크를 공유할때\n좀 더 이쁘면서 정보도 풍부하게 미리볼 수 있다면?\n보는 사람들도 궁금해서 링크를 클릭할 것이다!\n\n<br></br><br></br>\n\n# Open Graph\n\n링크를 공유했을 때 정보를 표시해주는 open graph를 적용해보자!\nOpen Graph는 통일된 메타데이터를 작성하도록 정의한 규약이다. Facebook, Twitter는 자체 프로토콜을 가지고 있다.\n자세한 메타데이터 및 속성은 [Open Graph Protocol](https://ogp.me/)를 참고하면 된다.\n\n<br></br>\n\n## og 메타데이터 작성하기\n\n`next-seo` 라이브러리를 사용해도 되지만 복잡한 사이트구조가 아니라고 판단하여 직접 `meta`태그를 작성했다.\n\n- 기본 메타데이터 예시\n  밑의 4가지 속성은 필수로 작성해야하는 속성이다.\n\n```html\n<head>\n  <meta property="og:title" content="The Rock" />\n  <meta property="og:type" content="video.movie" />\n  <meta property="og:url" content="https://www.imdb.com/title/tt0117500/" />\n  <meta\n    property="og:image"\n    content="https://ia.media-imdb.com/images/rock.jpg"\n  />\n  ...\n</head>\n```\n\n- 블로그에 적용한 코드\n\n```tsx\n<Head>\n  {/* HTML Meta Tags */}\n  <title>{`${post?.title} | ${pageConfig.title}`}</title>\n  <meta name="description" content={`${pageConfig.title}`} />\n  <meta name="viewport" content="width=device-width, initial-scale=1" />\n\n  {/* Facebook Meta Tags */}\n  <meta\n    property="og:url"\n    content={`https://xmunt.vercel.app/blog/${post?.slug}`}\n  />\n  <meta property="og:type" content="website" />\n  <meta\n    property="og:site_name"\n    content={`${post?.title} | ${pageConfig.title}`}\n  />\n  <meta property="og:title" content={`${post?.title} | ${pageConfig.title}`} />\n  <meta property="og:description" content={post?.description} />\n  <meta property="og:image" content={`${DOMAIN}${post?.coverImage}`} />\n\n  {/* Twitter Meta Tags */}\n  <meta name="twitter:card" content="summary_large_image" />\n  <meta property="twitter:domain" content="xmunt.vercel.app" />\n  <meta\n    property="twitter:url"\n    content={`https://xmunt.vercel.app/blog/${post?.slug}`}\n  />\n  <meta name="twitter:title" content={`${post?.title} | ${pageConfig.title}`} />\n  <meta name="twitter:description" content={post?.description} />\n  <meta name="twitter:image" content={`${pageConfig.siteImg}`} />\n  <meta name="twitter:label1" content="Category" />\n  <meta name="twitter:data1" content={`${post?.category}`} />\n</Head>\n```\n\n#### 직접 메타태그 하나하나 작성하는게 번거롭다면?\n\n[Open Graph prewiew & generate](https://www.opengraph.xyz/url/https%3A%2F%2Fxmunt.vercel.app%2F) 이 사이트에서는 메타데이터가 적용됐는지 각 SNS 별 미리보기를 볼 수 있고, 속성을 입력하면 자동으로 메타태그 생성도 해준다.\n\n<br></br><br></br>\n\n# 문제: 카카오톡 미리보기 업데이트가 안될 때\n\n### 상황\n\n분명히 `meta` 태그 다 적용해서 배포했고 다른 사이트들에선 잘 적용되는데\n카톡에서만,, 계속 og가 적용안된 미리보기가 보였었다!\n\n![230314-185422](/images/posts/open-graph/230314-185422.png)\n\n### 원인\n\n- 캐시가 문제!\n- og `meta`태그를 안 넣었을 때 이미 카톡에 url 공유를 했었던 것!\n- pc, 모바일에서 이미 전에 url 공유를 했었어서 해당 url 캐시가 남아있어서 그 전 미리보기를 불러왔던 것이었다.\n\n### 해결\n\n이럴 때는 카카오톡 캐시를 삭제하면 된다! 캐시 삭제 후 og가 반영된 미리보기로 잘 보여졌다!\n\n#### PC 캐시 삭제하기\n\n[카카오 공유 디버거](https://developers.kakao.com/tool/debugger/sharing)에서 URL 입력 후 캐시 초기화\n\n#### 모바일 캐시 삭제하기\n\n카톡 하단 맨 오른쪽 `...`설정탭 - 맨 아래 앱 관리 - 저장공간 관리 - 캐시 데이터 삭제(사진,동영상,음성파일은 유지됨)\n',
  },
  {
    slug: 'optimization-01',
    title: '빌드 속도 최소화? 근데 이제 Webpack과 React을 곁들인',
    content:
      "\n> 프로젝트가 커질 수록 번들 크기는 무거워지고 빌드 속도가 느려질 수 있습니다. 사용자가 첫 페이지에 진입할 때 느린 초기 로딩을 경험하지 않게 하기 위해서 Webpack과 React를 활용하여 코드를 분할하고 빌드 속도를 개선하는 방법을 살펴보겠습니다.\n\n<br /><br />\n\n### 🕖 빌드 시간 측정하기\n\n- [speed-measure-webpack-plugin](https://github.com/stephencookdev/speed-measure-webpack-plugin)로 Webpack loader와 plugin의 빌드 속도를 측정할 수 있습니다.\n- 사용 예시\n  ```js\n  // webpack.common.js\n  const SpeedMeasurePlugin = require('speed-measure-webpack-plugin')\n  const smp = new SpeedMeasurePlugin()\n  const webpackConfig = smp.wrap({\n    plugins: [\n      //...\n    ],\n  })\n  ```\n\n### 📐 번들 크기 분석하기\n\n- [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)를 사용하여 번들 크기를 분석했습니다.\n- 사용 예시\n\n  ```js\n  // webpack.production.js\n  const BundleAnalyzerPlugin =\n    require('webpack-bundle-analyzer').BundleAnalyzerPlugin\n  const { merge } = require('webpack-merge')\n  const common = require('./webpack.common.js')\n\n  module.exports = merge(common, {\n    mode: 'production',\n    plugins: [\n      new BundleAnalyzerPlugin({\n        openAnalyzer: true, // 보고서를 브라우저로 자동 오픈\n      }),\n    ],\n    //...\n  })\n  ```\n\n### Webpack 개발 모드 참고사항\n\n1. devtool : 웹팩 공식 문서에서는 `eval-cheap-module-source-map` 을 권장\n2. 제외해야 할 플러그인\n   왜냐하면 개발 모드일때는 빌드 속도가 빠르고 디버깅하기 쉬워야하기 때문에 압축 등 최적화 작업이 불필요합니다.\n   - TerserPlugin\n   - [fullhash]/[chunkhash]/[contenthash]\n   - AggressiveSplittingPlugin\n   - AggressiveMergingPlugin\n   - ModuleConcatenationPlugin\n\n<br /><br />\n\n---\n\n<br /><br />\n\n# 빌드 시간 최적화 방법\n\ndevelopment 모드에서는 빠른 빌드 속도와 디버깅이 편하기 위해 파일압축 등의 최적화 작업이 불필요하지만, production 모드일 때는 번들 크기를 줄여야하기 때문에 압축(Minify), 난독화 등의 최적화 작업이 필요합니다. 따라서 번들 크기를 줄이거나 빌드 속도를 최적화하는 방법을 알아보겠습니다.\n<br />\n\n> **압축(Minify)**\n> : 공백/들여쓰기, 주석, debugger, console.log 등을 제거하는 작업\n> **난독화(Uglify)**\n> : 기존 변수명, 함수명을 다르게 치환하는 보안 처리 작업. 난독화 단계가 높을 수록 코드를 해석하고 실행하는 시간이 늘어난다.\n\n <br />\n\n1. 불필요한 loader, plugin 제거\n2. loader 교체하기\n3. Code Splitting\n\n<br /><br />\n\n## 1. 불필요한 loader, plugin 제거\n\n#### Webpack v5부터 추가된 Asset 모듈 유형 사용하기\n\nv5 이전까진 `file-loader`, `url-loader`, `raw-loader`를 사용했지만, v5 이후부터 이 loader들을 대체하기 위한 모듈 유형이 추가됐습니다. 따라서 불필요해진 loader들을 제거하고 최소한으로 loader를 관리할 수 있게 됐습니다.\n\n- [Asset Modules](https://webpack.kr/guides/asset-modules/)\n  - asset/resource : file-loader 대체\n  - asset/inline : url-loader 대체\n  - asset/source : raw-loader 대체\n- 사용예시\n  ```js\n  module: {\n      rules: [\n        {\n          test: /\\.(png|jpe?g|gif|ico|webp)$/,\n          type: 'asset/resource',\n          generator: {\n            filename: 'images/[hash][ext][query]',\n          },\n        },\n      ],\n    },\n  ```\n\n<br />\n\n## 2. loader 교체하기\n\n#### 트랜스파일 loader 교체하기\n\n제일 처음에는 `babel-loader`를 사용했었습니다.\n하지만 파일 압축 플러그인을 설치 안했을 때 빌드 속도가 4.6s였기 때문에 플러그인을 추가 설치한다면 속도가 늘어날 것으로 예상됐습니다. 그래서 아예 loader를 교체해 빌드 속도를 줄이고자 했습니다.\nloader 종류로는 `babel-loader`, `ts-loader`, `esbuild-loader`, `swc-loader` 등이 있습니다. 이 중 앞선 3개 로더를 중심으로 살펴보겠습니다.\n\n<br />\n\n#### 1. `babel-loader` - 4.6s 소요됨 (플러그인 미설치 기준)\n\n- 압축 플러그인 추가 설치 필요\n  `terser-webpack-plugin` : JS 축소 플러그인(webpack v5 이상이면 내장되어 있어서 추가 설치 불필요)\n  `css-minimizer-webpack-plugin` : CSS 축소 플러그인\n\n#### 2. `ts-loader`\n\n- 타입스크립트 사용 시\n- 한계점 : 타입 검사하는 시간 때문에 빌드 속도가 저하됨\n- 한계점 보완하기 위해 `forkTsCheckerWebpackPlugin` 설치 필요\n- `forkTsCheckerWebpackPlugin`\n  : 별도의 스레드에서 타입 검사 진행하므로 빌드 시간을 줄일 수 있다.\n  - `transpileOnly: true` 옵션 활성화해서 `ts-loader`의 타입 검사를 해제하고 트랜스파일링만 수행하게 합니다.\n    해당 옵션은 `forkTsCheckerWebpackPlugin`을 사용한다면\n    `transpileOnly: true` 옵션이 자동 활성화되어있지만\n    `ts-loader` v9.3.0 미만이라면 옵션을 활성화시켜줘야 합니다.\n  - 예시\n  ```js\n  const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin')\n  //...\n  module.exports = {\n    // ...\n    module: {\n      rules: [\n        {\n          test: /.([cm]?ts|tsx)$/,\n          loader: 'ts-loader',\n          options: {\n            transpileOnly: true, // ts-loader v9.3.0 미만 시 옵션 활성화\n          },\n        },\n      ],\n    },\n    plugins: [\n      new ForkTsCheckerWebpackPlugin(),\n      // ...\n    ],\n  }\n  ```\n\n#### 3. `esbuild-loader` - ✅ 선택 2.1s 소요됨\n\n- 압축 플러그인이 내장되어 추가 설치 불필요\n  `EsbuildPlugin` - JS 축소 플러그인\n- 사용 중인 라이브러리와 호환이 안될 수 있어서 브라우저에서 정상 동작하는지 확인 필요\n- 타입 검사를 위해서 build script에 tsc 추가\n  ```json\n  //package.json 예시\n  \"typecheck\": \"tsc --noEmit\",\n  \"build\": \"npm run typecheck && webpack\"\n  ```\n\n> ### esbuild 란?\n>\n> esbuild는 차세대 번들러로 webpack5보다 빠른 속도를 가지고 있습니다. [(esbuild가 빠른 이유 - esbuild 공식문서)](https://esbuild.github.io/faq/) > ![](https://velog.velcdn.com/images/xmun74/post/19ce4ad4-cc92-4554-bda1-b3b7f10e101a/image.png)\n> 이렇게나 빠른데 esbuild를 번들러로 사용하지 않는 이유가 있습니다!\n> 아직까진 안정화된 단계가 아닌 점과 주의할 사항으로 Hot-module reloading, TypeScript 타입 검사 등의 기능 지원은 앞으로 없다고 합니다.[(참고)](https://esbuild.github.io/faq/#upcoming-roadmap)\n> 그런데 esbuild는 `esbuild-loader`를 지원하기 때문에 webpack의 loader와 결합할 수 있어서 webpack의 빌드 성능을 개선하는 데 활용할 수 있습니다.\n\n<br /><br />\n\n### ✅ esbuild-loader 적용 예시\n\n- webpack.common.js\n\n```js\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst path = require('path')\nconst dotenv = require('dotenv')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst SpeedMeasurePlugin = require('speed-measure-webpack-plugin')\nconst webpack = require('webpack')\n\nconst smp = new SpeedMeasurePlugin() // 빌드속도 측정 플러그인\n\ndotenv.config()\nmodule.exports = smp.wrap({\n  entry: `${path.resolve(__dirname, './src')}/index.tsx`,\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[contenthash].bundle.js',\n    chunkFilename: '[name].[contenthash].chunk.bundle.js',\n    clean: true,\n    publicPath: '/',\n  },\n  resolve: {\n    extensions: ['.js', '.jsx', '.ts', '.tsx'],\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n    },\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.[jt]sx?$/,\n        exclude: /node_modules/,\n        loader: 'esbuild-loader', //esbuild-loader로 교체\n        options: {\n          target: 'es2015',\n        },\n      },\n      {\n        test: /\\.(png|jpe?g|gif|ico|webp)$/,\n        type: 'asset/resource',\n        generator: {\n          filename: 'images/[hash][ext][query]',\n        },\n      },\n      {\n        test: /\\.css?$/,\n        exclude: [],\n        use: ['style-loader', 'css-loader', 'postcss-loader'],\n      },\n      {\n        test: /\\.svg$/i,\n        issuer: /\\.[jt]sx?$/,\n        use: ['@svgr/webpack'],\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, './public/index.html'),\n      favicon: './public/favicons/favicon.ico',\n    }),\n    new webpack.EnvironmentPlugin(['API_URL', 'USER_IMG_FIELD', 'CLIENT_URL']),\n  ],\n})\n```\n\n- webpack.dev.js\n\n```js\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst { merge } = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  devtool: 'eval-cheap-module-source-map',\n  devServer: {\n    port: 3000,\n    open: true, // 개발 서버 실행하면 브라우저 자동 오픈\n    // hot: true, // HMR(Hot Module Replacement) 사용할 수 있게 함. 4버전부터 자동 활성화됨.\n    historyApiFallback: true, //spa에서 react-router-dom 사용할 때 404에러 발생 방지\n    compress: true, // gzip 압축\n  },\n  optimization: {\n    minimize: false, // Terser 압축 플러그인 비활성화\n  },\n})\n```\n\n- webpack.prod.js\n\n```js\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst { EsbuildPlugin } = require('esbuild-loader')\nconst BundleAnalyzerPlugin =\n  require('webpack-bundle-analyzer').BundleAnalyzerPlugin\nconst { merge } = require('webpack-merge')\nconst common = require('./webpack.common.js')\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  plugins: [\n    new BundleAnalyzerPlugin({\n      openAnalyzer: true, //번들 보고서를 브라우저로 자동 오픈\n    }),\n  ],\n  optimization: {\n    minimizer: [\n      // EsbuildPlugin으로 JS 축소\n      new EsbuildPlugin({\n        target: 'es2015',\n        css: true, // CSS assets 축소\n      }),\n    ],\n  },\n})\n```\n\n<br /><br />\n\n### 로더 교체 전/후 빌드 속도 비교\n\n- `babel-loader`일 때 `speed-measure-webpack-plugin`으로 빌드 시간을 측정한 결과 4.65s 소요\n  ![](https://velog.velcdn.com/images/xmun74/post/bbffbbbc-7bc1-4b2b-a988-d9518690a38b/image.png)\n- `esbuild-loader`로 변경 후 2.12s로 **약 2초 감소**\n  ![](https://velog.velcdn.com/images/xmun74/post/3f624ea8-8f5d-4360-8f84-12a9fe4a4a83/image.png)\n\n<br /><br /><br /><br />\n\n## 3. Code-Splitting\n\n여러 개의 파일들을 하나의 파일로 번들링하다보니 용량이 커지게 됩니다.\n이로 인해 SPA일 때 사용자가 첫 페이지에 진입하면 모든 코드가 포함된 대용량의 파일을 다운받다보니 초기 로드 시간이 길어지는 문제가 발생합니다.\n때문에 사용자와의 상호작용이 늦어지게 되어 사용자 경험을 저하시키게 됩니다.\n초기 로드 시간이 길어지면 사용자 이탈이 증가하기 때문에 초기 렌더링 시간을 단축하는 것이 중요합니다.\n<br />\n따라서 이를 해결하기 위해 Code-Splitting이 나타나게 됐습니다.\n대용량인 하나의 번들링 파일을 여러 개의 파일로 분할하는 작업입니다.\n이렇게 코드 분할한 뒤 사용자가 첫 페이지에 진입 시 필요한 코드만 불러오면 되기 때문에 좋은 사용자 경험을 제공할 수 있게 됩니다.\n<br />\nCode-Splitting을 두가지로 나눠서 살펴보겠습니다.\n\n<br />\n\n1. [Webpack으로 코드 분할하기](https://webpack.kr/guides/code-splitting/)\n2. React lazy로 특정 컴포넌트를 분할하고 동적 import하기\n\n<br /><br />\n\n### 1. Webpack으로 코드 분할하기\n\n#### 청크 분할하기\n\n- optimization의 `splitChunks`\n  : 큰 번들을 작은 번들로 분리하여 로딩 속도 개선하는 작업\n  ```js\n  module.exports = {\n    output: {\n      path: path.resolve(__dirname, 'dist'),\n      filename: '[name].bundle.js',\n    },\n    optimization: {\n      splitChunks: {\n        chunks: 'all', // 모든 유형의 청크 포함\n      },\n    },\n  }\n  ```\n- 리액트 관련 패키지끼리 모아서 분리하기\n  리액트를 프로젝트 거의 모든 곳에서 사용하고 있기 때문에 별도의 번들로 분리했습니다. 초기에 리액트 번들 + main 번들을 다운받고나서 업데이트를 하면 리액트 번들을 다시 다운 안받기 위해서 분리했습니다.\n  ```js\n  optimization: {\n      splitChunks: {\n        chunks: 'all', // 리액트 외 것들 분리\n        // 리액트 관련 패키지들을 번들로 묶어서 분리\n        cacheGroups: {\n          reactVendor: { // 코드분할하는 그룹명 지정\n            // 정규 표현식으로 모듈 분리 대상 지정\n            test: /[\\\\/]node_modules[\\\\/](react|react-dom|react-router-dom)[\\\\/]/,\n            name: 'vendor-react', // 출력될 번들 파일명\n            chunks: 'all', // 모든 유형의 청크에서 해당 패키지 분리\n          },\n        },\n      },\n    },\n  ```\n- build 후 출력된 dist/index.html을 살펴보면 아래처럼\n  vender-react 번들, 674.~번들, main 번들로 분할된 것을 확인할 수 있습니다.\n  ![](https://velog.velcdn.com/images/xmun74/post/e21797f4-74bb-461e-8a67-bb5c707b43bc/image.png)\n- `webpack-bundle-analyzer`를 사용하여 확인한 번들\n  ![](https://velog.velcdn.com/images/xmun74/post/acde96b4-42d5-4ffe-91aa-fa7d999a9ecc/image.png)\n\n<br /><br /><br />\n\n### 2. React lazy 사용하기\n\n위에서 webpack의 code splitting을 통해 번들 파일을 분할했다면\nReact lazy 기능으로 필요할 때만 컴포넌트를 동적 import 해오도록 작업해줘야 합니다.\n\n#### React lazy, Suspense\n\n`React lazy`는 컴포넌트를 JS Chunk으로 분리하게 해줍니다. 예를 들어서 Home 페이지 컴포넌트를 따로 Home.Chunk 번들 파일로 분할해주는 것입니다.\n`Suspense`를 사용하면 지연이 발생할 때 로딩중인 스피너를 띄운다던지 로딩상태를 표시할 수 있습니다.\n<br />\n위에서 674 번들처럼 번들명이 id로 자동으로 생성된 것을 볼 수 있습니다. id로 자동 생성된 번들명이 아니라 직관적인 번들명으로 지정해보겠습니다.\n\n<br />\n\n#### 주석으로 번들명 지정하기\n\n- `/* webpackChunkName: \"번들명\" */` 주석으로 번들명 지정하기\n\n  ```tsx\n  import React, { Suspense, lazy } from 'react'\n\n  const Home = lazy(() => import(/* webpackChunkName: \"home\" */ '@/pages/Home'))\n  const Bible = lazy(\n    () => import(/* webpackChunkName: \"bible\" */ '@/pages/Bible')\n  )\n  const Profile = lazy(\n    () => import(/* webpackChunkName: \"profile\" */ '@/pages/Profile')\n  )\n\n  const App = () => (\n    <Router>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/bible\" element={<Bible />} />\n          <Route path=\"/profile\" element={<Profile />} />\n        </Routes>\n      </Suspense>\n    </Router>\n  )\n  ```\n\n- webpack.common.js에서 설정\n  `chunkFilename` : 고유 해쉬값으로 청크 파일명 생성하여 중복 방지\n  ```js\n  module.exports = {\n    output: {\n      path: path.resolve(__dirname, 'dist'),\n      filename: '[name].bundle.js',\n      // 분할된 청크 파일명 지정\n      chunkFilename: '[name].[chunkhash].bundle.js',\n    },\n  }\n  ```\n  위에 지정된 번들명으로 파일이 잘 생성된 것을 확인할 수 있습니다.\n  ![](https://velog.velcdn.com/images/xmun74/post/7a555cee-db22-4baa-b51e-225a82a2229e/image.png)\n\n#### TS 사용 시 tsconfig 설정 참고하기\n\n- module 설정\n  `\"module\": \"esnext\"`\n  동적 import를 사용하기 위해선 module이 다음과 같은 설정일 때 동작합니다.\n  'es2020', 'es2022', 'esnext', 'commonjs', 'amd', 'system', 'umd', 'node16', 'nodenext'\n- 주석 제거 설정 비활성화\n  `\"removeComments\": false`\n  TS 컴파일 과정에서 주석을 제거하면 Webpack에서 번들명 지정 주석을 읽기 전에 삭제되어 정상 작동안될 수 있습니다. 또한 Webpack에서도 Minify 압축할 때 주석을 제거하므로 tsconfig에서 해당 옵션을 비활성화합니다.\n  ```json\n  compilerOptions: {\n    \"module\": \"esnext\",\n    \"removeComments\": false,\n    // ...\n  }\n  ```\n\n<br /><br />\n\n### code splitting 전 후 번들 크기 비교\n\nyarn build를 하면 보고서가 브라우저에 자동으로 열립니다.\n밑 사진과 같이 main에 커서를 올려서 용량을 알 수 있습니다.\n<br />\n\n> - Stat - 파일 입력 크키 (축소 전 크기)\n> - Parsed - 파일 출력 크기 (Minify, Uglify 등 축소 후 크기)\n> - Gzipped - 압축돼서 네트워크에 로드되는 크기\n\n<br />\n\n- 전 - Stat : 738KB / Parsed : 739KB / Gzipped : 179KB\n  ![](https://velog.velcdn.com/images/xmun74/post/6c97f601-b227-4de8-b9b1-ba417cb526b6/image.png)\n- 후 - Stat : 753KB / Parsed : 400KB / Gzipped : 130KB\n  Gzipped 기준으로 **약 27% 감소**\n  ![](https://velog.velcdn.com/images/xmun74/post/91e32d7a-8252-4232-8452-09ae829d85a9/image.png)\n\n<br /><br /><br /><br />\n\n---\n\n<br /><br /><br /><br />\n\n# 참고\n\n[Webpack 공식문서 - 빌드 성능](https://webpack.kr/guides/build-performance/)\n[esbuild-loader github](https://github.com/esbuild-kit/esbuild-loader)\nhttps://www.codemzy.com/blog/react-bundle-size-webpack-code-splitting\n",
  },
  {
    slug: 'pitfalls-of-jwt',
    title: 'JWT도 함정은 있다!',
    content:
      '\n### 들어가기에 앞서\n\n먼저 로그인을 구현하는 인증방식으로 Session(세션인증)과 JWT(토큰인증)가 있습니다.\n비교적 최신에 나온 JWT는 많은 기술 블로그에서도 소개가 되면서 무조건 기본으로 채택하는 경우가 있습니다.\n그런데 정말 JWT가 좋으니깐 기본으로 채택해야 할까요?\n\n<br />\n\n먼저 세션 - 토큰 인증방식의 트레이드오프를 살펴보기 위해 각 특징에 대해서 간단히 살펴보고자 합니다.\n\n# 1. 세션(서버)기반 인증방식\n\n: 서버나 DB에 사용자 인증정보 저장하는 방식\n\n- 사용자가 로그인을 하면 인증정보를 서버의 세션 저장소에 저장하고 사용자에게 식별자로 Session ID를 발급해주게 됩니다. 식별자인 Session ID는 쿠키로 저장되어 전송,전달하지만 실제 중요한 인증정보는 서버나 DB에 저장되어 있습니다.\n\n#### 장점\n\n- 프론트엔드측의 인증이 쉬워진다.\n- 보안 측면에서 조금 유리\n  서버에서 인증정보를 관리하기 때문에 만약 해커가 세션 ID를 탈취하더라도 서버에서 해당 세션을 무효화하여 로그아웃시키면 됩니다.\n\n#### 단점\n\n- 확장성 문제로 서버측 비용 증가\n  사용자가 증가하게 되면 많은 트래픽을 처리해야 되므로 그만큼 DB 리소스가 더 필요해지게 됩니다. 그래서 서버 확장하거나 세션 분산 설계가 복잡해진다는 문제가 있습니다.\n\n# 2. 토큰기반 인증방식\n\n: 클라이언트 측에 사용자 인증정보 저장하는 방식\n\n#### 장점\n\n- 서버의 무상태성\n  클라이언트측에 토큰을 저장되기때문에 유저의 정보를 서버에 저장해두지 않습니다. 서버는 토큰 해독 여부만 판단하게 됩니다.\n- 서버 확장에 용이\n  서버가 무상태성을 가지게 되면서 서버 메모리 과부화에 대한 문제가 해결되고 사용자가 늘어나도 확장에 용이해지게 됩니다.\n\n## 토큰방식의 함정\n\n### 1. 크기 문제\n\n세션은 쿠키에 세션 ID만을 담아 전송하기 때문에 트래픽이 적게 사용됩니다. [참고 글](https://developer.okta.com/blog/2017/08/17/why-jwts-suck-as-session-tokens#size)에서의 비교를 보면 세션의 크키는 6 byte인 반면, JWT(최소한의 정보-`iss`, `sub`, `nbf`, `exp`, `ìat`, `jti`, `typ`)는 304 byte로 세션보다 약 50배 이상의 크기를 보유하고 있습니다.\n따라서 JWT가 상대적으로 크기 때문에 쿠키에서 사용될 때, 요청 당 오버헤드가 발생될 수 있다는 점이 있습니다.\n\n### 2. 서버에서 로그아웃 제어 불가\n\n만약 해커가 토큰을 탈취했다고 한다면, 토큰이 만료되지 않는 한 해커는 서버에 요청을 할 수 있게 됩니다. 그리고 서버의 무상태성 특징때문에 토큰이 탈취돼도 로그아웃을 강제로 못하는 문제가 있습니다.\n이러한 문제를 보안하기 위해서 다음의 작업들을 수행할 수도 있습니다.\n\n#### 1. access 토큰 짧은 만료기한 지정\n\n: 짧은 만료기한을 줘서 탈취돼도 오래 사용하지 못하도록 합니다.\n\n- **단점**\n  만료되기 전까지 해커가 요청을 보내게 된다는 점이 있고,\n  사용자가 매번 로그인해야되므로 편의성이 안좋아지는 단점이 생깁니다.\n\n#### 2. refresh 토큰 긴 만료기한 사용\n\n: 로그인을 유지하기 위해 access 토큰 발급받기 위한 긴 만료기한을 가진 토큰입니다. access의 짧은 만료기한으로 사용자가 매번 로그인하지 않도록 refresh가 있다면 갱신할 수 있도록 처리합니다.\n\n- **단점**\n  - access 만료기한 짧기 때문에 refresh 요청이 증가됩니다.\n  - 만약 해커가 refresh 토큰을 탈취했다면 문제가 심각해집니다. 그래서 보안이 중요한 서비스에서는 refresh 토큰을 사용하지 않기도 합니다.\n\n> #### Q) refresh 토큰이 탈취돼서 이를 로그아웃을 시키기 위해 서버 저장소를 두게 된다면?\n>\n> A) refresh 토큰 검증을 위해 중앙 집중식 저장소가 필요하게 된다. 그렇다면 서버 저장소, 클라이언트 저장이 필요해지면서 JWT의 최대 장점이었던 무상태성이 무효화됩니다. 따라서 세션과 유사한 방식으로 관리하게 됩니다.\n\n<br/>\n\n### 3. 클라이언트 측의 토큰 저장위치로 인한 보안문제\n\n브라우저의 웹 저장소(LocalStorage, SessionStorage)나 쿠키에 토큰을 저장하게 되면 XSS, CSRF 공격에 취약하다는 문제가 발생합니다.\n\n#### 1. LocalStorage | SessionStorage 저장 시\n\n저장하는 방법이 편리하긴 하지만 자바스크립트에서 `document.cookie`으로 접근이 가능하게 되면서 XSS(Cross Site Scripting) 공격에 취약하게 되므로 비권장됩니다.\n\n#### 2. Cookie 저장 시\n\n쿠키에 옵션을 주면 XSS, CSRF 공격에 조금 안전해질 수 있습니다.\n\n- 옵션\n  - `httpOnly` : XSS 공격에 조금 안전 (JS에서 `document.cookie`로 접근 불가)\n  - `secure=true` : `HTTPS` 일때만 쿠키 전송가능\n  - `sameSite=strict` : **CSRF(Cross-Site Request Forgery 사이트 간 요청 위조)** 방지.\n    같은 도메인일때만 쿠키 전송가능\n    - `lax`\n      명시안하면 적용되는 기본값. GET 요청에선 쿠키 전송가능. 다른 도메인으로 쿠키 전송불가\n    - `none`\n      도메인 달라도 항상 쿠키 전송가능. `secure` 옵션 붙여야 작동함\n    - `strict`\n      동일 도메인일때만 쿠키 전송가능\n\n<br/>\n\n> **😱 쿠키 secure 설정 시 주의사항**\n>\n> - 같은 도메인이더라도 `(FE 로컬)http - (서버)https` 환경에서는 refresh 쿠키 전달 못받음.\n>   서로 scheme이 달라서 다른 사이트로 인식한다. FE 로컬에서 작업할 때는 [추가 작업](https://velog.io/@yaytomato/React-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-https%EB%A1%9C-%EB%A1%9C%EC%BB%AC-%ED%85%8C%EC%8A%A4%ED%8C%85%ED%95%98%EA%B8%B0)이 필요하다.\n\n> **😱 쿠키 sameSite 설정 시 주의사항**\n>\n> - BE 서버가 FE와 같은 도메인일때만 사용가능.\n>   배포환경은 BE-FE 같은 도메인이라 괜찮지만\n>   개발환경에서 BE, FE가 다르면 크로스도메인 이슈 발생\n>\n> - 추가 세팅 필요\n>   도메인이 서로 다르면 서버에서 cors header를 설정하거나 refresh 토큰 요청을 인증된 사이트에서만 하도록 세팅해줘야한다.\n>   FE에서 `axios.defaults.withCredentials = true;` 설정도 필요하다.\n\n<br/>\n\n#### 각 토큰의 저장 위치는?\n\n1. access 토큰 저장소 - 로컬 변수로 저장\n\n   - 변수에 저장해서 XSS, CSRF공격으로부터 안전.\n   - 단, 새로고침하면 변수가 없어지므로 refresh로 재갱신 받는 요청을 수행해야 합니다. (slient refresh)\n\n2. refresh 토큰 - `secure httpOnly sameSite` 쿠키에 저장\n   - `httpOnly`- XSS에 조금 안전\n   - `secure` - HTTPS으로만 접속 가능\n   - `sameSite=strict`- CSRF에 조금 안전\n\n#### JWT 전달방식 정리\n\n1. 로그인 요청 성공 시, 응답으로 Access(짦은 유효기한) 발급받고 쿠키로 Refresh(긴 유효기한) 토큰을 발급받기.\n2. Refresh는 서버에서 `httpOnly secure sameSite` 옵션 설정한 쿠키로 저장하여 전송.\n3. Access는 클라이언트에서 로컬 변수에 저장하고, 권한 필요한 요청마다 Authorization 헤더에 `Bearer ${accessToken}`의 규격으로 전송.\n4. slient refresh로 Access 재발급 후 갱신하기\n\n- Access 만료 시)\n  쿠키에 Refresh가 이미 담겨진 상태로 요청마다 전송되어서 refresh로 재발급받는 API(`/refresh`)에 요청하고 응답으로 Access 받아서 갱신하기\n- 새로고침 시)\n  변수로 저장한 Access가 없어져서 재발급을 받아야 함.\n  쿠키에 Refresh가 이미 담겼기 때문에 refresh로 재발급받는 API(`/refresh`)에 요청하고 응답으로 Access 받아서 갱신하기\n\n5. Refresh 만료 시 재발급 후 갱신하거나 or 로그아웃 시키는 로직으로 구현\n\n#### 추가 참고사항\n\n- 강제 로그아웃을 위해 refresh를 서버에 저장할 수 있습니다.\n- 단, JWT에서 서버의 무상태성이란 장점은 무효화되고 세션과 비슷하게 관리하게 됩니다.\n\n<br/><br/><br/><br/>\n\n---\n\n<br/><br/>\n\n# 마치며\n\n결국 상황에 맞게 고려해서 방식을 채택해야 합니다. 서비스의 규모, 동시 접속자 수, 보안이 중요한 서비스 등등 상황들을 따져보고 선택하거나 두가지 인증 방식을 결합하여 구현할 수도 있습니다.\n각각의 트레이드 오프가 무엇인지 확인해보면서 전통적인 방식의 세션과 비교적 최신방식의 토큰 중 상황에 맞춰서 선택할 필요가 있습니다.\n<br/>\n따라서 JWT를 무조건 깃헙의 템플릿(보일러플레이트)에 기본으로 구성한다던지 앞으로의 프로젝트에 사용할 지는 충분히 고민을 해 본 후에 적용하는 것이 적절하다고 생각했습니다.\n<br/>\n만약, 보안이 중요한 서비스에서 강제 로그아웃을 구현해야한다면 서버의 refresh 저장소 구축에 대해서는 결국 세션과 유사한 방식이 되기 때문에 이렇게 된다면 그냥 세션을 사용하면 되지 않을까라는 생각이 들었습니다.\n또한 여기서 소개한 방법들이 모두 완벽한 정답은 아니므로 참고한다는 의미로 봐주시고 혹시나 잘못된 정보가 있었다면 자유롭게 댓글로 남겨주시면 감사하겠습니다.\n\n---\n\n<br/><br/><br/><br/>\n\n# 참조\n\n- [JWT should not be your default for sessions](https://evertpot.com/jwt-is-a-bad-default/)\n- [LocalStorage vs. Cookies: All You Need to Know About Storing JWT Tokens Securely in the Front-End](https://codeburst.io/localstorage-vs-cookies-all-you-need-to-know-about-storing-jwt-tokens-securely-in-the-front-end-70dc0a9b3ad3)\n- [🍪 프론트에서 안전하게 로그인 처리하기 (ft. React)](https://velog.io/@yaytomato/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%90%EC%84%9C-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0#%F0%9F%A7%9E%E2%99%82%EF%B8%8Ftldr)\n- [[프로젝트] Refresh Token 적용하기](https://pomo0703.tistory.com/208#recentComments)\n- [Access Token과 Refresh Token을 어디에 저장해야 할까?](https://velog.io/@ohzzi/Access-Token%EA%B3%BC-Refresh-Token%EC%9D%84-%EC%96%B4%EB%94%94%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C#%EA%B8%B0%ED%98%B8-1%EB%B2%88-%EB%A1%9C%EC%BB%AC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-or-%EC%84%B8%EC%85%98-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80)\n- 로그아웃 관련 참고 - [SpringBoot + Jwt를 이용한 로그아웃](https://velog.io/@joonghyun/SpringBoot-Jwt%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B7%B8%EC%95%84%EC%9B%83)\n',
  },
  {
    slug: 'sitemap-seo',
    title: 'NextJS로 만든 블로그 글 검색되게 하자! - sitemap, 검색엔진',
    content:
      '\n작성한 블로그 글이 네이버, 구글 등에서 검색되게 하고 싶다면?\n각 사이트 검색엔진에 블로그 주소를 등록하고 sitemap을 생성해야한다!\n\n# 1. sitemap\n\n[구글 사이트맵 설명](https://developers.google.com/search/docs/crawling-indexing/sitemaps/overview?hl=ko)\nsitemap이란?\n사이트에 있는 페이지, 동영상 등의 정보를 제공하는 파일이다.\n검색엔진이 sitemap 파일을 읽고 더 효율적으로 사이트를 크롤링할 수 있게 도움을 준다.\n따라서 검색했을 때 해당 사이트가 검색되게 하려면? sitemap을 생성해서 등록해주면 된다.\n검색엔진에 사이트맵 URL을 추가해야되기 때문에 먼저 sitemap 파일부터 생성해보자!\n\n## 방법 1. `next-sitemap` 라이브러리로 sitemap.xml 만들기\n\n- [next-sitemap](https://github.com/iamvishnusankar/next-sitemap) 라이브러리 설치\n\n```bash\nnpm i -D next-sitemap\n```\n\n- `next-sitemap.config.js` 생성하고\n\n  ```js:next-sitemap.config.js\n  /** @type {import(\'next-sitemap\').IConfig} */\n  module.exports = {\n    siteUrl: \'본인 사이트 url\',\n    changefreq: \'daily\',\n    priority: 0.7,\n    sitemapSize: 7000,\n    generateRobotsTxt: true,\n    exclude: [],\n  }\n  ```\n\n- `tsconfig.json`에 "next-sitemap.config.js"을 추가한다\n\n  ```json:tsconfig.json {6} showLineNumbers\n  "include": [\n    "next-env.d.ts",\n    "**/*.ts",\n    "**/*.tsx",\n    "**/*.d.ts",\n    "next-sitemap.config.js"\n  ],\n  ```\n\n- `package.json` 수정\n  ` "build": "next build && next-sitemap && next export",`\n\n- npm run build 하면\n  `public/robots.txt`, `public/sitemap.xml`, `public/sitemap-0.xml` 파일 생성됨\n  원격 push 안되게 gitignore에 추가하기\n\n> - `sitemap.xml` - 어떤 URL을 크롤링하는 지 알려주는 역할\n> - `robots.txt` - 어떤 URL에 접근할 수 있는지 검색엔진 크롤러에 알려주는 역할\n\n## 방법 2. 직접 sitemap.xml 만들기\n\n원래는 `next-sitemap` 라이브러리를 사용했는데 자꾸 구글 콘솔에 인식이 안되서 직접 만들기로 했다.\n\n# 2. 검색엔진 등록 방법\n\n### 검색엔진 종류\n\n내 블로그는 주로 사용하는 구글과 네이버 검색엔진을 등록하기로 했다.\n\n- 구글 서치 콘솔 - [Google Search Console](https://search.google.com/search-console/welcome?utm_source=about-page)\n- 네이버 서치 어드바이저- [Naver Search Advisor](https://searchadvisor.naver.com/)\n- [다음 검색등록](https://register.search.daum.net/index.daum)\n\n## [Google Search Console](https://search.google.com/search-console/welcome?utm_source=about-page)\n\n1. 사이트 등록 - 도메인이 있다면 도메인을 등록하거나, URL접두어를 등록하기\n   ![230308-123054](/images/posts/sitemap-seo/230308-123054.png)\n\n2. 아래의 HTML `meta` 태그를 `_document.tsx` `Head`에 추가\n   ![230308-123528](/images/posts/sitemap-seo/230308-123528.png)\n\n```js:_document.tsx {4-7} showLineNumbers\n    return (\n      <Html>\n        <Head>\n          <meta\n            name="google-site-verification"\n            content="복붙"\n          />\n          {/*  */}\n        </Head>\n          {/*  */}\n      </Html>\n    )\n```\n\n3. 배포까지 하면 `확인` 클릭\n4. 사이트맵 url `sitemap.xml` 제출\n\n![230309-111659](/images/posts/sitemap-seo/230309-111659.png)\n\n## [Naver Search Advisor](https://searchadvisor.naver.com/console/board)\n\n1. 사이트 등록\n2. `_document.tsx`에 HTML `meta` 태그 추가\n3. 배포 후 `소유확인` 클릭\n4. 요청 - 사이트맵 제출 `본인 url/sitemap.xml` 입력\n5. 검증 - robots.txt - 수집요청 클릭, 검증 확인받기\n6. 설정 - 수집주기설정 - `빠르게`\n',
  },
  {
    slug: 'v8-engine-01',
    title: 'JavaScript 실행하기 전 과정: V8 엔진의 작업 흐름',
    content:
      '\n# V8 엔진이란?\n\nC++로 작성된 Google의 오픈소스 **자바스크립트 및 WebAssembly 엔진**입니다. 오픈소스이기 때문에 [v8 github](https://github.com/v8/v8/tree/main)에서 소스코드를 확인할 수 있습니다.\n물론 자바스크립트 엔진에는 v8 외에도 Firefox (SpiderMonkey), Safari (JavaScriptCore), Microsoft Edge (Chakra 기반이었지만 최근 [Chromium](https://support.microsoft.com/en-us/microsoft-edge/download-the-new-microsoft-edge-based-on-chromium-0f4a3dd7-55df-60f5-739f-00010dba52cf), V8을 사용하여 다시 만들어짐) 등이 있습니다.\nChrome과 Node.js 등에서 사용되고, 자바스크립트 코드를 파싱하고 실행합니다. 또한 실행 속도를 높이는 등의 최적화 작업을 수행하기 위해서 JIT(Just In Time)컴파일러를 사용하고 있습니다.\n\n<br /><br /><br />\n\n---\n\n<br /><br /><br />\n\n## 파이프라인\n\nV8 엔진의 작업흐름을 전체적으로 파악하기 위해서 파이프라인을 살펴보도록 하겠습니다. 그런데 파이프라인의 역사?도 조금씩 변경된 부분들이 있어서 간단하게 살펴보고 넘어가겠습니다.\n\n#### 파이프라인의 변경\n\n- 2017년 이전 : Full-codegen + Crankshaft (+Ignition +TurboFan)\n  이후에 Ignition과 TurboFan로 대체되게 됩니다. [(사진출처)](https://v8.dev/blog/ignition-interpreter)\n\n  - ![](https://velog.velcdn.com/images/xmun74/post/e77dd87e-c8ec-42b0-8e00-f47b58c5954f/image.png)\n\n- 2017~2021년 : Ignition + TurboFan [(사진출처)](https://docs.google.com/presentation/d/1OqjVqRhtwlKeKfvMdX6HaCIu9wpZsrzqpIVIwQSuiXQ/edit#slide=id.g1453eb7f19_0_391)\n\n  - ![](https://velog.velcdn.com/images/xmun74/post/28911015-48f5-49d1-b2c1-946fa792f6e5/image.png)\n\n- 2021년(v9.1부터 변경된 파이프라인) : Ignition + `Sparkplug` + TurboFan [(사진출처)](https://v8.dev/blog/sparkplug)\n\n  - 중간에 Sparkplug가 추가되었습니다. ![](https://velog.velcdn.com/images/xmun74/post/a8b0f6bf-bd50-4658-87cf-be50cbeed96f/image.png)\n\n---\n\n- [(사진출처)](https://medium.com/@yanguly/sparkplug-v8-baseline-javascript-compiler-758a7bc96e84)![](https://velog.velcdn.com/images/xmun74/post/52b0873d-fe19-41cd-945e-4dcb8f47372f/image.png)\n\n이렇게 가장 최신의 파이프라인을 가지게 되었고 밑 내용대로 작업이 이뤄지게 됩니다.\n\n#### 1. JS 코드 -> AST로 Parsing\n\n- JavaScript 코드 -> AST(Abstract Syntax Tree: 추상구문트리로)로 파싱\n  코드를 컴퓨터가 쉽게 이해하도록 구조화하는 작업입니다.\n\n#### 2. Ignition(인터프리터)으로 Byte code 생성\n\n- AST를 바탕으로 바이트코드(Byte code)를 생성합니다.\n- 가상머신에서 실행되며 이때 인터프리터가 작동됩니다.\n\n#### 3. Sparkplug(비최적화 컴파일러)로 기계어 생성\n\n- 비최적화된 컴파일러로 바이트코드를 빠르게 네이티브 코드(기계어)로 변환\n\n#### 3. TurboFan(성능 최적화 컴파일러)로 기계어 생성\n\n- JIT 컴파일러 사용해서 바이트코드를 네이티브 코드(기계어)로 변환\n\n#### 4. 실행\n\n- 생성한 네이티브 코드를 CPU에서 실행\n  - 초기실행에서는 비최적화된 네이티브 코드가 실행되고\n  - 이후 성능최적화 작업을 거쳐 최적화된 네이티브 코드를 실행합니다.\n\n<br /><br />\n\n---\n\n## 1. JS를 AST로 파싱 : 코드 구조 이해하기\n\n사람이 작성한 JS 코드를 컴퓨터가 이해할 수 있도록 계층적 구조로 만들어줘야 합니다.\n\n```js\nlet x = \'문자열\' // 지금은 문자열 String\nx = 1 // 이제는 숫자 Number\n```\n\n그리고 JS는 동적 언어이기 때문에 실행중에 타입이 바뀌기도 합니다. 실행 전에 타입을 고정하기가 어렵습니다. 이러한 JS의 복잡한 동작을 처리하기 위해서는 먼저 코드 구조를 파악해야합니다. 그래서 코드를 실행하기 전에 컴퓨터가 이해하기 쉬운 AST로 구조화해두게 됩니다. 이렇게 해두면 이후 컴파일이나 최적화 작업을 효율적으로 처리할 수 있습니다. 타입 정보는 이후 코드를 실행할 때 동적으로 학습하게 됩니다.\n<br/>\n\n1. parser\n   즉시 실행에 필요한 코드를 전체 파싱합니다. 하지만 처리시간이 상대적으로 깁니다.\n\n   - AST, 스코프 생성\n   - 문법 오류 검출\n   - 소스코드 [(v8/src/parsing/parser.cc)](https://github.com/v8/v8/blob/main/src/parsing/parser.cc)\n\n2. [pre-parser](https://v8.dev/blog/preparser)\n   즉시 실행에 필요한 코드가 아니고 나중에 실행될 코드일 때 사용하는 파서입니다.\n\n   - AST 미생성, 스코프 생성\n   - 일부 문법 오류만 검출\n   - 소스코드 [(v8/src/parsing/preparser.cc)](https://github.com/v8/v8/blob/main/src/parsing/preparser.cc)\n\n<br/>\n파서는 위에 parser와 pre-parser(lazy-parser) 2개로 구분되어 사용됩니다.\n실행되지 않는 함수나 코드를 전부 일반 파서로 처리하면 초기 로딩시간이 길어지기 때문에 pre-parser(lazy-parser)로 초기 로딩 시간을 단축시키는 것이 목적입니다.\n\n- 예시 코드\n\n  ```js\n  const name = \'유재석\'\n  console.log(name) // parser\n\n  function greeting() {\n    console.log(\'Hello!\') // pre-parser\n  }\n\n  greeting() // 나중에 호출될 때 parser\n  ```\n\n<br/><br/>\n그리고 밑처럼 AST로 파싱한 결과물을 보고 싶다면 [AST Explorer](https://astexplorer.net/) 사이트에서 테스트해볼 수 있습니다.\n\n- JS 코드\n\n```js\nconst name = \'유재석\'\n```\n\n- AST 파싱 후\n\n```json\n{\n  "type": "Program",\n  "start": 0,\n  "end": 19,\n  "body": [\n    {\n      "type": "VariableDeclaration", // 변수 선언\n      "start": 0,\n      "end": 19,\n      "declarations": [\n        {\n          "type": "VariableDeclarator", // 대입문\n          "start": 6,\n          "end": 18,\n          "id": {\n            "type": "Identifier", // 변수 식별자\n            "start": 6,\n            "end": 10,\n            "name": "name" // 식별자명\n          },\n          "init": {\n            "type": "Literal", // 리터럴 값\n            "start": 13,\n            "end": 18,\n            "value": "유재석", // 실제 값\n            "raw": "\'유재석\'"\n          }\n        }\n      ],\n      "kind": "const"\n    }\n  ],\n  "sourceType": "module"\n}\n```\n\n<br /><br />\n\n---\n\n## 2. Ignition interpreter로 Byte code로 변환하기\n\n- [이미지 출처 - v8](https://v8.dev/blog/background-compilation)\n  ![](https://velog.velcdn.com/images/xmun74/post/55e235c0-1763-480e-b152-4ce4c86ac7d0/image.png)\n\n: 코드 한줄 실행할때마다 AST를 받아서 바이트코드로 반환해주는 인터프리터\n<br/>\n\n- **메모리 사용량을 감소**하기 위해 컴파일러가 아닌 인터프리터를 사용\n  : 컴파일러는 실행되지 않을 코드까지 네이티브 코드(기계어)로 변환해서 메모리 낭비가 발생하지만,\n  인터프리터는 바이트코드로 변환하기 때문에 상대적으로 용량도 작고, 한 줄씩 실행될때마다 변환하여 메모리 사용에 효율적입니다.\n  <br />\n\n- 이전 방식이었던 Full-codegen 대체하는 인터프리터\n  Full-codegen 컴파일의 단점으로 인해 인터프리터 단계가 추가되었다고 보시면 됩니다. 초기에 코드 실행 시 복잡한 네이티브 코드 생성이나 최적화를 건너뛰고, 빠르게 바이트코드를 사용해서 실행시키는 것에 초점이 맞춰져 있습니다.\n  <br />\n\n  > 마지막으로 바이트코드를 생성하는 것이 Full-codegen의 기준 컴파일된 코드를 생성하는 것보다 빠르기 때문에 Ignition을 활성화하면 일반적으로 스크립트 시작 시간이 개선되고 결과적으로 웹 페이지 로드도 개선됩니다.\n  >\n  > [- v8 Launching Ignition and TurboFan 본문 중 -](https://v8.dev/blog/launching-ignition-and-turbofan)\n\n<br />\n- 터미널에서 바이트코드 출력해보기\n  코드를 바이트코드로 보고 싶으면 `node --print-bytecode index.js`를 실행해보면 확인할 수 있습니다. 참고사항으로는 만약 함수면 함수를 실행해야 결과물을 확인할 수 있습니다.\n\n<br /><br />\n\n---\n\n## 3. Sparkplug 비최적화 컴파일러 도입\n\n: 터보팬과 달리 최적화를 수행하지 않고 바이트코드를 -> 기계어 코드로 빠르게 생성하는 컴파일러\n\n- 이그니션 - 터보팬의 중간단계인 **비최적화 컴파일러**\n- 바이트코드 기반으로 네이티브코드(기계어) 생성하므로 속도가 빠름\n- 터보팬에 비해서 최적화 작업을 생략하기 때문에 메모리 사용량 적음(최적화는 터보팬에 맡김)\n  최적화하는 데에는 비용이 발생합니다. 그런데 이전에 너무 섣부린 최적화로 인한 비용이 발생했었기 때문에 이러한 문제를 덜고자 심플한 비최적화 컴파일러를 도입하게 됩니다.\n\n## 4. 필요시 Turbofan compiler로 성능 최적화\n\n: 최적화 작업을 수행해서 바이트코드를 머신코드로 변환하는 컴파일러\n\n- 바이트코드를 분석해서 JIT 컴파일러로 성능 최적화 작업을 수행합니다.\n- 터미널에서 최적화 코드 로그 출력해보기\n  `node --trace-opt index.js`\n\n<br/><br/><br/><br/>\n\n> ### 자동차 엔진의 구조를 메타포로 사용한 용어 설명\n\n처음에 작업흐름을 쭉 살펴보면 용어들이 굉장히 생소하게 느껴질 수 있습니다. 하지만 이 용어들이 어디서 차용되었는지를 이해하면 나중에 해당 내용들을 다시봐도 직관적으로 이해할 수 있기 때문에 마지막으로 간단하게 살펴보겠습니다.\n\n#### V8\n\n: 경주용 자동차나 비행기에서 사용되는 엔진으로, v자 형태의 8기통 고성능 엔진인 [v8](https://en.wikipedia.org/wiki/V8_engine)의 이름을 따서 만들었습니다. (이게 진짜 엔진이름인 줄은 몰랐습니다..)\n\n<img\n  src="/images/posts/v8-engine-01/241123-223547.png"\n  width="200"\n  height="200"\n/>\n\n#### Ignition(점화)\n\n: 엔진을 가동시키는 점화 작업으로, JS코드를 빠르게 실행가능한 단계인 바이트코드로 변환하는 작업을 떠올리면 됩니다.\n\n#### TurboFan\n\n: 자동차 엔진의 터보차저로 고성능 가속 작업에 해당합니다. 이는 성능 최적화 작업을 수행하는 JIT 컴파일러를 떠올리면 됩니다.\n\n<br /><br /><br /><br />\n\n---\n\n<br /><br /><br /><br />\n\n여기까지 V8 엔진의 작업 흐름에 대해서 살펴보았습니다. 이번 편에서는 Spartplug나 TurboFan에 대해서 깊게 보지 않았는데... 관련 내용들이 살펴볼게 좀 있고, 뭔가 글이 너무 길어질 것 같아서 다음 블로그 글로 써보려고 합니다!\n\n<br /><br /><br /><br />\n\n---\n\n# 참고\n\n- [V8 github](https://github.com/v8/v8)\n- https://evan-moon.github.io/2019/06/28/v8-analysis/\n- [Youtube - BlinkOn 6 Day 1 Talk 2: Ignition - an interpreter for V8](https://www.youtube.com/watch?v=r5OWCtuKiAk)\n',
  },
]
